(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module2) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty7 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty7.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module2.exports = ReactPropTypesSecret;
    }
  });

  // node_modules/prop-types/lib/has.js
  var require_has = __commonJS({
    "node_modules/prop-types/lib/has.js"(exports, module2) {
      module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "node_modules/prop-types/checkPropTypes.js"(exports, module2) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has = require_has();
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has;
      function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
              } catch (ex) {
                error = ex;
              }
              if (error && !(error instanceof Error)) {
                printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
              }
              if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                loggedTypeFailures[error.message] = true;
                var stack = getStack ? getStack() : "";
                printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
              }
            }
          }
        }
      }
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module2.exports = checkPropTypes;
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var _assign = require_object_assign();
          var checkPropTypes = require_checkPropTypes();
          var ReactVersion = "16.14.0";
          var hasSymbol2 = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol2 ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol2 ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol2 ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol2 ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol2 ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol2 ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol2 ? Symbol.for("react.context") : 60110;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol2 ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol2 ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol2 ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol2 ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol2 ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol2 ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol2 ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol2 ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol2 ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol2 ? Symbol.for("react.scope") : 60119;
          var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            current: null
          };
          var ReactCurrentBatchConfig = {
            suspense: null
          };
          var ReactCurrentOwner = {
            current: null
          };
          var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
          function describeComponentFrame(name, source, ownerName) {
            var sourceInfo = "";
            if (source) {
              var path = source.fileName;
              var fileName = path.replace(BEFORE_SLASH_RE, "");
              {
                if (/^index\./.test(fileName)) {
                  var match = path.match(BEFORE_SLASH_RE);
                  if (match) {
                    var pathBeforeSlash = match[1];
                    if (pathBeforeSlash) {
                      var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                      fileName = folderName + "/" + fileName;
                    }
                  }
                }
              }
              sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
            } else if (ownerName) {
              sourceInfo = " (created by " + ownerName + ")";
            }
            return "\n    in " + (name || "Unknown") + sourceInfo;
          }
          var Resolved = 1;
          function refineResolvedLazyComponent(lazyComponent) {
            return lazyComponent._status === Resolved ? lazyComponent._result : null;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getComponentName(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  return "Context.Consumer";
                case REACT_PROVIDER_TYPE:
                  return "Context.Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  return getComponentName(type.type);
                case REACT_BLOCK_TYPE:
                  return getComponentName(type.render);
                case REACT_LAZY_TYPE: {
                  var thenable = type;
                  var resolvedThenable = refineResolvedLazyComponent(thenable);
                  if (resolvedThenable) {
                    return getComponentName(resolvedThenable);
                  }
                  break;
                }
              }
            }
            return null;
          }
          var ReactDebugCurrentFrame = {};
          var currentlyValidatingElement = null;
          function setCurrentlyValidatingElement(element) {
            {
              currentlyValidatingElement = element;
            }
          }
          {
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentlyValidatingElement) {
                var name = getComponentName(currentlyValidatingElement.type);
                var owner = currentlyValidatingElement._owner;
                stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var IsSomeRendererActing = {
            current: false
          };
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner,
            IsSomeRendererActing,
            assign: _assign
          };
          {
            _assign(ReactSharedInternals, {
              ReactDebugCurrentFrame,
              ReactComponentTreeHook: {}
            });
          }
          function warn(format) {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
          function error(format) {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
          function printWarning(level, format, args) {
            {
              var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === "string" && args[args.length - 1].indexOf("\n    in") === 0;
              if (!hasExistingStack) {
                var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame2.getStackAddendum();
                if (stack !== "") {
                  format += "%s";
                  args = args.concat([stack]);
                }
              }
              var argsWithFormat = args.map(function(item) {
                return "" + item;
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
              try {
                var argIndex = 0;
                var message = "Warning: " + format.replace(/%s/g, function() {
                  return args[argIndex++];
                });
                throw new Error(message);
              } catch (x) {
              }
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
              return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var emptyObject2 = {};
          {
            Object.freeze(emptyObject2);
          }
          function Component6(props, context2, updater) {
            this.props = props;
            this.context = context2;
            this.refs = emptyObject2;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component6.prototype.isReactComponent = {};
          Component6.prototype.setState = function(partialState, callback) {
            if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
              {
                throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
              }
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component6.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component6.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component6.prototype;
          function PureComponent18(props, context2, updater) {
            this.props = props;
            this.context = context2;
            this.refs = emptyObject2;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent18.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent18;
          _assign(pureComponentPrototype, Component6.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef4() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var hasOwnProperty7 = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty7.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty7.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                var componentName = getComponentName(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement15(type, config, children2) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config);
                }
              }
              if (hasValidKey(config)) {
                key = "" + config.key;
              }
              self2 = config.__self === void 0 ? null : config.__self;
              source = config.__source === void 0 ? null : config.__source;
              for (propName in config) {
                if (hasOwnProperty7.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children2;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps2 = type.defaultProps;
              for (propName in defaultProps2) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps2[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement2(element, config, children2) {
            if (!!(element === null || element === void 0)) {
              {
                throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
              }
            }
            var propName;
            var props = _assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config)) {
                key = "" + config.key;
              }
              var defaultProps2;
              if (element.type && element.type.defaultProps) {
                defaultProps2 = element.type.defaultProps;
              }
              for (propName in config) {
                if (hasOwnProperty7.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config[propName] === void 0 && defaultProps2 !== void 0) {
                    props[propName] = defaultProps2[propName];
                  } else {
                    props[propName] = config[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children2;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement3(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = ("" + key).replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return ("" + text).replace(userProvidedKeyEscapeRegex, "$&/");
          }
          var POOL_SIZE = 10;
          var traverseContextPool = [];
          function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
            if (traverseContextPool.length) {
              var traverseContext = traverseContextPool.pop();
              traverseContext.result = mapResult;
              traverseContext.keyPrefix = keyPrefix;
              traverseContext.func = mapFunction;
              traverseContext.context = mapContext;
              traverseContext.count = 0;
              return traverseContext;
            } else {
              return {
                result: mapResult,
                keyPrefix,
                func: mapFunction,
                context: mapContext,
                count: 0
              };
            }
          }
          function releaseTraverseContext(traverseContext) {
            traverseContext.result = null;
            traverseContext.keyPrefix = null;
            traverseContext.func = null;
            traverseContext.context = null;
            traverseContext.count = 0;
            if (traverseContextPool.length < POOL_SIZE) {
              traverseContextPool.push(traverseContext);
            }
          }
          function traverseAllChildrenImpl(children2, nameSoFar, callback, traverseContext) {
            var type = typeof children2;
            if (type === "undefined" || type === "boolean") {
              children2 = null;
            }
            var invokeCallback = false;
            if (children2 === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children2.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              callback(traverseContext, children2, nameSoFar === "" ? SEPARATOR + getComponentKey(children2, 0) : nameSoFar);
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (Array.isArray(children2)) {
              for (var i = 0; i < children2.length; i++) {
                child = children2[i];
                nextName = nextNamePrefix + getComponentKey(child, i);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            } else {
              var iteratorFn = getIteratorFn(children2);
              if (typeof iteratorFn === "function") {
                {
                  if (iteratorFn === children2.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is deprecated and will be removed in a future major release. Consider converting children to an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(children2);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getComponentKey(child, ii++);
                  subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
                }
              } else if (type === "object") {
                var addendum = "";
                {
                  addendum = " If you meant to render a collection of children, use an array instead." + ReactDebugCurrentFrame.getStackAddendum();
                }
                var childrenString = "" + children2;
                {
                  {
                    throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children2).join(", ") + "}" : childrenString) + ")." + addendum);
                  }
                }
              }
            }
            return subtreeCount;
          }
          function traverseAllChildren(children2, callback, traverseContext) {
            if (children2 == null) {
              return 0;
            }
            return traverseAllChildrenImpl(children2, "", callback, traverseContext);
          }
          function getComponentKey(component, index2) {
            if (typeof component === "object" && component !== null && component.key != null) {
              return escape(component.key);
            }
            return index2.toString(36);
          }
          function forEachSingleChild(bookKeeping, child, name) {
            var func = bookKeeping.func, context2 = bookKeeping.context;
            func.call(context2, child, bookKeeping.count++);
          }
          function forEachChildren(children2, forEachFunc, forEachContext) {
            if (children2 == null) {
              return children2;
            }
            var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
            traverseAllChildren(children2, forEachSingleChild, traverseContext);
            releaseTraverseContext(traverseContext);
          }
          function mapSingleChildIntoContext(bookKeeping, child, childKey) {
            var result2 = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context2 = bookKeeping.context;
            var mappedChild = func.call(context2, child, bookKeeping.count++);
            if (Array.isArray(mappedChild)) {
              mapIntoWithKeyPrefixInternal(mappedChild, result2, childKey, function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement3(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + "/" : "") + childKey);
              }
              result2.push(mappedChild);
            }
          }
          function mapIntoWithKeyPrefixInternal(children2, array, prefix2, func, context2) {
            var escapedPrefix = "";
            if (prefix2 != null) {
              escapedPrefix = escapeUserProvidedKey(prefix2) + "/";
            }
            var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context2);
            traverseAllChildren(children2, mapSingleChildIntoContext, traverseContext);
            releaseTraverseContext(traverseContext);
          }
          function mapChildren(children2, func, context2) {
            if (children2 == null) {
              return children2;
            }
            var result2 = [];
            mapIntoWithKeyPrefixInternal(children2, result2, null, func, context2);
            return result2;
          }
          function countChildren(children2) {
            return traverseAllChildren(children2, function() {
              return null;
            }, null);
          }
          function toArray2(children2) {
            var result2 = [];
            mapIntoWithKeyPrefixInternal(children2, result2, null, function(child) {
              return child;
            });
            return result2;
          }
          function onlyChild2(children2) {
            if (!isValidElement3(children2)) {
              {
                throw Error("React.Children.only expected to receive a single React element child.");
              }
            }
            return children2;
          }
          function createContext15(defaultValue, calculateChangedBits) {
            if (calculateChangedBits === void 0) {
              calculateChangedBits = null;
            } else {
              {
                if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                  error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
                }
              }
            }
            var context2 = {
              $$typeof: REACT_CONTEXT_TYPE,
              _calculateChangedBits: calculateChangedBits,
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              _threadCount: 0,
              Provider: null,
              Consumer: null
            };
            context2.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context2
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context2,
                _calculateChangedBits: context2._calculateChangedBits
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context2.Provider;
                  },
                  set: function(_Provider) {
                    context2.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context2._currentValue;
                  },
                  set: function(_currentValue) {
                    context2._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context2._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context2._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context2._threadCount;
                  },
                  set: function(_threadCount) {
                    context2._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context2.Consumer;
                  }
                }
              });
              context2.Consumer = Consumer;
            }
            {
              context2._currentRenderer = null;
              context2._currentRenderer2 = null;
            }
            return context2;
          }
          function lazy(ctor) {
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _ctor: ctor,
              _status: -1,
              _result: null
            };
            {
              var defaultProps2;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps2;
                  },
                  set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps2 = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef5(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            return {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
          }
          function isValidElementType2(type) {
            return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function memo7(type, compare) {
            {
              if (!isValidElementType2(type)) {
                error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            return {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            if (!(dispatcher !== null)) {
              {
                throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext14(Context, unstable_observedBits) {
            var dispatcher = resolveDispatcher();
            {
              if (unstable_observedBits !== void 0) {
                error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://fb.me/rules-of-hooks" : "");
              }
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context, unstable_observedBits);
          }
          function useState17(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
          }
          function useRef16(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect24(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
          }
          function useLayoutEffect4(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
          }
          function useCallback16(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo6(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
          }
          function useImperativeHandle2(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
          }
          function useDebugValue(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentName(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement(element);
            {
              error('Each child in a list should have a unique "key" prop.%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
            }
            setCurrentlyValidatingElement(null);
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (Array.isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement3(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement3(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement3(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var name = getComponentName(type);
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                setCurrentlyValidatingElement(element);
                checkPropTypes(propTypes, element.props, "prop", name, ReactDebugCurrentFrame.getStackAddendum);
                setCurrentlyValidatingElement(null);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              setCurrentlyValidatingElement(fragment);
              var keys = Object.keys(fragment.props);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (key !== "children" && key !== "key") {
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  break;
                }
              }
              if (fragment.ref !== null) {
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
              }
              setCurrentlyValidatingElement(null);
            }
          }
          function createElementWithValidation(type, props, children2) {
            var validType = isValidElementType2(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (Array.isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement15.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children2) {
            var newElement = cloneElement2.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          {
            try {
              var frozenObject = Object.freeze({});
              var testMap = /* @__PURE__ */ new Map([[frozenObject, null]]);
              var testSet = /* @__PURE__ */ new Set([frozenObject]);
              testMap.set(0, 0);
              testSet.add(0);
            } catch (e) {
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children8 = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray2,
            only: onlyChild2
          };
          exports.Children = Children8;
          exports.Component = Component6;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent18;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext15;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef4;
          exports.forwardRef = forwardRef5;
          exports.isValidElement = isValidElement3;
          exports.lazy = lazy;
          exports.memo = memo7;
          exports.useCallback = useCallback16;
          exports.useContext = useContext14;
          exports.useDebugValue = useDebugValue;
          exports.useEffect = useEffect24;
          exports.useImperativeHandle = useImperativeHandle2;
          exports.useLayoutEffect = useLayoutEffect4;
          exports.useMemo = useMemo6;
          exports.useReducer = useReducer;
          exports.useRef = useRef16;
          exports.useState = useState17;
          exports.version = ReactVersion;
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var enableSchedulerDebugging = false;
          var enableProfiling = true;
          var requestHostCallback;
          var requestHostTimeout;
          var cancelHostTimeout;
          var shouldYieldToHost;
          var requestPaint;
          if (typeof window === "undefined" || typeof MessageChannel !== "function") {
            var _callback = null;
            var _timeoutID = null;
            var _flushCallback = function() {
              if (_callback !== null) {
                try {
                  var currentTime = exports.unstable_now();
                  var hasRemainingTime = true;
                  _callback(hasRemainingTime, currentTime);
                  _callback = null;
                } catch (e) {
                  setTimeout(_flushCallback, 0);
                  throw e;
                }
              }
            };
            var initialTime = Date.now();
            exports.unstable_now = function() {
              return Date.now() - initialTime;
            };
            requestHostCallback = function(cb) {
              if (_callback !== null) {
                setTimeout(requestHostCallback, 0, cb);
              } else {
                _callback = cb;
                setTimeout(_flushCallback, 0);
              }
            };
            requestHostTimeout = function(cb, ms) {
              _timeoutID = setTimeout(cb, ms);
            };
            cancelHostTimeout = function() {
              clearTimeout(_timeoutID);
            };
            shouldYieldToHost = function() {
              return false;
            };
            requestPaint = exports.unstable_forceFrameRate = function() {
            };
          } else {
            var performance2 = window.performance;
            var _Date = window.Date;
            var _setTimeout = window.setTimeout;
            var _clearTimeout = window.clearTimeout;
            if (typeof console !== "undefined") {
              var requestAnimationFrame2 = window.requestAnimationFrame;
              var cancelAnimationFrame2 = window.cancelAnimationFrame;
              if (typeof requestAnimationFrame2 !== "function") {
                console["error"]("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
              }
              if (typeof cancelAnimationFrame2 !== "function") {
                console["error"]("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
              }
            }
            if (typeof performance2 === "object" && typeof performance2.now === "function") {
              exports.unstable_now = function() {
                return performance2.now();
              };
            } else {
              var _initialTime = _Date.now();
              exports.unstable_now = function() {
                return _Date.now() - _initialTime;
              };
            }
            var isMessageLoopRunning = false;
            var scheduledHostCallback = null;
            var taskTimeoutID = -1;
            var yieldInterval = 5;
            var deadline = 0;
            {
              shouldYieldToHost = function() {
                return exports.unstable_now() >= deadline;
              };
              requestPaint = function() {
              };
            }
            exports.unstable_forceFrameRate = function(fps) {
              if (fps < 0 || fps > 125) {
                console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported");
                return;
              }
              if (fps > 0) {
                yieldInterval = Math.floor(1e3 / fps);
              } else {
                yieldInterval = 5;
              }
            };
            var performWorkUntilDeadline = function() {
              if (scheduledHostCallback !== null) {
                var currentTime = exports.unstable_now();
                deadline = currentTime + yieldInterval;
                var hasTimeRemaining = true;
                try {
                  var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                  if (!hasMoreWork) {
                    isMessageLoopRunning = false;
                    scheduledHostCallback = null;
                  } else {
                    port.postMessage(null);
                  }
                } catch (error) {
                  port.postMessage(null);
                  throw error;
                }
              } else {
                isMessageLoopRunning = false;
              }
            };
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            requestHostCallback = function(callback) {
              scheduledHostCallback = callback;
              if (!isMessageLoopRunning) {
                isMessageLoopRunning = true;
                port.postMessage(null);
              }
            };
            requestHostTimeout = function(callback, ms) {
              taskTimeoutID = _setTimeout(function() {
                callback(exports.unstable_now());
              }, ms);
            };
            cancelHostTimeout = function() {
              _clearTimeout(taskTimeoutID);
              taskTimeoutID = -1;
            };
          }
          function push(heap, node) {
            var index2 = heap.length;
            heap.push(node);
            siftUp(heap, node, index2);
          }
          function peek(heap) {
            var first = heap[0];
            return first === void 0 ? null : first;
          }
          function pop(heap) {
            var first = heap[0];
            if (first !== void 0) {
              var last = heap.pop();
              if (last !== first) {
                heap[0] = last;
                siftDown(heap, last, 0);
              }
              return first;
            } else {
              return null;
            }
          }
          function siftUp(heap, node, i) {
            var index2 = i;
            while (true) {
              var parentIndex = index2 - 1 >>> 1;
              var parent = heap[parentIndex];
              if (parent !== void 0 && compare(parent, node) > 0) {
                heap[parentIndex] = node;
                heap[index2] = parent;
                index2 = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i) {
            var index2 = i;
            var length = heap.length;
            while (index2 < length) {
              var leftIndex = (index2 + 1) * 2 - 1;
              var left = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right = heap[rightIndex];
              if (left !== void 0 && compare(left, node) < 0) {
                if (right !== void 0 && compare(right, left) < 0) {
                  heap[index2] = right;
                  heap[rightIndex] = node;
                  index2 = rightIndex;
                } else {
                  heap[index2] = left;
                  heap[leftIndex] = node;
                  index2 = leftIndex;
                }
              } else if (right !== void 0 && compare(right, node) < 0) {
                heap[index2] = right;
                heap[rightIndex] = node;
                index2 = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare(a, b) {
            var diff = a.sortIndex - b.sortIndex;
            return diff !== 0 ? diff : a.id - b.id;
          }
          var NoPriority = 0;
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          var runIdCounter = 0;
          var mainThreadIdCounter = 0;
          var profilingStateSize = 4;
          var sharedProfilingBuffer = typeof SharedArrayBuffer === "function" ? new SharedArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : typeof ArrayBuffer === "function" ? new ArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : null;
          var profilingState = sharedProfilingBuffer !== null ? new Int32Array(sharedProfilingBuffer) : [];
          var PRIORITY = 0;
          var CURRENT_TASK_ID = 1;
          var CURRENT_RUN_ID = 2;
          var QUEUE_SIZE = 3;
          {
            profilingState[PRIORITY] = NoPriority;
            profilingState[QUEUE_SIZE] = 0;
            profilingState[CURRENT_TASK_ID] = 0;
          }
          var INITIAL_EVENT_LOG_SIZE = 131072;
          var MAX_EVENT_LOG_SIZE = 524288;
          var eventLogSize = 0;
          var eventLogBuffer = null;
          var eventLog = null;
          var eventLogIndex = 0;
          var TaskStartEvent = 1;
          var TaskCompleteEvent = 2;
          var TaskErrorEvent = 3;
          var TaskCancelEvent = 4;
          var TaskRunEvent = 5;
          var TaskYieldEvent = 6;
          var SchedulerSuspendEvent = 7;
          var SchedulerResumeEvent = 8;
          function logEvent(entries) {
            if (eventLog !== null) {
              var offset = eventLogIndex;
              eventLogIndex += entries.length;
              if (eventLogIndex + 1 > eventLogSize) {
                eventLogSize *= 2;
                if (eventLogSize > MAX_EVENT_LOG_SIZE) {
                  console["error"]("Scheduler Profiling: Event log exceeded maximum size. Don't forget to call `stopLoggingProfilingEvents()`.");
                  stopLoggingProfilingEvents();
                  return;
                }
                var newEventLog = new Int32Array(eventLogSize * 4);
                newEventLog.set(eventLog);
                eventLogBuffer = newEventLog.buffer;
                eventLog = newEventLog;
              }
              eventLog.set(entries, offset);
            }
          }
          function startLoggingProfilingEvents() {
            eventLogSize = INITIAL_EVENT_LOG_SIZE;
            eventLogBuffer = new ArrayBuffer(eventLogSize * 4);
            eventLog = new Int32Array(eventLogBuffer);
            eventLogIndex = 0;
          }
          function stopLoggingProfilingEvents() {
            var buffer = eventLogBuffer;
            eventLogSize = 0;
            eventLogBuffer = null;
            eventLog = null;
            eventLogIndex = 0;
            return buffer;
          }
          function markTaskStart(task, ms) {
            {
              profilingState[QUEUE_SIZE]++;
              if (eventLog !== null) {
                logEvent([TaskStartEvent, ms * 1e3, task.id, task.priorityLevel]);
              }
            }
          }
          function markTaskCompleted(task, ms) {
            {
              profilingState[PRIORITY] = NoPriority;
              profilingState[CURRENT_TASK_ID] = 0;
              profilingState[QUEUE_SIZE]--;
              if (eventLog !== null) {
                logEvent([TaskCompleteEvent, ms * 1e3, task.id]);
              }
            }
          }
          function markTaskCanceled(task, ms) {
            {
              profilingState[QUEUE_SIZE]--;
              if (eventLog !== null) {
                logEvent([TaskCancelEvent, ms * 1e3, task.id]);
              }
            }
          }
          function markTaskErrored(task, ms) {
            {
              profilingState[PRIORITY] = NoPriority;
              profilingState[CURRENT_TASK_ID] = 0;
              profilingState[QUEUE_SIZE]--;
              if (eventLog !== null) {
                logEvent([TaskErrorEvent, ms * 1e3, task.id]);
              }
            }
          }
          function markTaskRun(task, ms) {
            {
              runIdCounter++;
              profilingState[PRIORITY] = task.priorityLevel;
              profilingState[CURRENT_TASK_ID] = task.id;
              profilingState[CURRENT_RUN_ID] = runIdCounter;
              if (eventLog !== null) {
                logEvent([TaskRunEvent, ms * 1e3, task.id, runIdCounter]);
              }
            }
          }
          function markTaskYield(task, ms) {
            {
              profilingState[PRIORITY] = NoPriority;
              profilingState[CURRENT_TASK_ID] = 0;
              profilingState[CURRENT_RUN_ID] = 0;
              if (eventLog !== null) {
                logEvent([TaskYieldEvent, ms * 1e3, task.id, runIdCounter]);
              }
            }
          }
          function markSchedulerSuspended(ms) {
            {
              mainThreadIdCounter++;
              if (eventLog !== null) {
                logEvent([SchedulerSuspendEvent, ms * 1e3, mainThreadIdCounter]);
              }
            }
          }
          function markSchedulerUnsuspended(ms) {
            {
              if (eventLog !== null) {
                logEvent([SchedulerResumeEvent, ms * 1e3, mainThreadIdCounter]);
              }
            }
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          function advanceTimers(currentTime) {
            var timer = peek(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop(timerQueue);
              } else if (timer.startTime <= currentTime) {
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push(taskQueue, timer);
                {
                  markTaskStart(timer, currentTime);
                  timer.isQueued = true;
                }
              } else {
                return;
              }
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            {
              markSchedulerUnsuspended(initialTime2);
            }
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error) {
                  if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
              {
                var _currentTime = exports.unstable_now();
                markSchedulerSuspended(_currentTime);
              }
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                break;
              }
              var callback = currentTask.callback;
              if (callback !== null) {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                markTaskRun(currentTask, currentTime);
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                  markTaskYield(currentTask, currentTime);
                } else {
                  {
                    markTaskCompleted(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function timeoutForPriorityLevel(priorityLevel) {
            switch (priorityLevel) {
              case ImmediatePriority:
                return IMMEDIATE_PRIORITY_TIMEOUT;
              case UserBlockingPriority:
                return USER_BLOCKING_PRIORITY;
              case IdlePriority:
                return IDLE_PRIORITY;
              case LowPriority:
                return LOW_PRIORITY_TIMEOUT;
              case NormalPriority:
              default:
                return NORMAL_PRIORITY_TIMEOUT;
            }
          }
          function unstable_scheduleCallback(priorityLevel, callback, options) {
            var currentTime = exports.unstable_now();
            var startTime;
            var timeout2;
            if (typeof options === "object" && options !== null) {
              var delay = options.delay;
              if (typeof delay === "number" && delay > 0) {
                startTime = currentTime + delay;
              } else {
                startTime = currentTime;
              }
              timeout2 = typeof options.timeout === "number" ? options.timeout : timeoutForPriorityLevel(priorityLevel);
            } else {
              timeout2 = timeoutForPriorityLevel(priorityLevel);
              startTime = currentTime;
            }
            var expirationTime = startTime + timeout2;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime,
              expirationTime,
              sortIndex: -1
            };
            {
              newTask.isQueued = false;
            }
            if (startTime > currentTime) {
              newTask.sortIndex = startTime;
              push(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push(taskQueue, newTask);
              {
                markTaskStart(newTask, currentTime);
                newTask.isQueued = true;
              }
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            {
              if (task.isQueued) {
                var currentTime = exports.unstable_now();
                markTaskCanceled(task, currentTime);
                task.isQueued = false;
              }
            }
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          function unstable_shouldYield() {
            var currentTime = exports.unstable_now();
            advanceTimers(currentTime);
            var firstTask = peek(taskQueue);
            return firstTask !== currentTask && currentTask !== null && firstTask !== null && firstTask.callback !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = {
            startLoggingProfilingEvents,
            stopLoggingProfilingEvents,
            sharedProfilingBuffer
          };
          exports.unstable_IdlePriority = IdlePriority;
          exports.unstable_ImmediatePriority = ImmediatePriority;
          exports.unstable_LowPriority = LowPriority;
          exports.unstable_NormalPriority = NormalPriority;
          exports.unstable_Profiling = unstable_Profiling;
          exports.unstable_UserBlockingPriority = UserBlockingPriority;
          exports.unstable_cancelCallback = unstable_cancelCallback;
          exports.unstable_continueExecution = unstable_continueExecution;
          exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports.unstable_next = unstable_next;
          exports.unstable_pauseExecution = unstable_pauseExecution;
          exports.unstable_requestPaint = unstable_requestPaint;
          exports.unstable_runWithPriority = unstable_runWithPriority;
          exports.unstable_scheduleCallback = unstable_scheduleCallback;
          exports.unstable_shouldYield = unstable_shouldYield;
          exports.unstable_wrapCallback = unstable_wrapCallback;
        })();
      }
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler-tracing.development.js
  var require_scheduler_tracing_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler-tracing.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var DEFAULT_THREAD_ID = 0;
          var interactionIDCounter = 0;
          var threadIDCounter = 0;
          exports.__interactionsRef = null;
          exports.__subscriberRef = null;
          {
            exports.__interactionsRef = {
              current: /* @__PURE__ */ new Set()
            };
            exports.__subscriberRef = {
              current: null
            };
          }
          function unstable_clear(callback) {
            var prevInteractions = exports.__interactionsRef.current;
            exports.__interactionsRef.current = /* @__PURE__ */ new Set();
            try {
              return callback();
            } finally {
              exports.__interactionsRef.current = prevInteractions;
            }
          }
          function unstable_getCurrent() {
            {
              return exports.__interactionsRef.current;
            }
          }
          function unstable_getThreadID() {
            return ++threadIDCounter;
          }
          function unstable_trace(name, timestamp, callback) {
            var threadID = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_THREAD_ID;
            var interaction = {
              __count: 1,
              id: interactionIDCounter++,
              name,
              timestamp
            };
            var prevInteractions = exports.__interactionsRef.current;
            var interactions = new Set(prevInteractions);
            interactions.add(interaction);
            exports.__interactionsRef.current = interactions;
            var subscriber = exports.__subscriberRef.current;
            var returnValue;
            try {
              if (subscriber !== null) {
                subscriber.onInteractionTraced(interaction);
              }
            } finally {
              try {
                if (subscriber !== null) {
                  subscriber.onWorkStarted(interactions, threadID);
                }
              } finally {
                try {
                  returnValue = callback();
                } finally {
                  exports.__interactionsRef.current = prevInteractions;
                  try {
                    if (subscriber !== null) {
                      subscriber.onWorkStopped(interactions, threadID);
                    }
                  } finally {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    }
                  }
                }
              }
            }
            return returnValue;
          }
          function unstable_wrap(callback) {
            var threadID = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_THREAD_ID;
            var wrappedInteractions = exports.__interactionsRef.current;
            var subscriber = exports.__subscriberRef.current;
            if (subscriber !== null) {
              subscriber.onWorkScheduled(wrappedInteractions, threadID);
            }
            wrappedInteractions.forEach(function(interaction) {
              interaction.__count++;
            });
            var hasRun = false;
            function wrapped() {
              var prevInteractions = exports.__interactionsRef.current;
              exports.__interactionsRef.current = wrappedInteractions;
              subscriber = exports.__subscriberRef.current;
              try {
                var returnValue;
                try {
                  if (subscriber !== null) {
                    subscriber.onWorkStarted(wrappedInteractions, threadID);
                  }
                } finally {
                  try {
                    returnValue = callback.apply(void 0, arguments);
                  } finally {
                    exports.__interactionsRef.current = prevInteractions;
                    if (subscriber !== null) {
                      subscriber.onWorkStopped(wrappedInteractions, threadID);
                    }
                  }
                }
                return returnValue;
              } finally {
                if (!hasRun) {
                  hasRun = true;
                  wrappedInteractions.forEach(function(interaction) {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    }
                  });
                }
              }
            }
            wrapped.cancel = function cancel2() {
              subscriber = exports.__subscriberRef.current;
              try {
                if (subscriber !== null) {
                  subscriber.onWorkCanceled(wrappedInteractions, threadID);
                }
              } finally {
                wrappedInteractions.forEach(function(interaction) {
                  interaction.__count--;
                  if (subscriber && interaction.__count === 0) {
                    subscriber.onInteractionScheduledWorkCompleted(interaction);
                  }
                });
              }
            };
            return wrapped;
          }
          var subscribers = null;
          {
            subscribers = /* @__PURE__ */ new Set();
          }
          function unstable_subscribe(subscriber) {
            {
              subscribers.add(subscriber);
              if (subscribers.size === 1) {
                exports.__subscriberRef.current = {
                  onInteractionScheduledWorkCompleted,
                  onInteractionTraced,
                  onWorkCanceled,
                  onWorkScheduled,
                  onWorkStarted,
                  onWorkStopped
                };
              }
            }
          }
          function unstable_unsubscribe(subscriber) {
            {
              subscribers.delete(subscriber);
              if (subscribers.size === 0) {
                exports.__subscriberRef.current = null;
              }
            }
          }
          function onInteractionTraced(interaction) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onInteractionTraced(interaction);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onInteractionScheduledWorkCompleted(interaction) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkScheduled(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkScheduled(interactions, threadID);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkStarted(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkStarted(interactions, threadID);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkStopped(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkStopped(interactions, threadID);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkCanceled(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkCanceled(interactions, threadID);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          exports.unstable_clear = unstable_clear;
          exports.unstable_getCurrent = unstable_getCurrent;
          exports.unstable_getThreadID = unstable_getThreadID;
          exports.unstable_subscribe = unstable_subscribe;
          exports.unstable_trace = unstable_trace;
          exports.unstable_unsubscribe = unstable_unsubscribe;
          exports.unstable_wrap = unstable_wrap;
        })();
      }
    }
  });

  // node_modules/scheduler/tracing.js
  var require_tracing = __commonJS({
    "node_modules/scheduler/tracing.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_scheduler_tracing_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React109 = require_react();
          var _assign = require_object_assign();
          var Scheduler = require_scheduler();
          var checkPropTypes = require_checkPropTypes();
          var tracing = require_tracing();
          var ReactSharedInternals = React109.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          if (!ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher")) {
            ReactSharedInternals.ReactCurrentDispatcher = {
              current: null
            };
          }
          if (!ReactSharedInternals.hasOwnProperty("ReactCurrentBatchConfig")) {
            ReactSharedInternals.ReactCurrentBatchConfig = {
              suspense: null
            };
          }
          function warn(format) {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
          function error(format) {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
          function printWarning(level, format, args) {
            {
              var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === "string" && args[args.length - 1].indexOf("\n    in") === 0;
              if (!hasExistingStack) {
                var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
                var stack = ReactDebugCurrentFrame2.getStackAddendum();
                if (stack !== "") {
                  format += "%s";
                  args = args.concat([stack]);
                }
              }
              var argsWithFormat = args.map(function(item) {
                return "" + item;
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
              try {
                var argIndex = 0;
                var message = "Warning: " + format.replace(/%s/g, function() {
                  return args[argIndex++];
                });
                throw new Error(message);
              } catch (x) {
              }
            }
          }
          if (!React109) {
            {
              throw Error("ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.");
            }
          }
          var invokeGuardedCallbackImpl = function(name, func, context2, a, b, c, d, e, f) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context2, funcArgs);
            } catch (error2) {
              this.onError(error2);
            }
          };
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              var invokeGuardedCallbackDev = function(name, func, context2, a, b, c, d, e, f) {
                if (!(typeof document !== "undefined")) {
                  {
                    throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                  }
                }
                var evt = document.createEvent("Event");
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                  func.apply(context2, funcArgs);
                  didError = false;
                }
                var error2;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error2 = event.error;
                  didSetError = true;
                  if (error2 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error2 != null && typeof error2 === "object") {
                      try {
                        error2._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name ? name : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didError) {
                  if (!didSetError) {
                    error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://fb.me/react-crossorigin-error for more information.");
                  }
                  this.onError(error2);
                }
                window.removeEventListener("error", handleWindowError);
              };
              invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error2) {
              hasError = true;
              caughtError = error2;
            }
          };
          function invokeGuardedCallback(name, func, context2, a, b, c, d, e, f) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name, func, context2, a, b, c, d, e, f) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error2 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error2;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error2 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error2;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error2 = caughtError;
              hasError = false;
              caughtError = null;
              return error2;
            } else {
              {
                {
                  throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
          }
          var getFiberCurrentPropsFromNode = null;
          var getInstanceFromNode = null;
          var getNodeFromInstance = null;
          function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {
            getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
            getInstanceFromNode = getInstanceFromNodeImpl;
            getNodeFromInstance = getNodeFromInstanceImpl;
            {
              if (!getNodeFromInstance || !getInstanceFromNode) {
                error("EventPluginUtils.setComponentTree(...): Injected module is missing getNodeFromInstance or getInstanceFromNode.");
              }
            }
          }
          var validateEventDispatches;
          {
            validateEventDispatches = function(event) {
              var dispatchListeners = event._dispatchListeners;
              var dispatchInstances = event._dispatchInstances;
              var listenersIsArr = Array.isArray(dispatchListeners);
              var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
              var instancesIsArr = Array.isArray(dispatchInstances);
              var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
              if (instancesIsArr !== listenersIsArr || instancesLen !== listenersLen) {
                error("EventPluginUtils: Invalid `event`.");
              }
            };
          }
          function executeDispatch(event, listener, inst) {
            var type = event.type || "unknown-event";
            event.currentTarget = getNodeFromInstance(inst);
            invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
            event.currentTarget = null;
          }
          function executeDispatchesInOrder(event) {
            var dispatchListeners = event._dispatchListeners;
            var dispatchInstances = event._dispatchInstances;
            {
              validateEventDispatches(event);
            }
            if (Array.isArray(dispatchListeners)) {
              for (var i = 0; i < dispatchListeners.length; i++) {
                if (event.isPropagationStopped()) {
                  break;
                }
                executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
              }
            } else if (dispatchListeners) {
              executeDispatch(event, dispatchListeners, dispatchInstances);
            }
            event._dispatchListeners = null;
            event._dispatchInstances = null;
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var FundamentalComponent = 20;
          var ScopeComponent = 21;
          var Block = 22;
          var eventPluginOrder = null;
          var namesToPlugins = {};
          function recomputePluginOrdering() {
            if (!eventPluginOrder) {
              return;
            }
            for (var pluginName in namesToPlugins) {
              var pluginModule = namesToPlugins[pluginName];
              var pluginIndex = eventPluginOrder.indexOf(pluginName);
              if (!(pluginIndex > -1)) {
                {
                  throw Error("EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `" + pluginName + "`.");
                }
              }
              if (plugins[pluginIndex]) {
                continue;
              }
              if (!pluginModule.extractEvents) {
                {
                  throw Error("EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `" + pluginName + "` does not.");
                }
              }
              plugins[pluginIndex] = pluginModule;
              var publishedEvents = pluginModule.eventTypes;
              for (var eventName in publishedEvents) {
                if (!publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName)) {
                  {
                    throw Error("EventPluginRegistry: Failed to publish event `" + eventName + "` for plugin `" + pluginName + "`.");
                  }
                }
              }
            }
          }
          function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
            if (!!eventNameDispatchConfigs.hasOwnProperty(eventName)) {
              {
                throw Error("EventPluginRegistry: More than one plugin attempted to publish the same event name, `" + eventName + "`.");
              }
            }
            eventNameDispatchConfigs[eventName] = dispatchConfig;
            var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
            if (phasedRegistrationNames) {
              for (var phaseName in phasedRegistrationNames) {
                if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
                  var phasedRegistrationName = phasedRegistrationNames[phaseName];
                  publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
                }
              }
              return true;
            } else if (dispatchConfig.registrationName) {
              publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
              return true;
            }
            return false;
          }
          function publishRegistrationName(registrationName, pluginModule, eventName) {
            if (!!registrationNameModules[registrationName]) {
              {
                throw Error("EventPluginRegistry: More than one plugin attempted to publish the same registration name, `" + registrationName + "`.");
              }
            }
            registrationNameModules[registrationName] = pluginModule;
            registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
          }
          var plugins = [];
          var eventNameDispatchConfigs = {};
          var registrationNameModules = {};
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function injectEventPluginOrder(injectedEventPluginOrder) {
            if (!!eventPluginOrder) {
              {
                throw Error("EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.");
              }
            }
            eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
            recomputePluginOrdering();
          }
          function injectEventPluginsByName(injectedNamesToPlugins) {
            var isOrderingDirty = false;
            for (var pluginName in injectedNamesToPlugins) {
              if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
                continue;
              }
              var pluginModule = injectedNamesToPlugins[pluginName];
              if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
                if (!!namesToPlugins[pluginName]) {
                  {
                    throw Error("EventPluginRegistry: Cannot inject two different event plugins using the same name, `" + pluginName + "`.");
                  }
                }
                namesToPlugins[pluginName] = pluginModule;
                isOrderingDirty = true;
              }
            }
            if (isOrderingDirty) {
              recomputePluginOrdering();
            }
          }
          var canUseDOM3 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var PLUGIN_EVENT_SYSTEM = 1;
          var IS_REPLAYED = 1 << 5;
          var IS_FIRST_ANCESTOR = 1 << 6;
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
              return;
            }
            if (!(typeof restoreImpl === "function")) {
              {
                throw Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target);
              } else {
                restoreQueue = [target];
              }
            } else {
              restoreTarget = target;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
              for (var i = 0; i < queuedTargets.length; i++) {
                restoreStateOfTarget(queuedTargets[i]);
              }
            }
          }
          var enableProfilerTimer = true;
          var enableDeprecatedFlareAPI = false;
          var enableFundamentalAPI = false;
          var warnAboutStringRefs = false;
          var batchedUpdatesImpl = function(fn, bookkeeping) {
            return fn(bookkeeping);
          };
          var discreteUpdatesImpl = function(fn, a, b, c, d) {
            return fn(a, b, c, d);
          };
          var flushDiscreteUpdatesImpl = function() {
          };
          var batchedEventUpdatesImpl = batchedUpdatesImpl;
          var isInsideEventHandler = false;
          var isBatchingEventUpdates = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushDiscreteUpdatesImpl();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn, bookkeeping) {
            if (isInsideEventHandler) {
              return fn(bookkeeping);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn, bookkeeping);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function batchedEventUpdates(fn, a, b) {
            if (isBatchingEventUpdates) {
              return fn(a, b);
            }
            isBatchingEventUpdates = true;
            try {
              return batchedEventUpdatesImpl(fn, a, b);
            } finally {
              isBatchingEventUpdates = false;
              finishEventHandler();
            }
          }
          function discreteUpdates(fn, a, b, c, d) {
            var prevIsInsideEventHandler = isInsideEventHandler;
            isInsideEventHandler = true;
            try {
              return discreteUpdatesImpl(fn, a, b, c, d);
            } finally {
              isInsideEventHandler = prevIsInsideEventHandler;
              if (!isInsideEventHandler) {
                finishEventHandler();
              }
            }
          }
          function flushDiscreteUpdatesIfNeeded(timeStamp) {
            if (!isInsideEventHandler && !enableDeprecatedFlareAPI) {
              flushDiscreteUpdatesImpl();
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            discreteUpdatesImpl = _discreteUpdatesImpl;
            flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
            batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
          }
          var DiscreteEvent = 0;
          var UserBlockingEvent = 1;
          var ContinuousEvent = 2;
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var ROOT_ATTRIBUTE_NAME = "data-reactroot";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var hasOwnProperty7 = Object.prototype.hasOwnProperty;
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty7.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty7.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN:
                  return !value;
                case OVERLOADED_BOOLEAN:
                  return value === false;
                case NUMERIC:
                  return isNaN(value);
                case POSITIVE_NUMERIC:
                  return isNaN(value) || value < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name) {
            return properties.hasOwnProperty(name) ? properties[name] : null;
          }
          function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false);
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name = _ref[0], attributeName = _ref[1];
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false);
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false);
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false);
          });
          [
            "allowFullScreen",
            "async",
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            "itemScope"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false);
          });
          [
            "checked",
            "multiple",
            "muted",
            "selected"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false);
          });
          [
            "capture",
            "download"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false);
          });
          [
            "cols",
            "rows",
            "size",
            "span"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false);
          });
          ["rowSpan", "start"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false);
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false);
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false);
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false);
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false);
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true);
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true);
          });
          var ReactDebugCurrentFrame = null;
          {
            ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          }
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node, name, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                return node[propertyName];
              } else {
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                      return value;
                    }
                    if (value === "" + expected) {
                      return expected;
                    }
                    return value;
                  }
                } else if (node.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return node.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN) {
                    return expected;
                  }
                  stringValue = node.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node, name, expected) {
            {
              if (!isAttributeNameSafe(name)) {
                return;
              }
              if (!node.hasAttribute(name)) {
                return expected === void 0 ? void 0 : null;
              }
              var value = node.getAttribute(name);
              if (value === "" + expected) {
                return expected;
              }
              return value;
            }
          }
          function setValueForProperty(node, name, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name);
            if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
              value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name)) {
                var _attributeName = name;
                if (value === null) {
                  node.removeAttribute(_attributeName);
                } else {
                  node.setAttribute(_attributeName, "" + value);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (value === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN ? false : "";
              } else {
                node[propertyName] = value;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
              node.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
                attributeValue = "";
              } else {
                {
                  attributeValue = "" + value;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
          function describeComponentFrame(name, source, ownerName) {
            var sourceInfo = "";
            if (source) {
              var path = source.fileName;
              var fileName = path.replace(BEFORE_SLASH_RE, "");
              {
                if (/^index\./.test(fileName)) {
                  var match = path.match(BEFORE_SLASH_RE);
                  if (match) {
                    var pathBeforeSlash = match[1];
                    if (pathBeforeSlash) {
                      var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                      fileName = folderName + "/" + fileName;
                    }
                  }
                }
              }
              sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
            } else if (ownerName) {
              sourceInfo = " (created by " + ownerName + ")";
            }
            return "\n    in " + (name || "Unknown") + sourceInfo;
          }
          var hasSymbol2 = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol2 ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol2 ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol2 ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol2 ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol2 ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol2 ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol2 ? Symbol.for("react.context") : 60110;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol2 ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol2 ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol2 ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol2 ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol2 ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol2 ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol2 ? Symbol.for("react.block") : 60121;
          var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function refineResolvedLazyComponent(lazyComponent) {
            return lazyComponent._status === Resolved ? lazyComponent._result : null;
          }
          function initializeLazyComponentType(lazyComponent) {
            if (lazyComponent._status === Uninitialized) {
              lazyComponent._status = Pending;
              var ctor = lazyComponent._ctor;
              var thenable = ctor();
              lazyComponent._result = thenable;
              thenable.then(function(moduleObject) {
                if (lazyComponent._status === Pending) {
                  var defaultExport = moduleObject.default;
                  {
                    if (defaultExport === void 0) {
                      error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                    }
                  }
                  lazyComponent._status = Resolved;
                  lazyComponent._result = defaultExport;
                }
              }, function(error2) {
                if (lazyComponent._status === Pending) {
                  lazyComponent._status = Rejected;
                  lazyComponent._result = error2;
                }
              });
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getComponentName(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  return "Context.Consumer";
                case REACT_PROVIDER_TYPE:
                  return "Context.Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  return getComponentName(type.type);
                case REACT_BLOCK_TYPE:
                  return getComponentName(type.render);
                case REACT_LAZY_TYPE: {
                  var thenable = type;
                  var resolvedThenable = refineResolvedLazyComponent(thenable);
                  if (resolvedThenable) {
                    return getComponentName(resolvedThenable);
                  }
                  break;
                }
              }
            }
            return null;
          }
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function describeFiber(fiber) {
            switch (fiber.tag) {
              case HostRoot:
              case HostPortal:
              case HostText:
              case Fragment:
              case ContextProvider:
              case ContextConsumer:
                return "";
              default:
                var owner = fiber._debugOwner;
                var source = fiber._debugSource;
                var name = getComponentName(fiber.type);
                var ownerName = null;
                if (owner) {
                  ownerName = getComponentName(owner.type);
                }
                return describeComponentFrame(name, source, ownerName);
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            var info = "";
            var node = workInProgress2;
            do {
              info += describeFiber(node);
              node = node.return;
            } while (node);
            return info;
          }
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentName(owner.type);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame$1.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function toString3(value) {
            return "" + value;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
              case "object":
              case "string":
              case "undefined":
                return value;
              default:
                return "";
            }
          }
          var ReactDebugCurrentFrame$2 = null;
          var ReactControlledValuePropTypes = {
            checkPropTypes: null
          };
          {
            ReactDebugCurrentFrame$2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var hasReadOnlyValue = {
              button: true,
              checkbox: true,
              image: true,
              hidden: true,
              radio: true,
              reset: true,
              submit: true
            };
            var propTypes = {
              value: function(props, propName, componentName) {
                if (hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == null || enableDeprecatedFlareAPI) {
                  return null;
                }
                return new Error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              },
              checked: function(props, propName, componentName) {
                if (props.onChange || props.readOnly || props.disabled || props[propName] == null || enableDeprecatedFlareAPI) {
                  return null;
                }
                return new Error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            };
            ReactControlledValuePropTypes.checkPropTypes = function(tagName, props) {
              checkPropTypes(propTypes, props, "prop", tagName, ReactDebugCurrentFrame$2.getStackAddendum);
            };
          }
          function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node) {
            return node._valueTracker;
          }
          function detachTracker(node) {
            node._valueTracker = null;
          }
          function getValueFromNode(node) {
            var value = "";
            if (!node) {
              return value;
            }
            if (isCheckable(node)) {
              value = node.checked ? "true" : "false";
            } else {
              value = node.value;
            }
            return value;
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            var currentValue = "" + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get5 = descriptor.get, set2 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get5.call(this);
              },
              set: function(value) {
                currentValue = "" + value;
                set2.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                currentValue = "" + value;
              },
              stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
              }
            };
            return tracker;
          }
          function track(node) {
            if (getTracker(node)) {
              return;
            }
            node._valueTracker = trackValueOnNode(node);
          }
          function updateValueIfChanged(node) {
            if (!node) {
              return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node = element;
            var checked = props.checked;
            var hostProps = _assign({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked != null ? checked : node._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              ReactControlledValuePropTypes.checkPropTypes("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://fb.me/react-controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://fb.me/react-controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node = element;
            var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
            node._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node = element;
            var checked = props.checked;
            if (checked != null) {
              setValueForProperty(node, "checked", checked, false);
            }
          }
          function updateWrapper(element, props) {
            var node = element;
            {
              var controlled = isControlled(props);
              if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error("A component is changing an uncontrolled input of type %s to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://fb.me/react-controlled-components", props.type);
                didWarnUncontrolledToControlled = true;
              }
              if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error("A component is changing a controlled input of type %s to be uncontrolled. Input elements should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://fb.me/react-controlled-components", props.type);
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
              if (type === "number") {
                if (value === 0 && node.value === "" || node.value != value) {
                  node.value = toString3(value);
                }
              } else if (node.value !== toString3(value)) {
                node.value = toString3(value);
              }
            } else if (type === "submit" || type === "reset") {
              node.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue(node, props.type, value);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton = type === "submit" || type === "reset";
              if (isButton && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString3(node._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node.value) {
                    node.value = initialValue;
                  }
                }
              }
              {
                node.defaultValue = initialValue;
              }
            }
            var name = node.name;
            if (name !== "") {
              node.name = "";
            }
            {
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name !== "") {
              node.name = name;
            }
          }
          function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name = props.name;
            if (props.type === "radio" && name != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
              for (var i = 0; i < group.length; i++) {
                var otherNode = group[i];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
                if (!otherProps) {
                  {
                    throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                  }
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue(node, type, value) {
            if (type !== "number" || node.ownerDocument.activeElement !== node) {
              if (value == null) {
                node.defaultValue = toString3(node._wrapperState.initialValue);
              } else if (node.defaultValue !== toString3(value)) {
                node.defaultValue = toString3(value);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          function flattenChildren(children2) {
            var content = "";
            React109.Children.forEach(children2, function(child) {
              if (child == null) {
                return;
              }
              content += child;
            });
            return content;
          }
          function validateProps(element, props) {
            {
              if (typeof props.children === "object" && props.children !== null) {
                React109.Children.forEach(props.children, function(child) {
                  if (child == null) {
                    return;
                  }
                  if (typeof child === "string" || typeof child === "number") {
                    return;
                  }
                  if (typeof child.type !== "string") {
                    return;
                  }
                  if (!didWarnInvalidChild) {
                    didWarnInvalidChild = true;
                    error("Only strings and numbers are supported as <option> children.");
                  }
                });
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString3(getToStringValue(props.value)));
            }
          }
          function getHostProps$1(element, props) {
            var hostProps = _assign({
              children: void 0
            }, props);
            var content = flattenChildren(props.children);
            if (content) {
              hostProps.children = content;
            }
            return hostProps;
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              ReactControlledValuePropTypes.checkPropTypes("select", props);
              for (var i = 0; i < valuePropNames.length; i++) {
                var propName = valuePropNames[i];
                if (props[propName] == null) {
                  continue;
                }
                var isArray3 = Array.isArray(props[propName]);
                if (props.multiple && !isArray3) {
                  error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && isArray3) {
                  error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options = node.options;
            if (multiple) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i = 0; i < selectedValues.length; i++) {
                selectedValue["$" + selectedValues[i]] = true;
              }
              for (var _i = 0; _i < options.length; _i++) {
                var selected = selectedValue.hasOwnProperty("$" + options[_i].value);
                if (options[_i].selected !== selected) {
                  options[_i].selected = selected;
                }
                if (selected && setDefaultSelected) {
                  options[_i].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString3(getToStringValue(propValue));
              var defaultSelected = null;
              for (var _i2 = 0; _i2 < options.length; _i2++) {
                if (options[_i2].value === _selectedValue) {
                  options[_i2].selected = true;
                  if (setDefaultSelected) {
                    options[_i2].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected === null && !options[_i2].disabled) {
                  defaultSelected = options[_i2];
                }
              }
              if (defaultSelected !== null) {
                defaultSelected.selected = true;
              }
            }
          }
          function getHostProps$2(element, props) {
            return _assign({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node = element;
            {
              checkSelectPropTypes(props);
            }
            node._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://fb.me/react-controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$3(element, props) {
            var node = element;
            if (!(props.dangerouslySetInnerHTML == null)) {
              {
                throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              }
            }
            var hostProps = _assign({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString3(node._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node = element;
            {
              ReactControlledValuePropTypes.checkPropTypes("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://fb.me/react-controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children2 = props.children, defaultValue = props.defaultValue;
              if (children2 != null) {
                {
                  error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (!(defaultValue == null)) {
                    {
                      throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                    }
                  }
                  if (Array.isArray(children2)) {
                    if (!(children2.length <= 1)) {
                      {
                        throw Error("<textarea> can only have at most one child.");
                      }
                    }
                    children2 = children2[0];
                  }
                  defaultValue = children2;
                }
              }
              if (defaultValue == null) {
                defaultValue = "";
              }
              initialValue = defaultValue;
            }
            node._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node = element;
            var value = getToStringValue(props.value);
            var defaultValue = getToStringValue(props.defaultValue);
            if (value != null) {
              var newValue = toString3(value);
              if (newValue !== node.value) {
                node.value = newValue;
              }
              if (props.defaultValue == null && node.defaultValue !== newValue) {
                node.defaultValue = newValue;
              }
            }
            if (defaultValue != null) {
              node.defaultValue = toString3(defaultValue);
            }
          }
          function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          var Namespaces = {
            html: HTML_NAMESPACE,
            mathml: MATH_NAMESPACE,
            svg: SVG_NAMESPACE
          };
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
            if (node.namespaceURI === Namespaces.svg) {
              if (!("innerHTML" in node)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node.innerHTML = html;
          });
          var ELEMENT_NODE = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node, text) {
            if (text) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
              }
            }
            node.textContent = text;
          };
          function unsafeCastStringToDOMTopLevelType(topLevelType) {
            return topLevelType;
          }
          function unsafeCastDOMTopLevelTypeToString(topLevelType) {
            return topLevelType;
          }
          function makePrefixMap(styleProp, eventName) {
            var prefixes2 = {};
            prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes2["Webkit" + styleProp] = "webkit" + eventName;
            prefixes2["Moz" + styleProp] = "moz" + eventName;
            return prefixes2;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style4 = {};
          if (canUseDOM3) {
            style4 = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style4) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var TOP_ABORT = unsafeCastStringToDOMTopLevelType("abort");
          var TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName("animationend"));
          var TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName("animationiteration"));
          var TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName("animationstart"));
          var TOP_BLUR = unsafeCastStringToDOMTopLevelType("blur");
          var TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType("canplay");
          var TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType("canplaythrough");
          var TOP_CANCEL = unsafeCastStringToDOMTopLevelType("cancel");
          var TOP_CHANGE = unsafeCastStringToDOMTopLevelType("change");
          var TOP_CLICK = unsafeCastStringToDOMTopLevelType("click");
          var TOP_CLOSE = unsafeCastStringToDOMTopLevelType("close");
          var TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType("compositionend");
          var TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType("compositionstart");
          var TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType("compositionupdate");
          var TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType("contextmenu");
          var TOP_COPY = unsafeCastStringToDOMTopLevelType("copy");
          var TOP_CUT = unsafeCastStringToDOMTopLevelType("cut");
          var TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType("dblclick");
          var TOP_AUX_CLICK = unsafeCastStringToDOMTopLevelType("auxclick");
          var TOP_DRAG = unsafeCastStringToDOMTopLevelType("drag");
          var TOP_DRAG_END = unsafeCastStringToDOMTopLevelType("dragend");
          var TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType("dragenter");
          var TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType("dragexit");
          var TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType("dragleave");
          var TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType("dragover");
          var TOP_DRAG_START = unsafeCastStringToDOMTopLevelType("dragstart");
          var TOP_DROP = unsafeCastStringToDOMTopLevelType("drop");
          var TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType("durationchange");
          var TOP_EMPTIED = unsafeCastStringToDOMTopLevelType("emptied");
          var TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType("encrypted");
          var TOP_ENDED = unsafeCastStringToDOMTopLevelType("ended");
          var TOP_ERROR = unsafeCastStringToDOMTopLevelType("error");
          var TOP_FOCUS = unsafeCastStringToDOMTopLevelType("focus");
          var TOP_GOT_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType("gotpointercapture");
          var TOP_INPUT = unsafeCastStringToDOMTopLevelType("input");
          var TOP_INVALID = unsafeCastStringToDOMTopLevelType("invalid");
          var TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType("keydown");
          var TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType("keypress");
          var TOP_KEY_UP = unsafeCastStringToDOMTopLevelType("keyup");
          var TOP_LOAD = unsafeCastStringToDOMTopLevelType("load");
          var TOP_LOAD_START = unsafeCastStringToDOMTopLevelType("loadstart");
          var TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType("loadeddata");
          var TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType("loadedmetadata");
          var TOP_LOST_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType("lostpointercapture");
          var TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType("mousedown");
          var TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType("mousemove");
          var TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType("mouseout");
          var TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType("mouseover");
          var TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType("mouseup");
          var TOP_PASTE = unsafeCastStringToDOMTopLevelType("paste");
          var TOP_PAUSE = unsafeCastStringToDOMTopLevelType("pause");
          var TOP_PLAY = unsafeCastStringToDOMTopLevelType("play");
          var TOP_PLAYING = unsafeCastStringToDOMTopLevelType("playing");
          var TOP_POINTER_CANCEL = unsafeCastStringToDOMTopLevelType("pointercancel");
          var TOP_POINTER_DOWN = unsafeCastStringToDOMTopLevelType("pointerdown");
          var TOP_POINTER_MOVE = unsafeCastStringToDOMTopLevelType("pointermove");
          var TOP_POINTER_OUT = unsafeCastStringToDOMTopLevelType("pointerout");
          var TOP_POINTER_OVER = unsafeCastStringToDOMTopLevelType("pointerover");
          var TOP_POINTER_UP = unsafeCastStringToDOMTopLevelType("pointerup");
          var TOP_PROGRESS = unsafeCastStringToDOMTopLevelType("progress");
          var TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType("ratechange");
          var TOP_RESET = unsafeCastStringToDOMTopLevelType("reset");
          var TOP_SCROLL = unsafeCastStringToDOMTopLevelType("scroll");
          var TOP_SEEKED = unsafeCastStringToDOMTopLevelType("seeked");
          var TOP_SEEKING = unsafeCastStringToDOMTopLevelType("seeking");
          var TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType("selectionchange");
          var TOP_STALLED = unsafeCastStringToDOMTopLevelType("stalled");
          var TOP_SUBMIT = unsafeCastStringToDOMTopLevelType("submit");
          var TOP_SUSPEND = unsafeCastStringToDOMTopLevelType("suspend");
          var TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType("textInput");
          var TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType("timeupdate");
          var TOP_TOGGLE = unsafeCastStringToDOMTopLevelType("toggle");
          var TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType("touchcancel");
          var TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType("touchend");
          var TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType("touchmove");
          var TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType("touchstart");
          var TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName("transitionend"));
          var TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType("volumechange");
          var TOP_WAITING = unsafeCastStringToDOMTopLevelType("waiting");
          var TOP_WHEEL = unsafeCastStringToDOMTopLevelType("wheel");
          var mediaEventTypes = [TOP_ABORT, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_VOLUME_CHANGE, TOP_WAITING];
          function getRawEventName(topLevelType) {
            return unsafeCastDOMTopLevelTypeToString(topLevelType);
          }
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          var elementListenerMap = new PossiblyWeakMap();
          function getListenerMapForElement(element) {
            var listenerMap = elementListenerMap.get(element);
            if (listenerMap === void 0) {
              listenerMap = /* @__PURE__ */ new Map();
              elementListenerMap.set(element, listenerMap);
            }
            return listenerMap;
          }
          function get4(key) {
            return key._reactInternalFiber;
          }
          function has(key) {
            return key._reactInternalFiber !== void 0;
          }
          function set(key, value) {
            key._reactInternalFiber = value;
          }
          var NoEffect = 0;
          var PerformedWork = 1;
          var Placement = 2;
          var Update = 4;
          var PlacementAndUpdate = 6;
          var Deletion = 8;
          var ContentReset = 16;
          var Callback = 32;
          var DidCapture = 64;
          var Ref = 128;
          var Snapshot = 256;
          var Passive = 512;
          var Hydrating = 1024;
          var HydratingAndUpdate = 1028;
          var LifecycleEffectMask = 932;
          var HostEffectMask = 2047;
          var Incomplete = 2048;
          var ShouldCapture = 4096;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.effectTag & (Placement | Hydrating)) !== NoEffect) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get4(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (!(getNearestMountedFiber(fiber) === fiber)) {
              {
                throw Error("Unable to find node on an unmounted component.");
              }
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (!(nearestMounted !== null)) {
                {
                  throw Error("Unable to find node on an unmounted component.");
                }
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a = fiber;
            var b = alternate;
            while (true) {
              var parentA = a.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a = b = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                {
                  {
                    throw Error("Unable to find node on an unmounted component.");
                  }
                }
              }
              if (a.return !== b.return) {
                a = parentA;
                b = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentA;
                    b = parentB;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentA;
                    a = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentB;
                      b = parentA;
                      break;
                    }
                    if (_child === b) {
                      didFindChild = true;
                      b = parentB;
                      a = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    {
                      throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                    }
                  }
                }
              }
              if (!(a.alternate === b)) {
                {
                  throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            if (!(a.tag === HostRoot)) {
              {
                throw Error("Unable to find node on an unmounted component.");
              }
            }
            if (a.stateNode.current === a) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            if (!currentParent) {
              return null;
            }
            var node = currentParent;
            while (true) {
              if (node.tag === HostComponent || node.tag === HostText) {
                return node;
              } else if (node.child) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === currentParent) {
                return null;
              }
              while (!node.sibling) {
                if (!node.return || node.return === currentParent) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            if (!currentParent) {
              return null;
            }
            var node = currentParent;
            while (true) {
              if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI) {
                return node;
              } else if (node.child && node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === currentParent) {
                return null;
              }
              while (!node.sibling) {
                if (!node.return || node.return === currentParent) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          function accumulateInto(current2, next) {
            if (!(next != null)) {
              {
                throw Error("accumulateInto(...): Accumulated items must not be null or undefined.");
              }
            }
            if (current2 == null) {
              return next;
            }
            if (Array.isArray(current2)) {
              if (Array.isArray(next)) {
                current2.push.apply(current2, next);
                return current2;
              }
              current2.push(next);
              return current2;
            }
            if (Array.isArray(next)) {
              return [current2].concat(next);
            }
            return [current2, next];
          }
          function forEachAccumulated(arr, cb, scope) {
            if (Array.isArray(arr)) {
              arr.forEach(cb, scope);
            } else if (arr) {
              cb.call(scope, arr);
            }
          }
          var eventQueue = null;
          var executeDispatchesAndRelease = function(event) {
            if (event) {
              executeDispatchesInOrder(event);
              if (!event.isPersistent()) {
                event.constructor.release(event);
              }
            }
          };
          var executeDispatchesAndReleaseTopLevel = function(e) {
            return executeDispatchesAndRelease(e);
          };
          function runEventsInBatch(events) {
            if (events !== null) {
              eventQueue = accumulateInto(eventQueue, events);
            }
            var processingEventQueue = eventQueue;
            eventQueue = null;
            if (!processingEventQueue) {
              return;
            }
            forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
            if (!!eventQueue) {
              {
                throw Error("processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.");
              }
            }
            rethrowCaughtError();
          }
          function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
              target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM3) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported = eventName in document;
            if (!isSupported) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported = typeof element[eventName] === "function";
            }
            return isSupported;
          }
          var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
          var callbackBookkeepingPool = [];
          function releaseTopLevelCallbackBookKeeping(instance) {
            instance.topLevelType = null;
            instance.nativeEvent = null;
            instance.targetInst = null;
            instance.ancestors.length = 0;
            if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
              callbackBookkeepingPool.push(instance);
            }
          }
          function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst, eventSystemFlags) {
            if (callbackBookkeepingPool.length) {
              var instance = callbackBookkeepingPool.pop();
              instance.topLevelType = topLevelType;
              instance.eventSystemFlags = eventSystemFlags;
              instance.nativeEvent = nativeEvent;
              instance.targetInst = targetInst;
              return instance;
            }
            return {
              topLevelType,
              eventSystemFlags,
              nativeEvent,
              targetInst,
              ancestors: []
            };
          }
          function findRootContainerNode(inst) {
            if (inst.tag === HostRoot) {
              return inst.stateNode.containerInfo;
            }
            while (inst.return) {
              inst = inst.return;
            }
            if (inst.tag !== HostRoot) {
              return null;
            }
            return inst.stateNode.containerInfo;
          }
          function extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
            var events = null;
            for (var i = 0; i < plugins.length; i++) {
              var possiblePlugin = plugins[i];
              if (possiblePlugin) {
                var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
                if (extractedEvents) {
                  events = accumulateInto(events, extractedEvents);
                }
              }
            }
            return events;
          }
          function runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
            var events = extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            runEventsInBatch(events);
          }
          function handleTopLevel(bookKeeping) {
            var targetInst = bookKeeping.targetInst;
            var ancestor = targetInst;
            do {
              if (!ancestor) {
                var ancestors = bookKeeping.ancestors;
                ancestors.push(ancestor);
                break;
              }
              var root3 = findRootContainerNode(ancestor);
              if (!root3) {
                break;
              }
              var tag = ancestor.tag;
              if (tag === HostComponent || tag === HostText) {
                bookKeeping.ancestors.push(ancestor);
              }
              ancestor = getClosestInstanceFromNode(root3);
            } while (ancestor);
            for (var i = 0; i < bookKeeping.ancestors.length; i++) {
              targetInst = bookKeeping.ancestors[i];
              var eventTarget = getEventTarget(bookKeeping.nativeEvent);
              var topLevelType = bookKeeping.topLevelType;
              var nativeEvent = bookKeeping.nativeEvent;
              var eventSystemFlags = bookKeeping.eventSystemFlags;
              if (i === 0) {
                eventSystemFlags |= IS_FIRST_ANCESTOR;
              }
              runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, eventTarget, eventSystemFlags);
            }
          }
          function dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst) {
            var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst, eventSystemFlags);
            try {
              batchedEventUpdates(handleTopLevel, bookKeeping);
            } finally {
              releaseTopLevelCallbackBookKeeping(bookKeeping);
            }
          }
          function legacyListenToEvent(registrationName, mountAt) {
            var listenerMap = getListenerMapForElement(mountAt);
            var dependencies = registrationNameDependencies[registrationName];
            for (var i = 0; i < dependencies.length; i++) {
              var dependency = dependencies[i];
              legacyListenToTopLevelEvent(dependency, mountAt, listenerMap);
            }
          }
          function legacyListenToTopLevelEvent(topLevelType, mountAt, listenerMap) {
            if (!listenerMap.has(topLevelType)) {
              switch (topLevelType) {
                case TOP_SCROLL:
                  trapCapturedEvent(TOP_SCROLL, mountAt);
                  break;
                case TOP_FOCUS:
                case TOP_BLUR:
                  trapCapturedEvent(TOP_FOCUS, mountAt);
                  trapCapturedEvent(TOP_BLUR, mountAt);
                  listenerMap.set(TOP_BLUR, null);
                  listenerMap.set(TOP_FOCUS, null);
                  break;
                case TOP_CANCEL:
                case TOP_CLOSE:
                  if (isEventSupported(getRawEventName(topLevelType))) {
                    trapCapturedEvent(topLevelType, mountAt);
                  }
                  break;
                case TOP_INVALID:
                case TOP_SUBMIT:
                case TOP_RESET:
                  break;
                default:
                  var isMediaEvent = mediaEventTypes.indexOf(topLevelType) !== -1;
                  if (!isMediaEvent) {
                    trapBubbledEvent(topLevelType, mountAt);
                  }
                  break;
              }
              listenerMap.set(topLevelType, null);
            }
          }
          function isListeningToAllDependencies(registrationName, mountAt) {
            var listenerMap = getListenerMapForElement(mountAt);
            var dependencies = registrationNameDependencies[registrationName];
            for (var i = 0; i < dependencies.length; i++) {
              var dependency = dependencies[i];
              if (!listenerMap.has(dependency)) {
                return false;
              }
            }
            return true;
          }
          var attemptUserBlockingHydration;
          function setAttemptUserBlockingHydration(fn) {
            attemptUserBlockingHydration = fn;
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn) {
            attemptContinuousHydration = fn;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn) {
            attemptHydrationAtCurrentPriority = fn;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = /* @__PURE__ */ new Map();
          var queuedPointerCaptures = /* @__PURE__ */ new Map();
          var queuedExplicitHydrationTargets = [];
          function hasQueuedDiscreteEvents() {
            return queuedDiscreteEvents.length > 0;
          }
          var discreteReplayableEvents = [TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_TOUCH_START, TOP_AUX_CLICK, TOP_DOUBLE_CLICK, TOP_POINTER_CANCEL, TOP_POINTER_DOWN, TOP_POINTER_UP, TOP_DRAG_END, TOP_DRAG_START, TOP_DROP, TOP_COMPOSITION_END, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_INPUT, TOP_TEXT_INPUT, TOP_CLOSE, TOP_CANCEL, TOP_COPY, TOP_CUT, TOP_PASTE, TOP_CLICK, TOP_CHANGE, TOP_CONTEXT_MENU, TOP_RESET, TOP_SUBMIT];
          var continuousReplayableEvents = [TOP_FOCUS, TOP_BLUR, TOP_DRAG_ENTER, TOP_DRAG_LEAVE, TOP_MOUSE_OVER, TOP_MOUSE_OUT, TOP_POINTER_OVER, TOP_POINTER_OUT, TOP_GOT_POINTER_CAPTURE, TOP_LOST_POINTER_CAPTURE];
          function isReplayableDiscreteEvent(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function trapReplayableEventForDocument(topLevelType, document2, listenerMap) {
            legacyListenToTopLevelEvent(topLevelType, document2, listenerMap);
          }
          function eagerlyTrapReplayableEvents(container, document2) {
            var listenerMapForDoc = getListenerMapForElement(document2);
            discreteReplayableEvents.forEach(function(topLevelType) {
              trapReplayableEventForDocument(topLevelType, document2, listenerMapForDoc);
            });
            continuousReplayableEvents.forEach(function(topLevelType) {
              trapReplayableEventForDocument(topLevelType, document2, listenerMapForDoc);
            });
          }
          function createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {
            return {
              blockedOn,
              topLevelType,
              eventSystemFlags: eventSystemFlags | IS_REPLAYED,
              nativeEvent,
              container
            };
          }
          function queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);
            queuedDiscreteEvents.push(queuedEvent);
          }
          function clearIfContinuousEvent(topLevelType, nativeEvent) {
            switch (topLevelType) {
              case TOP_FOCUS:
              case TOP_BLUR:
                queuedFocus = null;
                break;
              case TOP_DRAG_ENTER:
              case TOP_DRAG_LEAVE:
                queuedDrag = null;
                break;
              case TOP_MOUSE_OVER:
              case TOP_MOUSE_OUT:
                queuedMouse = null;
                break;
              case TOP_POINTER_OVER:
              case TOP_POINTER_OUT: {
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
              }
              case TOP_GOT_POINTER_CAPTURE:
              case TOP_LOST_POINTER_CAPTURE: {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode$1(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {
            switch (topLevelType) {
              case TOP_FOCUS: {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, topLevelType, eventSystemFlags, container, focusEvent);
                return true;
              }
              case TOP_DRAG_ENTER: {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, topLevelType, eventSystemFlags, container, dragEvent);
                return true;
              }
              case TOP_MOUSE_OVER: {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, topLevelType, eventSystemFlags, container, mouseEvent);
                return true;
              }
              case TOP_POINTER_OVER: {
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, topLevelType, eventSystemFlags, container, pointerEvent));
                return true;
              }
              case TOP_GOT_POINTER_CAPTURE: {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, topLevelType, eventSystemFlags, container, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    Scheduler.unstable_runWithPriority(queuedTarget.priority, function() {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    });
                    return;
                  }
                } else if (tag === HostRoot) {
                  var root3 = nearestMounted.stateNode;
                  if (root3.hydrate) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var nextBlockedOn = attemptToDispatchEvent(queuedEvent.topLevelType, queuedEvent.eventSystemFlags, queuedEvent.container, queuedEvent.nativeEvent);
            if (nextBlockedOn !== null) {
              var _fiber3 = getInstanceFromNode$1(nextBlockedOn);
              if (_fiber3 !== null) {
                attemptContinuousHydration(_fiber3);
              }
              queuedEvent.blockedOn = nextBlockedOn;
              return false;
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map.delete(key);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            while (queuedDiscreteEvents.length > 0) {
              var nextDiscreteEvent = queuedDiscreteEvents[0];
              if (nextDiscreteEvent.blockedOn !== null) {
                var _fiber4 = getInstanceFromNode$1(nextDiscreteEvent.blockedOn);
                if (_fiber4 !== null) {
                  attemptUserBlockingHydration(_fiber4);
                }
                break;
              }
              var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.topLevelType, nextDiscreteEvent.eventSystemFlags, nextDiscreteEvent.container, nextDiscreteEvent.nativeEvent);
              if (nextBlockedOn !== null) {
                nextDiscreteEvent.blockedOn = nextBlockedOn;
              } else {
                queuedDiscreteEvents.shift();
              }
            }
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i = 1; i < queuedDiscreteEvents.length; i++) {
                var queuedEvent = queuedDiscreteEvents[i];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          function addEventBubbleListener(element, eventType, listener) {
            element.addEventListener(eventType, listener, false);
          }
          function addEventCaptureListener(element, eventType, listener) {
            element.addEventListener(eventType, listener, true);
          }
          var simpleEventPluginEventTypes = {};
          var topLevelEventsToDispatchConfig = /* @__PURE__ */ new Map();
          var eventPriorities = /* @__PURE__ */ new Map();
          var discreteEventPairsForSimpleEventPlugin = [TOP_BLUR, "blur", TOP_CANCEL, "cancel", TOP_CLICK, "click", TOP_CLOSE, "close", TOP_CONTEXT_MENU, "contextMenu", TOP_COPY, "copy", TOP_CUT, "cut", TOP_AUX_CLICK, "auxClick", TOP_DOUBLE_CLICK, "doubleClick", TOP_DRAG_END, "dragEnd", TOP_DRAG_START, "dragStart", TOP_DROP, "drop", TOP_FOCUS, "focus", TOP_INPUT, "input", TOP_INVALID, "invalid", TOP_KEY_DOWN, "keyDown", TOP_KEY_PRESS, "keyPress", TOP_KEY_UP, "keyUp", TOP_MOUSE_DOWN, "mouseDown", TOP_MOUSE_UP, "mouseUp", TOP_PASTE, "paste", TOP_PAUSE, "pause", TOP_PLAY, "play", TOP_POINTER_CANCEL, "pointerCancel", TOP_POINTER_DOWN, "pointerDown", TOP_POINTER_UP, "pointerUp", TOP_RATE_CHANGE, "rateChange", TOP_RESET, "reset", TOP_SEEKED, "seeked", TOP_SUBMIT, "submit", TOP_TOUCH_CANCEL, "touchCancel", TOP_TOUCH_END, "touchEnd", TOP_TOUCH_START, "touchStart", TOP_VOLUME_CHANGE, "volumeChange"];
          var otherDiscreteEvents = [TOP_CHANGE, TOP_SELECTION_CHANGE, TOP_TEXT_INPUT, TOP_COMPOSITION_START, TOP_COMPOSITION_END, TOP_COMPOSITION_UPDATE];
          var userBlockingPairsForSimpleEventPlugin = [TOP_DRAG, "drag", TOP_DRAG_ENTER, "dragEnter", TOP_DRAG_EXIT, "dragExit", TOP_DRAG_LEAVE, "dragLeave", TOP_DRAG_OVER, "dragOver", TOP_MOUSE_MOVE, "mouseMove", TOP_MOUSE_OUT, "mouseOut", TOP_MOUSE_OVER, "mouseOver", TOP_POINTER_MOVE, "pointerMove", TOP_POINTER_OUT, "pointerOut", TOP_POINTER_OVER, "pointerOver", TOP_SCROLL, "scroll", TOP_TOGGLE, "toggle", TOP_TOUCH_MOVE, "touchMove", TOP_WHEEL, "wheel"];
          var continuousPairsForSimpleEventPlugin = [TOP_ABORT, "abort", TOP_ANIMATION_END, "animationEnd", TOP_ANIMATION_ITERATION, "animationIteration", TOP_ANIMATION_START, "animationStart", TOP_CAN_PLAY, "canPlay", TOP_CAN_PLAY_THROUGH, "canPlayThrough", TOP_DURATION_CHANGE, "durationChange", TOP_EMPTIED, "emptied", TOP_ENCRYPTED, "encrypted", TOP_ENDED, "ended", TOP_ERROR, "error", TOP_GOT_POINTER_CAPTURE, "gotPointerCapture", TOP_LOAD, "load", TOP_LOADED_DATA, "loadedData", TOP_LOADED_METADATA, "loadedMetadata", TOP_LOAD_START, "loadStart", TOP_LOST_POINTER_CAPTURE, "lostPointerCapture", TOP_PLAYING, "playing", TOP_PROGRESS, "progress", TOP_SEEKING, "seeking", TOP_STALLED, "stalled", TOP_SUSPEND, "suspend", TOP_TIME_UPDATE, "timeUpdate", TOP_TRANSITION_END, "transitionEnd", TOP_WAITING, "waiting"];
          function processSimpleEventPluginPairsByPriority(eventTypes2, priority) {
            for (var i = 0; i < eventTypes2.length; i += 2) {
              var topEvent = eventTypes2[i];
              var event = eventTypes2[i + 1];
              var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
              var onEvent = "on" + capitalizedEvent;
              var config = {
                phasedRegistrationNames: {
                  bubbled: onEvent,
                  captured: onEvent + "Capture"
                },
                dependencies: [topEvent],
                eventPriority: priority
              };
              eventPriorities.set(topEvent, priority);
              topLevelEventsToDispatchConfig.set(topEvent, config);
              simpleEventPluginEventTypes[event] = config;
            }
          }
          function processTopEventPairsByPriority(eventTypes2, priority) {
            for (var i = 0; i < eventTypes2.length; i++) {
              eventPriorities.set(eventTypes2[i], priority);
            }
          }
          processSimpleEventPluginPairsByPriority(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
          processSimpleEventPluginPairsByPriority(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
          processSimpleEventPluginPairsByPriority(continuousPairsForSimpleEventPlugin, ContinuousEvent);
          processTopEventPairsByPriority(otherDiscreteEvents, DiscreteEvent);
          function getEventPriorityForPluginSystem(topLevelType) {
            var priority = eventPriorities.get(topLevelType);
            return priority === void 0 ? ContinuousEvent : priority;
          }
          var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, runWithPriority = Scheduler.unstable_runWithPriority;
          var _enabled = true;
          function setEnabled(enabled) {
            _enabled = !!enabled;
          }
          function isEnabled() {
            return _enabled;
          }
          function trapBubbledEvent(topLevelType, element) {
            trapEventForPluginEventSystem(element, topLevelType, false);
          }
          function trapCapturedEvent(topLevelType, element) {
            trapEventForPluginEventSystem(element, topLevelType, true);
          }
          function trapEventForPluginEventSystem(container, topLevelType, capture) {
            var listener;
            switch (getEventPriorityForPluginSystem(topLevelType)) {
              case DiscreteEvent:
                listener = dispatchDiscreteEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM, container);
                break;
              case UserBlockingEvent:
                listener = dispatchUserBlockingUpdate.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM, container);
                break;
              case ContinuousEvent:
              default:
                listener = dispatchEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM, container);
                break;
            }
            var rawEventName = getRawEventName(topLevelType);
            if (capture) {
              addEventCaptureListener(container, rawEventName, listener);
            } else {
              addEventBubbleListener(container, rawEventName, listener);
            }
          }
          function dispatchDiscreteEvent(topLevelType, eventSystemFlags, container, nativeEvent) {
            flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
            discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, container, nativeEvent);
          }
          function dispatchUserBlockingUpdate(topLevelType, eventSystemFlags, container, nativeEvent) {
            runWithPriority(UserBlockingPriority, dispatchEvent.bind(null, topLevelType, eventSystemFlags, container, nativeEvent));
          }
          function dispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent) {
            if (!_enabled) {
              return;
            }
            if (hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(topLevelType)) {
              queueDiscreteEvent(null, topLevelType, eventSystemFlags, container, nativeEvent);
              return;
            }
            var blockedOn = attemptToDispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent);
            if (blockedOn === null) {
              clearIfContinuousEvent(topLevelType, nativeEvent);
              return;
            }
            if (isReplayableDiscreteEvent(topLevelType)) {
              queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent)) {
              return;
            }
            clearIfContinuousEvent(topLevelType, nativeEvent);
            {
              dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, null);
            }
          }
          function attemptToDispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag === HostRoot) {
                  var root3 = nearestMounted.stateNode;
                  if (root3.hydrate) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            {
              dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);
            }
            return null;
          }
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber = {
            animationIterationCount: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          function dangerousStyleValue(name, value, isCustomProperty) {
            var isEmpty2 = value == null || typeof value === "boolean" || value === "";
            if (isEmpty2) {
              return "";
            }
            if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
              return value + "px";
            }
            return ("" + value).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string) {
              return string.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1, "ms-")));
            };
            var warnBadVendoredStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error("`NaN` is an invalid value for the `%s` css style property.", name);
            };
            var warnStyleValueIsInfinity = function(name, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error("`Infinity` is an invalid value for the `%s` css style property.", name);
            };
            warnValidStyle = function(name, value) {
              if (name.indexOf("-") > -1) {
                warnHyphenatedStyleName(name);
              } else if (badVendoredStyleNamePattern.test(name)) {
                warnBadVendoredStyleName(name);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles34) {
            {
              var serialized = "";
              var delimiter = "";
              for (var styleName in styles34) {
                if (!styles34.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles34[styleName];
                if (styleValue != null) {
                  var isCustomProperty = styleName.indexOf("--") === 0;
                  serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                  delimiter = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node, styles34) {
            var style5 = node.style;
            for (var styleName in styles34) {
              if (!styles34.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty) {
                  warnValidStyle$1(styleName, styles34[styleName]);
                }
              }
              var styleValue = dangerousStyleValue(styleName, styles34[styleName], isCustomProperty);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty) {
                style5.setProperty(styleName, styleValue);
              } else {
                style5[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty(value) {
            return value == null || typeof value === "boolean" || value === "";
          }
          function expandShorthandMap(styles34) {
            var expanded = {};
            for (var key in styles34) {
              var longhands = shorthandToLonghand[key] || [key];
              for (var i = 0; i < longhands.length; i++) {
                expanded[longhands[i]] = key;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key in expandedUpdates) {
                var originalKey = expandedUpdates[key];
                var correctOriginalKey = expandedStyles[key];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
          };
          var voidElementTags = _assign({
            menuitem: true
          }, omittedCloseTags);
          var HTML = "__html";
          var ReactDebugCurrentFrame$3 = null;
          {
            ReactDebugCurrentFrame$3 = ReactSharedInternals.ReactDebugCurrentFrame;
          }
          function assertValidProps(tag, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag]) {
              if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
                {
                  throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`." + ReactDebugCurrentFrame$3.getStackAddendum());
                }
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (!(props.children == null)) {
                {
                  throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
                }
              }
              if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
                {
                  throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.");
                }
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (!(props.style == null || typeof props.style === "object")) {
              {
                throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX." + ReactDebugCurrentFrame$3.getStackAddendum());
              }
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
          function validateProperty(tagName, name) {
            {
              if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
                return true;
              }
              if (rARIACamel.test(name)) {
                var ariaName = "aria-" + name.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                  warnedProperties[name] = true;
                  return true;
                }
                if (name !== correctName) {
                  error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
              if (rARIA.test(name)) {
                var lowerCasedName = name.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name] = true;
                  return false;
                }
                if (name !== standardName) {
                  error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error("Invalid aria prop %s on <%s> tag. For details, see https://fb.me/invalid-aria-prop", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error("Invalid aria props %s on <%s> tag. For details, see https://fb.me/invalid-aria-prop", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var _hasOwnProperty = Object.prototype.hasOwnProperty;
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name, value, canUseEventSystem) {
              if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                return true;
              }
              var lowerCasedName = name.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (canUseEventSystem) {
                if (registrationNameModules.hasOwnProperty(name)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
                if (registrationName != null) {
                  error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name)) {
                  error("Unknown event handler property `%s`. It will be ignored.", name);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name)) {
                if (INVALID_EVENT_NAME_REGEX.test(name)) {
                  error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
                warnedProperties$1[name] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name) {
                  error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (!isReserved && name !== lowerCasedName) {
                error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                if (value) {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
                } else {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                warnedProperties$1[name] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                warnedProperties$1[name] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, canUseEventSystem) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://fb.me/react-attribute-behavior", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://fb.me/react-attribute-behavior", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, canUseEventSystem) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, canUseEventSystem);
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var HTML_NAMESPACE$1 = Namespaces.html;
          var warnedUnknownTags;
          var suppressHydrationWarning;
          var validatePropertiesInDevelopment;
          var warnForTextDifference;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeMarkupForTextOrAttribute;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              time: true,
              dialog: true,
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, true);
            };
            canDiffStyleForHydrationWarning = canUseDOM3 && !document.documentMode;
            var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
            var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
            normalizeMarkupForTextOrAttribute = function(markup) {
              var markupString = typeof markup === "string" ? markup : "" + markup;
              return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
            };
            warnForTextDifference = function(serverText, clientText) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
              var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
              if (normalizedServerText === normalizedClientText) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
            };
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names = [];
              attributeNames.forEach(function(name) {
                names.push(name);
              });
              error("Extra attributes from the server: %s", names);
            };
            warnForInvalidEventListener = function(registrationName, listener) {
              if (listener === false) {
                error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
              }
            };
            normalizeHTML = function(parent, html) {
              var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
              testElement.innerHTML = html;
              return testElement.innerHTML;
            };
          }
          function ensureListeningTo(rootContainerElement, registrationName) {
            var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
            var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
            legacyListenToEvent(registrationName, doc);
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop6() {
          }
          function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop6;
          }
          function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameModules.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  ensureListeningTo(rootContainerElement, propKey);
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i = 0; i < updatePayload.length; i += 2) {
              var propKey = updatePayload[i];
              var propValue = updatePayload[i + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement15(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE$1) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE$1) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div = ownerDocument.createElement("div");
                div.innerHTML = "<script><\/script>";
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node = domElement;
                  if (props.multiple) {
                    node.multiple = true;
                  } else if (props.size) {
                    node.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE$1) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
          }
          function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
              validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
              case "iframe":
              case "object":
              case "embed":
                trapBubbledEvent(TOP_LOAD, domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  trapBubbledEvent(mediaEventTypes[i], domElement);
                }
                props = rawProps;
                break;
              case "source":
                trapBubbledEvent(TOP_ERROR, domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                trapBubbledEvent(TOP_ERROR, domElement);
                trapBubbledEvent(TOP_LOAD, domElement);
                props = rawProps;
                break;
              case "form":
                trapBubbledEvent(TOP_RESET, domElement);
                trapBubbledEvent(TOP_SUBMIT, domElement);
                props = rawProps;
                break;
              case "details":
                trapBubbledEvent(TOP_TOGGLE, domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                trapBubbledEvent(TOP_INVALID, domElement);
                ensureListeningTo(rootContainerElement, "onChange");
                break;
              case "option":
                validateProps(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                trapBubbledEvent(TOP_INVALID, domElement);
                ensureListeningTo(rootContainerElement, "onChange");
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$3(domElement, rawProps);
                trapBubbledEvent(TOP_INVALID, domElement);
                ensureListeningTo(rootContainerElement, "onChange");
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "option":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$3(domElement, lastRawProps);
                nextProps = getHostProps$3(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameModules.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (lastProp !== nextProp && (typeof nextProp === "string" || typeof nextProp === "number")) {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (registrationNameModules.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  ensureListeningTo(rootContainerElement, propKey);
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
              isCustomComponentTag = isCustomComponent(tag, rawProps);
              validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
              case "iframe":
              case "object":
              case "embed":
                trapBubbledEvent(TOP_LOAD, domElement);
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  trapBubbledEvent(mediaEventTypes[i], domElement);
                }
                break;
              case "source":
                trapBubbledEvent(TOP_ERROR, domElement);
                break;
              case "img":
              case "image":
              case "link":
                trapBubbledEvent(TOP_ERROR, domElement);
                trapBubbledEvent(TOP_LOAD, domElement);
                break;
              case "form":
                trapBubbledEvent(TOP_RESET, domElement);
                trapBubbledEvent(TOP_SUBMIT, domElement);
                break;
              case "details":
                trapBubbledEvent(TOP_TOGGLE, domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                trapBubbledEvent(TOP_INVALID, domElement);
                ensureListeningTo(rootContainerElement, "onChange");
                break;
              case "option":
                validateProps(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                trapBubbledEvent(TOP_INVALID, domElement);
                ensureListeningTo(rootContainerElement, "onChange");
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                trapBubbledEvent(TOP_INVALID, domElement);
                ensureListeningTo(rootContainerElement, "onChange");
                break;
            }
            assertValidProps(tag, rawProps);
            {
              extraAttributeNames = /* @__PURE__ */ new Set();
              var attributes = domElement.attributes;
              for (var _i = 0; _i < attributes.length; _i++) {
                var name = attributes[_i].name.toLowerCase();
                switch (name) {
                  case "data-reactroot":
                    break;
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (!suppressHydrationWarning) {
                      warnForTextDifference(domElement.textContent, nextProp);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (!suppressHydrationWarning) {
                      warnForTextDifference(domElement.textContent, nextProp);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameModules.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  ensureListeningTo(rootContainerElement, propKey);
                }
              } else if (typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = getPropertyInfo(propKey);
                if (suppressHydrationWarning)
                  ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")
                  ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  var expectedHTML = normalizeHTML(domElement, nextHtml != null ? nextHtml : "");
                  if (expectedHTML !== serverHTML) {
                    warnForPropDifference(propKey, serverHTML, expectedHTML);
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE$1) {
                      ownNamespace = getIntrinsicNamespace(tag);
                    }
                    if (ownNamespace === HTML_NAMESPACE$1) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
                warnForExtraAttributes(extraAttributeNames);
              }
            }
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text) {
            var isDifferent = textNode.nodeValue !== text;
            return isDifferent;
          }
          function warnForUnmatchedText(textNode, text) {
            {
              warnForTextDifference(textNode.nodeValue, text);
            }
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text) {
            {
              if (text === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          function getActiveElement(doc) {
            doc = doc || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc === "undefined") {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e) {
              return doc.body;
            }
          }
          function getLeafNode(node) {
            while (node && node.firstChild) {
              node = node.firstChild;
            }
            return node;
          }
          function getSiblingNode(node) {
            while (node) {
              if (node.nextSibling) {
                return node.nextSibling;
              }
              node = node.parentNode;
            }
          }
          function getNodeForCharacterOffset(root3, offset) {
            var node = getLeafNode(root3);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
              if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset && nodeEnd >= offset) {
                  return {
                    node,
                    offset: offset - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node = getLeafNode(getSiblingNode(node));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win2 = ownerDocument && ownerDocument.defaultView || window;
            var selection = win2.getSelection && win2.getSelection();
            if (!selection || selection.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length = 0;
            var start = -1;
            var end = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer:
              while (true) {
                var next = null;
                while (true) {
                  if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                    start = length + anchorOffset;
                  }
                  if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                    end = length + focusOffset;
                  }
                  if (node.nodeType === TEXT_NODE) {
                    length += node.nodeValue.length;
                  }
                  if ((next = node.firstChild) === null) {
                    break;
                  }
                  parentNode = node;
                  node = next;
                }
                while (true) {
                  if (node === outerNode) {
                    break outer;
                  }
                  if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                    start = length;
                  }
                  if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                    end = length;
                  }
                  if ((next = node.nextSibling) !== null) {
                    break;
                  }
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
            if (start === -1 || end === -1) {
              return null;
            }
            return {
              start,
              end
            };
          }
          function setOffsets(node, offsets) {
            var doc = node.ownerDocument || document;
            var win2 = doc && doc.defaultView || window;
            if (!win2.getSelection) {
              return;
            }
            var selection = win2.getSelection();
            var length = node.textContent.length;
            var start = Math.min(offsets.start, length);
            var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
            if (!selection.extend && start > end) {
              var temp = end;
              end = start;
              start = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start);
            var endMarker = getNodeForCharacterOffset(node, end);
            if (startMarker && endMarker) {
              if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                return;
              }
              var range = doc.createRange();
              range.setStart(startMarker.node, startMarker.offset);
              selection.removeAllRanges();
              if (start > end) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset);
              } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range);
              }
            }
          }
          function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win2 = window;
            var element = getActiveElement();
            while (element instanceof win2.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win2 = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement(win2.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              activeElementDetached: null,
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i = 0; i < ancestors.length; i++) {
                var info = ancestors[i];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection(input) {
            var selection;
            if ("selectionStart" in input) {
              selection = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection = getOffsets(input);
            }
            return selection || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start = offsets.start, end = offsets.end;
            if (end === void 0) {
              end = start;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start;
              input.selectionEnd = Math.min(end, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag) {
              var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag
              };
              if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag === "dd" || tag === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag, parentTag) {
              switch (parentTag) {
                case "select":
                  return tag === "option" || tag === "optgroup" || tag === "#text";
                case "optgroup":
                  return tag === "option" || tag === "#text";
                case "option":
                  return tag === "#text";
                case "tr":
                  return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
                case "colgroup":
                  return tag === "col" || tag === "template";
                case "table":
                  return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
                case "head":
                  return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
                case "html":
                  return tag === "head" || tag === "body" || tag === "frameset";
                case "frameset":
                  return tag === "frame";
                case "#document":
                  return tag === "html";
              }
              switch (tag) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag, ancestorInfo) {
              switch (tag) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var addendum = getCurrentFiberStackInDev();
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag + "|" + addendum;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1;
          {
            SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          }
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function shouldAutoFocusHostComponent(type, props) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
            }
            return false;
          }
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root3 = rootContainerInstance.documentElement;
                namespace = root3 ? root3.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container.namespaceURI || null;
                type = container.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            setEnabled(false);
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement15(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            return shouldAutoFocusHostComponent(type, props);
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "option" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function shouldDeprioritizeSubtree(type, props) {
            return !!props.hidden;
          }
          function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            if (shouldAutoFocusHostComponent(type, newProps)) {
              domElement.focus();
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateFiberProps(domElement, newProps);
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container, child) {
            var parentNode;
            if (container.nodeType === COMMENT_NODE) {
              parentNode = container.parentNode;
              parentNode.insertBefore(child, container);
            } else {
              parentNode = container;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container, child, beforeChild) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.insertBefore(child, beforeChild);
            } else {
              container.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container, child) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.removeChild(child);
            } else {
              container.removeChild(child);
            }
          }
          function hideInstance(instance) {
            instance = instance;
            var style5 = instance.style;
            if (typeof style5.setProperty === "function") {
              style5.setProperty("display", "none", "important");
            } else {
              style5.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue("display", display);
          }
          function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text) {
            if (text === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                break;
              }
            }
            return node;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
          }
          function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            return diffHydratedText(textInstance, text);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth2 = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth2 === 0) {
                    return getNextHydratableSibling(node);
                  } else {
                    depth2--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  depth2++;
                }
              }
              node = node.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth2 = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (depth2 === 0) {
                    return node;
                  } else {
                    depth2--;
                  }
                } else if (data === SUSPENSE_END_DATA) {
                  depth2++;
                }
              }
              node = node.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container) {
            retryIfBlockedOn(container);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
            {
              warnForUnmatchedText(textInstance, text);
            }
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForUnmatchedText(textInstance, text);
            }
          }
          function didNotHydrateContainerInstance(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentInstance, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentInstance, instance);
              }
            }
          }
          function didNotFindHydratableContainerInstance(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableContainerTextInstance(parentContainer, text) {
            {
              warnForInsertedHydratedText(parentContainer, text);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedElement(parentInstance, type);
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedText(parentInstance, text);
            }
          }
          function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true)
              ;
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactInternalInstance$" + randomKey;
          var internalEventHandlersKey = "__reactEventHandlers$" + randomKey;
          var internalContainerInstanceKey = "__reactContainere$" + randomKey;
          function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode$1(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance$1(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            {
              {
                throw Error("getNodeFromInstance: Invalid argument.");
              }
            }
          }
          function getFiberCurrentPropsFromNode$1(node) {
            return node[internalEventHandlersKey] || null;
          }
          function updateFiberProps(node, props) {
            node[internalEventHandlersKey] = props;
          }
          function getParent(inst) {
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var depthA = 0;
            for (var tempA = instA; tempA; tempA = getParent(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = instB; tempB; tempB = getParent(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              instA = getParent(instA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              instB = getParent(instB);
              depthB--;
            }
            var depth2 = depthA;
            while (depth2--) {
              if (instA === instB || instA === instB.alternate) {
                return instA;
              }
              instA = getParent(instA);
              instB = getParent(instB);
            }
            return null;
          }
          function traverseTwoPhase(inst, fn, arg) {
            var path = [];
            while (inst) {
              path.push(inst);
              inst = getParent(inst);
            }
            var i;
            for (i = path.length; i-- > 0; ) {
              fn(path[i], "captured", arg);
            }
            for (i = 0; i < path.length; i++) {
              fn(path[i], "bubbled", arg);
            }
          }
          function traverseEnterLeave(from, to, fn, argFrom, argTo) {
            var common = from && to ? getLowestCommonAncestor(from, to) : null;
            var pathFrom = [];
            while (true) {
              if (!from) {
                break;
              }
              if (from === common) {
                break;
              }
              var alternate = from.alternate;
              if (alternate !== null && alternate === common) {
                break;
              }
              pathFrom.push(from);
              from = getParent(from);
            }
            var pathTo = [];
            while (true) {
              if (!to) {
                break;
              }
              if (to === common) {
                break;
              }
              var _alternate = to.alternate;
              if (_alternate !== null && _alternate === common) {
                break;
              }
              pathTo.push(to);
              to = getParent(to);
            }
            for (var i = 0; i < pathFrom.length; i++) {
              fn(pathFrom[i], "bubbled", argFrom);
            }
            for (var _i = pathTo.length; _i-- > 0; ) {
              fn(pathTo[_i], "captured", argTo);
            }
          }
          function isInteractive(tag) {
            return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
          }
          function shouldPreventMouseEvent(name, type, props) {
            switch (name) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var listener;
            var stateNode = inst.stateNode;
            if (!stateNode) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (!props) {
              return null;
            }
            listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (!(!listener || typeof listener === "function")) {
              {
                throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
              }
            }
            return listener;
          }
          function listenerAtPhase(inst, event, propagationPhase) {
            var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
            return getListener(inst, registrationName);
          }
          function accumulateDirectionalDispatches(inst, phase, event) {
            {
              if (!inst) {
                error("Dispatching inst must not be null");
              }
            }
            var listener = listenerAtPhase(inst, event, phase);
            if (listener) {
              event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
              event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
            }
          }
          function accumulateTwoPhaseDispatchesSingle(event) {
            if (event && event.dispatchConfig.phasedRegistrationNames) {
              traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
            }
          }
          function accumulateDispatches(inst, ignoredDirection, event) {
            if (inst && event && event.dispatchConfig.registrationName) {
              var registrationName = event.dispatchConfig.registrationName;
              var listener = getListener(inst, registrationName);
              if (listener) {
                event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
                event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
              }
            }
          }
          function accumulateDirectDispatchesSingle(event) {
            if (event && event.dispatchConfig.registrationName) {
              accumulateDispatches(event._targetInst, null, event);
            }
          }
          function accumulateTwoPhaseDispatches(events) {
            forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
          }
          function accumulateEnterLeaveDispatches(leave, enter, from, to) {
            traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
          }
          function accumulateDirectDispatches(events) {
            forEachAccumulated(events, accumulateDirectDispatchesSingle);
          }
          var root2 = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root2 = nativeEventTarget;
            startText = getText();
            return true;
          }
          function reset() {
            root2 = null;
            startText = null;
            fallbackText = null;
          }
          function getData() {
            if (fallbackText) {
              return fallbackText;
            }
            var start;
            var startValue = startText;
            var startLength = startValue.length;
            var end;
            var endValue = getText();
            var endLength = endValue.length;
            for (start = 0; start < startLength; start++) {
              if (startValue[start] !== endValue[start]) {
                break;
              }
            }
            var minEnd = startLength - start;
            for (end = 1; end <= minEnd; end++) {
              if (startValue[startLength - end] !== endValue[endLength - end]) {
                break;
              }
            }
            var sliceTail = end > 1 ? 1 - end : void 0;
            fallbackText = endValue.slice(start, sliceTail);
            return fallbackText;
          }
          function getText() {
            if ("value" in root2) {
              return root2.value;
            }
            return root2.textContent;
          }
          var EVENT_POOL_SIZE = 10;
          var EventInterface = {
            type: null,
            target: null,
            currentTarget: function() {
              return null;
            },
            eventPhase: null,
            bubbles: null,
            cancelable: null,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: null,
            isTrusted: null
          };
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
            {
              delete this.nativeEvent;
              delete this.preventDefault;
              delete this.stopPropagation;
              delete this.isDefaultPrevented;
              delete this.isPropagationStopped;
            }
            this.dispatchConfig = dispatchConfig;
            this._targetInst = targetInst;
            this.nativeEvent = nativeEvent;
            var Interface = this.constructor.Interface;
            for (var propName in Interface) {
              if (!Interface.hasOwnProperty(propName)) {
                continue;
              }
              {
                delete this[propName];
              }
              var normalize2 = Interface[propName];
              if (normalize2) {
                this[propName] = normalize2(nativeEvent);
              } else {
                if (propName === "target") {
                  this.target = nativeEventTarget;
                } else {
                  this[propName] = nativeEvent[propName];
                }
              }
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) {
              this.isDefaultPrevented = functionThatReturnsTrue;
            } else {
              this.isDefaultPrevented = functionThatReturnsFalse;
            }
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          _assign(SyntheticEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.preventDefault) {
                event.preventDefault();
              } else if (typeof event.returnValue !== "unknown") {
                event.returnValue = false;
              }
              this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.stopPropagation) {
                event.stopPropagation();
              } else if (typeof event.cancelBubble !== "unknown") {
                event.cancelBubble = true;
              }
              this.isPropagationStopped = functionThatReturnsTrue;
            },
            persist: function() {
              this.isPersistent = functionThatReturnsTrue;
            },
            isPersistent: functionThatReturnsFalse,
            destructor: function() {
              var Interface = this.constructor.Interface;
              for (var propName in Interface) {
                {
                  Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
                }
              }
              this.dispatchConfig = null;
              this._targetInst = null;
              this.nativeEvent = null;
              this.isDefaultPrevented = functionThatReturnsFalse;
              this.isPropagationStopped = functionThatReturnsFalse;
              this._dispatchListeners = null;
              this._dispatchInstances = null;
              {
                Object.defineProperty(this, "nativeEvent", getPooledWarningPropertyDefinition("nativeEvent", null));
                Object.defineProperty(this, "isDefaultPrevented", getPooledWarningPropertyDefinition("isDefaultPrevented", functionThatReturnsFalse));
                Object.defineProperty(this, "isPropagationStopped", getPooledWarningPropertyDefinition("isPropagationStopped", functionThatReturnsFalse));
                Object.defineProperty(this, "preventDefault", getPooledWarningPropertyDefinition("preventDefault", function() {
                }));
                Object.defineProperty(this, "stopPropagation", getPooledWarningPropertyDefinition("stopPropagation", function() {
                }));
              }
            }
          });
          SyntheticEvent.Interface = EventInterface;
          SyntheticEvent.extend = function(Interface) {
            var Super = this;
            var E = function() {
            };
            E.prototype = Super.prototype;
            var prototype2 = new E();
            function Class() {
              return Super.apply(this, arguments);
            }
            _assign(prototype2, Class.prototype);
            Class.prototype = prototype2;
            Class.prototype.constructor = Class;
            Class.Interface = _assign({}, Super.Interface, Interface);
            Class.extend = Super.extend;
            addEventPoolingTo(Class);
            return Class;
          };
          addEventPoolingTo(SyntheticEvent);
          function getPooledWarningPropertyDefinition(propName, getVal) {
            var isFunction = typeof getVal === "function";
            return {
              configurable: true,
              set: set2,
              get: get5
            };
            function set2(val) {
              var action = isFunction ? "setting the method" : "setting the property";
              warn2(action, "This is effectively a no-op");
              return val;
            }
            function get5() {
              var action = isFunction ? "accessing the method" : "accessing the property";
              var result2 = isFunction ? "This is a no-op function" : "This is set to null";
              warn2(action, result2);
              return getVal;
            }
            function warn2(action, result2) {
              {
                error("This synthetic event is reused for performance reasons. If you're seeing this, you're %s `%s` on a released/nullified synthetic event. %s. If you must keep the original synthetic event around, use event.persist(). See https://fb.me/react-event-pooling for more information.", action, propName, result2);
              }
            }
          }
          function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
            var EventConstructor = this;
            if (EventConstructor.eventPool.length) {
              var instance = EventConstructor.eventPool.pop();
              EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
              return instance;
            }
            return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
          }
          function releasePooledEvent(event) {
            var EventConstructor = this;
            if (!(event instanceof EventConstructor)) {
              {
                throw Error("Trying to release an event instance into a pool of a different type.");
              }
            }
            event.destructor();
            if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
              EventConstructor.eventPool.push(event);
            }
          }
          function addEventPoolingTo(EventConstructor) {
            EventConstructor.eventPool = [];
            EventConstructor.getPooled = getPooledEvent;
            EventConstructor.release = releasePooledEvent;
          }
          var SyntheticCompositionEvent = SyntheticEvent.extend({
            data: null
          });
          var SyntheticInputEvent = SyntheticEvent.extend({
            data: null
          });
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM3 && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM3 && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM3 && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM3 && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          var eventTypes = {
            beforeInput: {
              phasedRegistrationNames: {
                bubbled: "onBeforeInput",
                captured: "onBeforeInputCapture"
              },
              dependencies: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]
            },
            compositionEnd: {
              phasedRegistrationNames: {
                bubbled: "onCompositionEnd",
                captured: "onCompositionEndCapture"
              },
              dependencies: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
            },
            compositionStart: {
              phasedRegistrationNames: {
                bubbled: "onCompositionStart",
                captured: "onCompositionStartCapture"
              },
              dependencies: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
            },
            compositionUpdate: {
              phasedRegistrationNames: {
                bubbled: "onCompositionUpdate",
                captured: "onCompositionUpdateCapture"
              },
              dependencies: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
            }
          };
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(topLevelType) {
            switch (topLevelType) {
              case TOP_COMPOSITION_START:
                return eventTypes.compositionStart;
              case TOP_COMPOSITION_END:
                return eventTypes.compositionEnd;
              case TOP_COMPOSITION_UPDATE:
                return eventTypes.compositionUpdate;
            }
          }
          function isFallbackCompositionStart(topLevelType, nativeEvent) {
            return topLevelType === TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(topLevelType, nativeEvent) {
            switch (topLevelType) {
              case TOP_KEY_UP:
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case TOP_KEY_DOWN:
                return nativeEvent.keyCode !== START_KEYCODE;
              case TOP_KEY_PRESS:
              case TOP_MOUSE_DOWN:
              case TOP_BLUR:
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(topLevelType);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
                eventType = eventTypes.compositionStart;
              }
            } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
              eventType = eventTypes.compositionEnd;
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === eventTypes.compositionStart) {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === eventTypes.compositionEnd) {
                if (isComposing) {
                  fallbackData = getData();
                }
              }
            }
            var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
            if (fallbackData) {
              event.data = fallbackData;
            } else {
              var customData = getDataFromCustomEvent(nativeEvent);
              if (customData !== null) {
                event.data = customData;
              }
            }
            accumulateTwoPhaseDispatches(event);
            return event;
          }
          function getNativeBeforeInputChars(topLevelType, nativeEvent) {
            switch (topLevelType) {
              case TOP_COMPOSITION_END:
                return getDataFromCustomEvent(nativeEvent);
              case TOP_KEY_PRESS:
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case TOP_TEXT_INPUT:
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
            if (isComposing) {
              if (topLevelType === TOP_COMPOSITION_END || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                var chars = getData();
                reset();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (topLevelType) {
              case TOP_PASTE:
                return null;
              case TOP_KEY_PRESS:
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case TOP_COMPOSITION_END:
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
            event.data = chars;
            accumulateTwoPhaseDispatches(event);
            return event;
          }
          var BeforeInputEventPlugin = {
            eventTypes,
            extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
              var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);
              var beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);
              if (composition === null) {
                return beforeInput;
              }
              if (beforeInput === null) {
                return composition;
              }
              return [composition, beforeInput];
            }
          };
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          var eventTypes$1 = {
            change: {
              phasedRegistrationNames: {
                bubbled: "onChange",
                captured: "onChangeCapture"
              },
              dependencies: [TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE]
            }
          };
          function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
            var event = SyntheticEvent.getPooled(eventTypes$1.change, inst, nativeEvent, target);
            event.type = "change";
            enqueueStateRestore(target);
            accumulateTwoPhaseDispatches(event);
            return event;
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates(runEventInBatch, event);
          }
          function runEventInBatch(event) {
            runEventsInBatch(event);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance$1(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(topLevelType, targetInst) {
            if (topLevelType === TOP_CHANGE) {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM3) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
            if (topLevelType === TOP_FOCUS) {
              stopWatchingForValueChange();
              startWatchingForValueChange(target, targetInst);
            } else if (topLevelType === TOP_BLUR) {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
            if (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
          }
          function getTargetInstForClickEvent(topLevelType, targetInst) {
            if (topLevelType === TOP_CLICK) {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
            if (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node) {
            var state = node._wrapperState;
            if (!state || !state.controlled || node.type !== "number") {
              return;
            }
            {
              setDefaultValue(node, "number", node.value);
            }
          }
          var ChangeEventPlugin = {
            eventTypes: eventTypes$1,
            _isInputEventSupported: isInputEventSupported,
            extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
              var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;
              var getTargetInstFunc, handleEventFunc;
              if (shouldUseChangeEvent(targetNode)) {
                getTargetInstFunc = getTargetInstForChangeEvent;
              } else if (isTextInputElement(targetNode)) {
                if (isInputEventSupported) {
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                } else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  handleEventFunc = handleEventsForInputEventPolyfill;
                }
              } else if (shouldUseClickEvent(targetNode)) {
                getTargetInstFunc = getTargetInstForClickEvent;
              }
              if (getTargetInstFunc) {
                var inst = getTargetInstFunc(topLevelType, targetInst);
                if (inst) {
                  var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
                  return event;
                }
              }
              if (handleEventFunc) {
                handleEventFunc(topLevelType, targetNode, targetInst);
              }
              if (topLevelType === TOP_BLUR) {
                handleControlledInputBlur(targetNode);
              }
            }
          };
          var SyntheticUIEvent = SyntheticEvent.extend({
            view: null,
            detail: null
          });
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var previousScreenX = 0;
          var previousScreenY = 0;
          var isMovementXSet = false;
          var isMovementYSet = false;
          var SyntheticMouseEvent = SyntheticUIEvent.extend({
            screenX: null,
            screenY: null,
            clientX: null,
            clientY: null,
            pageX: null,
            pageY: null,
            ctrlKey: null,
            shiftKey: null,
            altKey: null,
            metaKey: null,
            getModifierState: getEventModifierState,
            button: null,
            buttons: null,
            relatedTarget: function(event) {
              return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              var screenX = previousScreenX;
              previousScreenX = event.screenX;
              if (!isMovementXSet) {
                isMovementXSet = true;
                return 0;
              }
              return event.type === "mousemove" ? event.screenX - screenX : 0;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              var screenY = previousScreenY;
              previousScreenY = event.screenY;
              if (!isMovementYSet) {
                isMovementYSet = true;
                return 0;
              }
              return event.type === "mousemove" ? event.screenY - screenY : 0;
            }
          });
          var SyntheticPointerEvent = SyntheticMouseEvent.extend({
            pointerId: null,
            width: null,
            height: null,
            pressure: null,
            tangentialPressure: null,
            tiltX: null,
            tiltY: null,
            twist: null,
            pointerType: null,
            isPrimary: null
          });
          var eventTypes$2 = {
            mouseEnter: {
              registrationName: "onMouseEnter",
              dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]
            },
            mouseLeave: {
              registrationName: "onMouseLeave",
              dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]
            },
            pointerEnter: {
              registrationName: "onPointerEnter",
              dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]
            },
            pointerLeave: {
              registrationName: "onPointerLeave",
              dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]
            }
          };
          var EnterLeaveEventPlugin = {
            eventTypes: eventTypes$2,
            extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
              var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;
              var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;
              if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0 && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
                return null;
              }
              if (!isOutEvent && !isOverEvent) {
                return null;
              }
              var win2;
              if (nativeEventTarget.window === nativeEventTarget) {
                win2 = nativeEventTarget;
              } else {
                var doc = nativeEventTarget.ownerDocument;
                if (doc) {
                  win2 = doc.defaultView || doc.parentWindow;
                } else {
                  win2 = window;
                }
              }
              var from;
              var to;
              if (isOutEvent) {
                from = targetInst;
                var related = nativeEvent.relatedTarget || nativeEvent.toElement;
                to = related ? getClosestInstanceFromNode(related) : null;
                if (to !== null) {
                  var nearestMounted = getNearestMountedFiber(to);
                  if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                    to = null;
                  }
                }
              } else {
                from = null;
                to = targetInst;
              }
              if (from === to) {
                return null;
              }
              var eventInterface, leaveEventType, enterEventType, eventTypePrefix;
              if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {
                eventInterface = SyntheticMouseEvent;
                leaveEventType = eventTypes$2.mouseLeave;
                enterEventType = eventTypes$2.mouseEnter;
                eventTypePrefix = "mouse";
              } else if (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {
                eventInterface = SyntheticPointerEvent;
                leaveEventType = eventTypes$2.pointerLeave;
                enterEventType = eventTypes$2.pointerEnter;
                eventTypePrefix = "pointer";
              }
              var fromNode = from == null ? win2 : getNodeFromInstance$1(from);
              var toNode = to == null ? win2 : getNodeFromInstance$1(to);
              var leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);
              leave.type = eventTypePrefix + "leave";
              leave.target = fromNode;
              leave.relatedTarget = toNode;
              var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);
              enter.type = eventTypePrefix + "enter";
              enter.target = toNode;
              enter.relatedTarget = fromNode;
              accumulateEnterLeaveDispatches(leave, enter, from, to);
              if ((eventSystemFlags & IS_FIRST_ANCESTOR) === 0) {
                return [leave];
              }
              return [leave, enter];
            }
          };
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs2 = typeof Object.is === "function" ? Object.is : is;
          var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
          function shallowEqual(objA, objB) {
            if (objectIs2(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i = 0; i < keysA.length; i++) {
              if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs2(objA[keysA[i]], objB[keysA[i]])) {
                return false;
              }
            }
            return true;
          }
          var skipSelectionChangeEvent = canUseDOM3 && "documentMode" in document && document.documentMode <= 11;
          var eventTypes$3 = {
            select: {
              phasedRegistrationNames: {
                bubbled: "onSelect",
                captured: "onSelectCapture"
              },
              dependencies: [TOP_BLUR, TOP_CONTEXT_MENU, TOP_DRAG_END, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE]
            }
          };
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node) {
            if ("selectionStart" in node && hasSelectionCapabilities(node)) {
              return {
                start: node.selectionStart,
                end: node.selectionEnd
              };
            } else {
              var win2 = node.ownerDocument && node.ownerDocument.defaultView || window;
              var selection = win2.getSelection();
              return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
              return null;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);
              syntheticEvent.type = "select";
              syntheticEvent.target = activeElement$1;
              accumulateTwoPhaseDispatches(syntheticEvent);
              return syntheticEvent;
            }
            return null;
          }
          var SelectEventPlugin = {
            eventTypes: eventTypes$3,
            extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, container) {
              var containerOrDoc = container || getEventTargetDocument(nativeEventTarget);
              if (!containerOrDoc || !isListeningToAllDependencies("onSelect", containerOrDoc)) {
                return null;
              }
              var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;
              switch (topLevelType) {
                case TOP_FOCUS:
                  if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                    activeElement$1 = targetNode;
                    activeElementInst$1 = targetInst;
                    lastSelection = null;
                  }
                  break;
                case TOP_BLUR:
                  activeElement$1 = null;
                  activeElementInst$1 = null;
                  lastSelection = null;
                  break;
                case TOP_MOUSE_DOWN:
                  mouseDown = true;
                  break;
                case TOP_CONTEXT_MENU:
                case TOP_MOUSE_UP:
                case TOP_DRAG_END:
                  mouseDown = false;
                  return constructSelectEvent(nativeEvent, nativeEventTarget);
                case TOP_SELECTION_CHANGE:
                  if (skipSelectionChangeEvent) {
                    break;
                  }
                case TOP_KEY_DOWN:
                case TOP_KEY_UP:
                  return constructSelectEvent(nativeEvent, nativeEventTarget);
              }
              return null;
            }
          };
          var SyntheticAnimationEvent = SyntheticEvent.extend({
            animationName: null,
            elapsedTime: null,
            pseudoElement: null
          });
          var SyntheticClipboardEvent = SyntheticEvent.extend({
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticFocusEvent = SyntheticUIEvent.extend({
            relatedTarget: null
          });
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if (key !== "Unidentified") {
                return key;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var SyntheticKeyboardEvent = SyntheticUIEvent.extend({
            key: getEventKey,
            location: null,
            ctrlKey: null,
            shiftKey: null,
            altKey: null,
            metaKey: null,
            repeat: null,
            locale: null,
            getModifierState: getEventModifierState,
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticDragEvent = SyntheticMouseEvent.extend({
            dataTransfer: null
          });
          var SyntheticTouchEvent = SyntheticUIEvent.extend({
            touches: null,
            targetTouches: null,
            changedTouches: null,
            altKey: null,
            metaKey: null,
            ctrlKey: null,
            shiftKey: null,
            getModifierState: getEventModifierState
          });
          var SyntheticTransitionEvent = SyntheticEvent.extend({
            propertyName: null,
            elapsedTime: null,
            pseudoElement: null
          });
          var SyntheticWheelEvent = SyntheticMouseEvent.extend({
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
            },
            deltaZ: null,
            deltaMode: null
          });
          var knownHTMLTopLevelTypes = [TOP_ABORT, TOP_CANCEL, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_CLOSE, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_INPUT, TOP_INVALID, TOP_LOAD, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_RESET, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUBMIT, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_TOGGLE, TOP_VOLUME_CHANGE, TOP_WAITING];
          var SimpleEventPlugin = {
            eventTypes: simpleEventPluginEventTypes,
            extractEvents: function(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
              var dispatchConfig = topLevelEventsToDispatchConfig.get(topLevelType);
              if (!dispatchConfig) {
                return null;
              }
              var EventConstructor;
              switch (topLevelType) {
                case TOP_KEY_PRESS:
                  if (getEventCharCode(nativeEvent) === 0) {
                    return null;
                  }
                case TOP_KEY_DOWN:
                case TOP_KEY_UP:
                  EventConstructor = SyntheticKeyboardEvent;
                  break;
                case TOP_BLUR:
                case TOP_FOCUS:
                  EventConstructor = SyntheticFocusEvent;
                  break;
                case TOP_CLICK:
                  if (nativeEvent.button === 2) {
                    return null;
                  }
                case TOP_AUX_CLICK:
                case TOP_DOUBLE_CLICK:
                case TOP_MOUSE_DOWN:
                case TOP_MOUSE_MOVE:
                case TOP_MOUSE_UP:
                case TOP_MOUSE_OUT:
                case TOP_MOUSE_OVER:
                case TOP_CONTEXT_MENU:
                  EventConstructor = SyntheticMouseEvent;
                  break;
                case TOP_DRAG:
                case TOP_DRAG_END:
                case TOP_DRAG_ENTER:
                case TOP_DRAG_EXIT:
                case TOP_DRAG_LEAVE:
                case TOP_DRAG_OVER:
                case TOP_DRAG_START:
                case TOP_DROP:
                  EventConstructor = SyntheticDragEvent;
                  break;
                case TOP_TOUCH_CANCEL:
                case TOP_TOUCH_END:
                case TOP_TOUCH_MOVE:
                case TOP_TOUCH_START:
                  EventConstructor = SyntheticTouchEvent;
                  break;
                case TOP_ANIMATION_END:
                case TOP_ANIMATION_ITERATION:
                case TOP_ANIMATION_START:
                  EventConstructor = SyntheticAnimationEvent;
                  break;
                case TOP_TRANSITION_END:
                  EventConstructor = SyntheticTransitionEvent;
                  break;
                case TOP_SCROLL:
                  EventConstructor = SyntheticUIEvent;
                  break;
                case TOP_WHEEL:
                  EventConstructor = SyntheticWheelEvent;
                  break;
                case TOP_COPY:
                case TOP_CUT:
                case TOP_PASTE:
                  EventConstructor = SyntheticClipboardEvent;
                  break;
                case TOP_GOT_POINTER_CAPTURE:
                case TOP_LOST_POINTER_CAPTURE:
                case TOP_POINTER_CANCEL:
                case TOP_POINTER_DOWN:
                case TOP_POINTER_MOVE:
                case TOP_POINTER_OUT:
                case TOP_POINTER_OVER:
                case TOP_POINTER_UP:
                  EventConstructor = SyntheticPointerEvent;
                  break;
                default:
                  {
                    if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
                      error("SimpleEventPlugin: Unhandled event type, `%s`. This warning is likely caused by a bug in React. Please file an issue.", topLevelType);
                    }
                  }
                  EventConstructor = SyntheticEvent;
                  break;
              }
              var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
              accumulateTwoPhaseDispatches(event);
              return event;
            }
          };
          var DOMEventPluginOrder = ["ResponderEventPlugin", "SimpleEventPlugin", "EnterLeaveEventPlugin", "ChangeEventPlugin", "SelectEventPlugin", "BeforeInputEventPlugin"];
          injectEventPluginOrder(DOMEventPluginOrder);
          setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);
          injectEventPluginsByName({
            SimpleEventPlugin,
            EnterLeaveEventPlugin,
            ChangeEventPlugin,
            SelectEventPlugin,
            BeforeInputEventPlugin
          });
          var reactEmoji = "\u269B";
          var warningEmoji = "\u26D4";
          var supportsUserTiming = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.clearMarks === "function" && typeof performance.measure === "function" && typeof performance.clearMeasures === "function";
          var currentFiber = null;
          var currentPhase = null;
          var currentPhaseFiber = null;
          var isCommitting = false;
          var hasScheduledUpdateInCurrentCommit = false;
          var hasScheduledUpdateInCurrentPhase = false;
          var commitCountInCurrentWorkLoop = 0;
          var effectCountInCurrentCommit = 0;
          var labelsInCurrentCommit = /* @__PURE__ */ new Set();
          var formatMarkName = function(markName) {
            return reactEmoji + " " + markName;
          };
          var formatLabel = function(label, warning2) {
            var prefix2 = warning2 ? warningEmoji + " " : reactEmoji + " ";
            var suffix = warning2 ? " Warning: " + warning2 : "";
            return "" + prefix2 + label + suffix;
          };
          var beginMark = function(markName) {
            performance.mark(formatMarkName(markName));
          };
          var clearMark = function(markName) {
            performance.clearMarks(formatMarkName(markName));
          };
          var endMark = function(label, markName, warning2) {
            var formattedMarkName = formatMarkName(markName);
            var formattedLabel = formatLabel(label, warning2);
            try {
              performance.measure(formattedLabel, formattedMarkName);
            } catch (err) {
            }
            performance.clearMarks(formattedMarkName);
            performance.clearMeasures(formattedLabel);
          };
          var getFiberMarkName = function(label, debugID) {
            return label + " (#" + debugID + ")";
          };
          var getFiberLabel = function(componentName, isMounted2, phase) {
            if (phase === null) {
              return componentName + " [" + (isMounted2 ? "update" : "mount") + "]";
            } else {
              return componentName + "." + phase;
            }
          };
          var beginFiberMark = function(fiber, phase) {
            var componentName = getComponentName(fiber.type) || "Unknown";
            var debugID = fiber._debugID;
            var isMounted2 = fiber.alternate !== null;
            var label = getFiberLabel(componentName, isMounted2, phase);
            if (isCommitting && labelsInCurrentCommit.has(label)) {
              return false;
            }
            labelsInCurrentCommit.add(label);
            var markName = getFiberMarkName(label, debugID);
            beginMark(markName);
            return true;
          };
          var clearFiberMark = function(fiber, phase) {
            var componentName = getComponentName(fiber.type) || "Unknown";
            var debugID = fiber._debugID;
            var isMounted2 = fiber.alternate !== null;
            var label = getFiberLabel(componentName, isMounted2, phase);
            var markName = getFiberMarkName(label, debugID);
            clearMark(markName);
          };
          var endFiberMark = function(fiber, phase, warning2) {
            var componentName = getComponentName(fiber.type) || "Unknown";
            var debugID = fiber._debugID;
            var isMounted2 = fiber.alternate !== null;
            var label = getFiberLabel(componentName, isMounted2, phase);
            var markName = getFiberMarkName(label, debugID);
            endMark(label, markName, warning2);
          };
          var shouldIgnoreFiber = function(fiber) {
            switch (fiber.tag) {
              case HostRoot:
              case HostComponent:
              case HostText:
              case HostPortal:
              case Fragment:
              case ContextProvider:
              case ContextConsumer:
              case Mode:
                return true;
              default:
                return false;
            }
          };
          var clearPendingPhaseMeasurement = function() {
            if (currentPhase !== null && currentPhaseFiber !== null) {
              clearFiberMark(currentPhaseFiber, currentPhase);
            }
            currentPhaseFiber = null;
            currentPhase = null;
            hasScheduledUpdateInCurrentPhase = false;
          };
          var pauseTimers = function() {
            var fiber = currentFiber;
            while (fiber) {
              if (fiber._debugIsCurrentlyTiming) {
                endFiberMark(fiber, null, null);
              }
              fiber = fiber.return;
            }
          };
          var resumeTimersRecursively = function(fiber) {
            if (fiber.return !== null) {
              resumeTimersRecursively(fiber.return);
            }
            if (fiber._debugIsCurrentlyTiming) {
              beginFiberMark(fiber, null);
            }
          };
          var resumeTimers = function() {
            if (currentFiber !== null) {
              resumeTimersRecursively(currentFiber);
            }
          };
          function recordEffect() {
            {
              effectCountInCurrentCommit++;
            }
          }
          function recordScheduleUpdate() {
            {
              if (isCommitting) {
                hasScheduledUpdateInCurrentCommit = true;
              }
              if (currentPhase !== null && currentPhase !== "componentWillMount" && currentPhase !== "componentWillReceiveProps") {
                hasScheduledUpdateInCurrentPhase = true;
              }
            }
          }
          function startWorkTimer(fiber) {
            {
              if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                return;
              }
              currentFiber = fiber;
              if (!beginFiberMark(fiber, null)) {
                return;
              }
              fiber._debugIsCurrentlyTiming = true;
            }
          }
          function cancelWorkTimer(fiber) {
            {
              if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                return;
              }
              fiber._debugIsCurrentlyTiming = false;
              clearFiberMark(fiber, null);
            }
          }
          function stopWorkTimer(fiber) {
            {
              if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                return;
              }
              currentFiber = fiber.return;
              if (!fiber._debugIsCurrentlyTiming) {
                return;
              }
              fiber._debugIsCurrentlyTiming = false;
              endFiberMark(fiber, null, null);
            }
          }
          function stopFailedWorkTimer(fiber) {
            {
              if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                return;
              }
              currentFiber = fiber.return;
              if (!fiber._debugIsCurrentlyTiming) {
                return;
              }
              fiber._debugIsCurrentlyTiming = false;
              var warning2 = fiber.tag === SuspenseComponent ? "Rendering was suspended" : "An error was thrown inside this error boundary";
              endFiberMark(fiber, null, warning2);
            }
          }
          function startPhaseTimer(fiber, phase) {
            {
              if (!supportsUserTiming) {
                return;
              }
              clearPendingPhaseMeasurement();
              if (!beginFiberMark(fiber, phase)) {
                return;
              }
              currentPhaseFiber = fiber;
              currentPhase = phase;
            }
          }
          function stopPhaseTimer() {
            {
              if (!supportsUserTiming) {
                return;
              }
              if (currentPhase !== null && currentPhaseFiber !== null) {
                var warning2 = hasScheduledUpdateInCurrentPhase ? "Scheduled a cascading update" : null;
                endFiberMark(currentPhaseFiber, currentPhase, warning2);
              }
              currentPhase = null;
              currentPhaseFiber = null;
            }
          }
          function startWorkLoopTimer(nextUnitOfWork) {
            {
              currentFiber = nextUnitOfWork;
              if (!supportsUserTiming) {
                return;
              }
              commitCountInCurrentWorkLoop = 0;
              beginMark("(React Tree Reconciliation)");
              resumeTimers();
            }
          }
          function stopWorkLoopTimer(interruptedBy2, didCompleteRoot) {
            {
              if (!supportsUserTiming) {
                return;
              }
              var warning2 = null;
              if (interruptedBy2 !== null) {
                if (interruptedBy2.tag === HostRoot) {
                  warning2 = "A top-level update interrupted the previous render";
                } else {
                  var componentName = getComponentName(interruptedBy2.type) || "Unknown";
                  warning2 = "An update to " + componentName + " interrupted the previous render";
                }
              } else if (commitCountInCurrentWorkLoop > 1) {
                warning2 = "There were cascading updates";
              }
              commitCountInCurrentWorkLoop = 0;
              var label = didCompleteRoot ? "(React Tree Reconciliation: Completed Root)" : "(React Tree Reconciliation: Yielded)";
              pauseTimers();
              endMark(label, "(React Tree Reconciliation)", warning2);
            }
          }
          function startCommitTimer() {
            {
              if (!supportsUserTiming) {
                return;
              }
              isCommitting = true;
              hasScheduledUpdateInCurrentCommit = false;
              labelsInCurrentCommit.clear();
              beginMark("(Committing Changes)");
            }
          }
          function stopCommitTimer() {
            {
              if (!supportsUserTiming) {
                return;
              }
              var warning2 = null;
              if (hasScheduledUpdateInCurrentCommit) {
                warning2 = "Lifecycle hook scheduled a cascading update";
              } else if (commitCountInCurrentWorkLoop > 0) {
                warning2 = "Caused by a cascading update in earlier commit";
              }
              hasScheduledUpdateInCurrentCommit = false;
              commitCountInCurrentWorkLoop++;
              isCommitting = false;
              labelsInCurrentCommit.clear();
              endMark("(Committing Changes)", "(Committing Changes)", warning2);
            }
          }
          function startCommitSnapshotEffectsTimer() {
            {
              if (!supportsUserTiming) {
                return;
              }
              effectCountInCurrentCommit = 0;
              beginMark("(Committing Snapshot Effects)");
            }
          }
          function stopCommitSnapshotEffectsTimer() {
            {
              if (!supportsUserTiming) {
                return;
              }
              var count = effectCountInCurrentCommit;
              effectCountInCurrentCommit = 0;
              endMark("(Committing Snapshot Effects: " + count + " Total)", "(Committing Snapshot Effects)", null);
            }
          }
          function startCommitHostEffectsTimer() {
            {
              if (!supportsUserTiming) {
                return;
              }
              effectCountInCurrentCommit = 0;
              beginMark("(Committing Host Effects)");
            }
          }
          function stopCommitHostEffectsTimer() {
            {
              if (!supportsUserTiming) {
                return;
              }
              var count = effectCountInCurrentCommit;
              effectCountInCurrentCommit = 0;
              endMark("(Committing Host Effects: " + count + " Total)", "(Committing Host Effects)", null);
            }
          }
          function startCommitLifeCyclesTimer() {
            {
              if (!supportsUserTiming) {
                return;
              }
              effectCountInCurrentCommit = 0;
              beginMark("(Calling Lifecycle Methods)");
            }
          }
          function stopCommitLifeCyclesTimer() {
            {
              if (!supportsUserTiming) {
                return;
              }
              var count = effectCountInCurrentCommit;
              effectCountInCurrentCommit = 0;
              endMark("(Calling Lifecycle Methods: " + count + " Total)", "(Calling Lifecycle Methods)", null);
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index2 = -1;
          function createCursor(defaultValue) {
            return {
              current: defaultValue
            };
          }
          function pop(cursor, fiber) {
            if (index2 < 0) {
              {
                error("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index2]) {
                error("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index2];
            valueStack[index2] = null;
            {
              fiberStack[index2] = null;
            }
            index2--;
          }
          function push(cursor, value, fiber) {
            index2++;
            valueStack[index2] = cursor.current;
            {
              fiberStack[index2] = fiber;
            }
            cursor.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component6, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component6)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context2 = {};
              for (var key in contextTypes) {
                context2[key] = unmaskedContext[key];
              }
              {
                var name = getComponentName(type) || "Unknown";
                checkPropTypes(contextTypes, context2, "context", name, getCurrentFiberStackInDev);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context2);
              }
              return context2;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context2, didChange) {
            {
              if (!(contextStackCursor.current === emptyContextObject)) {
                {
                  throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              push(contextStackCursor, context2, fiber);
              push(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentName(type) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext;
              startPhaseTimer(fiber, "getChildContext");
              childContext = instance.getChildContext();
              stopPhaseTimer();
              for (var contextKey2 in childContext) {
                if (!(contextKey2 in childContextTypes)) {
                  {
                    throw Error((getComponentName(type) || "Unknown") + '.getChildContext(): key "' + contextKey2 + '" is not defined in childContextTypes.');
                  }
                }
              }
              {
                var name = getComponentName(type) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name, getCurrentFiberStackInDev);
              }
              return _assign({}, parentContext, {}, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                {
                  throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push(contextStackCursor, mergedContext, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) {
                {
                  throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component6 = node.type;
                    if (isContextProvider(Component6)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              {
                {
                  throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
          }
          var LegacyRoot = 0;
          var BlockingRoot = 1;
          var ConcurrentRoot = 2;
          var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority, Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback, Scheduler_cancelCallback = Scheduler.unstable_cancelCallback, Scheduler_shouldYield = Scheduler.unstable_shouldYield, Scheduler_requestPaint = Scheduler.unstable_requestPaint, Scheduler_now = Scheduler.unstable_now, Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority, Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, Scheduler_NormalPriority = Scheduler.unstable_NormalPriority, Scheduler_LowPriority = Scheduler.unstable_LowPriority, Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
          {
            if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
              {
                throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling");
              }
            }
          }
          var fakeCallbackNode = {};
          var ImmediatePriority = 99;
          var UserBlockingPriority$1 = 98;
          var NormalPriority = 97;
          var LowPriority = 96;
          var IdlePriority = 95;
          var NoPriority = 90;
          var shouldYield = Scheduler_shouldYield;
          var requestPaint = Scheduler_requestPaint !== void 0 ? Scheduler_requestPaint : function() {
          };
          var syncQueue = null;
          var immediateQueueCallbackNode = null;
          var isFlushingSyncQueue = false;
          var initialTimeMs = Scheduler_now();
          var now = initialTimeMs < 1e4 ? Scheduler_now : function() {
            return Scheduler_now() - initialTimeMs;
          };
          function getCurrentPriorityLevel() {
            switch (Scheduler_getCurrentPriorityLevel()) {
              case Scheduler_ImmediatePriority:
                return ImmediatePriority;
              case Scheduler_UserBlockingPriority:
                return UserBlockingPriority$1;
              case Scheduler_NormalPriority:
                return NormalPriority;
              case Scheduler_LowPriority:
                return LowPriority;
              case Scheduler_IdlePriority:
                return IdlePriority;
              default: {
                {
                  throw Error("Unknown priority level.");
                }
              }
            }
          }
          function reactPriorityToSchedulerPriority(reactPriorityLevel) {
            switch (reactPriorityLevel) {
              case ImmediatePriority:
                return Scheduler_ImmediatePriority;
              case UserBlockingPriority$1:
                return Scheduler_UserBlockingPriority;
              case NormalPriority:
                return Scheduler_NormalPriority;
              case LowPriority:
                return Scheduler_LowPriority;
              case IdlePriority:
                return Scheduler_IdlePriority;
              default: {
                {
                  throw Error("Unknown priority level.");
                }
              }
            }
          }
          function runWithPriority$1(reactPriorityLevel, fn) {
            var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
            return Scheduler_runWithPriority(priorityLevel, fn);
          }
          function scheduleCallback(reactPriorityLevel, callback, options) {
            var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
            return Scheduler_scheduleCallback(priorityLevel, callback, options);
          }
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
              immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
            } else {
              syncQueue.push(callback);
            }
            return fakeCallbackNode;
          }
          function cancelCallback(callbackNode) {
            if (callbackNode !== fakeCallbackNode) {
              Scheduler_cancelCallback(callbackNode);
            }
          }
          function flushSyncCallbackQueue() {
            if (immediateQueueCallbackNode !== null) {
              var node = immediateQueueCallbackNode;
              immediateQueueCallbackNode = null;
              Scheduler_cancelCallback(node);
            }
            flushSyncCallbackQueueImpl();
          }
          function flushSyncCallbackQueueImpl() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i = 0;
              try {
                var _isSync = true;
                var queue = syncQueue;
                runWithPriority$1(ImmediatePriority, function() {
                  for (; i < queue.length; i++) {
                    var callback = queue[i];
                    do {
                      callback = callback(_isSync);
                    } while (callback !== null);
                  }
                });
                syncQueue = null;
              } catch (error2) {
                if (syncQueue !== null) {
                  syncQueue = syncQueue.slice(i + 1);
                }
                Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
                throw error2;
              } finally {
                isFlushingSyncQueue = false;
              }
            }
          }
          var NoMode = 0;
          var StrictMode = 1;
          var BlockingMode = 2;
          var ConcurrentMode = 4;
          var ProfileMode = 8;
          var MAX_SIGNED_31_BIT_INT2 = 1073741823;
          var NoWork = 0;
          var Never = 1;
          var Idle = 2;
          var ContinuousHydration = 3;
          var Sync = MAX_SIGNED_31_BIT_INT2;
          var Batched = Sync - 1;
          var UNIT_SIZE = 10;
          var MAGIC_NUMBER_OFFSET = Batched - 1;
          function msToExpirationTime(ms) {
            return MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | 0);
          }
          function expirationTimeToMs(expirationTime) {
            return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;
          }
          function ceiling(num, precision) {
            return ((num / precision | 0) + 1) * precision;
          }
          function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
            return MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
          }
          var LOW_PRIORITY_EXPIRATION = 5e3;
          var LOW_PRIORITY_BATCH_SIZE = 250;
          function computeAsyncExpiration(currentTime) {
            return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);
          }
          function computeSuspenseExpiration(currentTime, timeoutMs) {
            return computeExpirationBucket(currentTime, timeoutMs, LOW_PRIORITY_BATCH_SIZE);
          }
          var HIGH_PRIORITY_EXPIRATION = 500;
          var HIGH_PRIORITY_BATCH_SIZE = 100;
          function computeInteractiveExpiration(currentTime) {
            return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);
          }
          function inferPriorityFromExpirationTime(currentTime, expirationTime) {
            if (expirationTime === Sync) {
              return ImmediatePriority;
            }
            if (expirationTime === Never || expirationTime === Idle) {
              return IdlePriority;
            }
            var msUntil = expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime);
            if (msUntil <= 0) {
              return ImmediatePriority;
            }
            if (msUntil <= HIGH_PRIORITY_EXPIRATION + HIGH_PRIORITY_BATCH_SIZE) {
              return UserBlockingPriority$1;
            }
            if (msUntil <= LOW_PRIORITY_EXPIRATION + LOW_PRIORITY_BATCH_SIZE) {
              return NormalPriority;
            }
            return IdlePriority;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictMode) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set2) {
              var array = [];
              set2.forEach(function(value) {
                array.push(value);
              });
              return array.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn("componentWillMount has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn("componentWillUpdate has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                var firstComponentStack = getStackByFiberInDevAndProd(firstFiber);
                error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://fb.me/react-legacy-context%s", sortedNames, firstComponentStack);
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root3, update) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
              flushPassiveEffects();
              flushSync(function() {
                scheduleFibersWithFamiliesRecursively(root3.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root3, element) {
            {
              if (root3.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              syncUpdates(function() {
                updateContainer(element, root3, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                scheduleWork(fiber, Sync);
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root3, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root3.current, types, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          function resolveDefaultProps(Component6, baseProps) {
            if (Component6 && Component6.defaultProps) {
              var props = _assign({}, baseProps);
              var defaultProps2 = Component6.defaultProps;
              for (var propName in defaultProps2) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps2[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          function readLazyComponentType(lazyComponent) {
            initializeLazyComponentType(lazyComponent);
            if (lazyComponent._status !== Resolved) {
              throw lazyComponent._result;
            }
            return lazyComponent._result;
          }
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastContextWithAllBitsObserved = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastContextWithAllBitsObserved = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, nextValue) {
            var context2 = providerFiber.type._context;
            {
              push(valueCursor, context2._currentValue, providerFiber);
              context2._currentValue = nextValue;
              {
                if (context2._currentRenderer !== void 0 && context2._currentRenderer !== null && context2._currentRenderer !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context2._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            var context2 = providerFiber.type._context;
            {
              context2._currentValue = currentValue;
            }
          }
          function calculateChangedBits(context2, newValue, oldValue) {
            if (objectIs2(oldValue, newValue)) {
              return 0;
            } else {
              var changedBits = typeof context2._calculateChangedBits === "function" ? context2._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT2;
              {
                if ((changedBits & MAX_SIGNED_31_BIT_INT2) !== changedBits) {
                  error("calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s", changedBits);
                }
              }
              return changedBits | 0;
            }
          }
          function scheduleWorkOnParentPath(parent, renderExpirationTime2) {
            var node = parent;
            while (node !== null) {
              var alternate = node.alternate;
              if (node.childExpirationTime < renderExpirationTime2) {
                node.childExpirationTime = renderExpirationTime2;
                if (alternate !== null && alternate.childExpirationTime < renderExpirationTime2) {
                  alternate.childExpirationTime = renderExpirationTime2;
                }
              } else if (alternate !== null && alternate.childExpirationTime < renderExpirationTime2) {
                alternate.childExpirationTime = renderExpirationTime2;
              } else {
                break;
              }
              node = node.return;
            }
          }
          function propagateContextChange(workInProgress2, context2, changedBits, renderExpirationTime2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context2 && (dependency.observedBits & changedBits) !== 0) {
                    if (fiber.tag === ClassComponent) {
                      var update = createUpdate(renderExpirationTime2, null);
                      update.tag = ForceUpdate;
                      enqueueUpdate(fiber, update);
                    }
                    if (fiber.expirationTime < renderExpirationTime2) {
                      fiber.expirationTime = renderExpirationTime2;
                    }
                    var alternate = fiber.alternate;
                    if (alternate !== null && alternate.expirationTime < renderExpirationTime2) {
                      alternate.expirationTime = renderExpirationTime2;
                    }
                    scheduleWorkOnParentPath(fiber.return, renderExpirationTime2);
                    if (list.expirationTime < renderExpirationTime2) {
                      list.expirationTime = renderExpirationTime2;
                    }
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderExpirationTime2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastContextWithAllBitsObserved = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (dependencies.expirationTime >= renderExpirationTime2) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
          function readContext(context2, observedBits) {
            {
              if (isDisallowedContextReadInDEV) {
                error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            if (lastContextWithAllBitsObserved === context2)
              ;
            else if (observedBits === false || observedBits === 0)
              ;
            else {
              var resolvedObservedBits;
              if (typeof observedBits !== "number" || observedBits === MAX_SIGNED_31_BIT_INT2) {
                lastContextWithAllBitsObserved = context2;
                resolvedObservedBits = MAX_SIGNED_31_BIT_INT2;
              } else {
                resolvedObservedBits = observedBits;
              }
              var contextItem = {
                context: context2,
                observedBits: resolvedObservedBits,
                next: null
              };
              if (lastContextDependency === null) {
                if (!(currentlyRenderingFiber !== null)) {
                  {
                    throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                  }
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  expirationTime: NoWork,
                  firstContext: contextItem,
                  responders: null
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return context2._currentValue;
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              baseQueue: null,
              shared: {
                pending: null
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone = {
                baseState: currentQueue.baseState,
                baseQueue: currentQueue.baseQueue,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone;
            }
          }
          function createUpdate(expirationTime, suspenseConfig) {
            var update = {
              expirationTime,
              suspenseConfig,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            update.next = update;
            {
              update.priority = getCurrentPriorityLevel();
            }
            return update;
          }
          function enqueueUpdate(fiber, update) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            var pending = sharedQueue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            sharedQueue.pending = update;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
          }
          function enqueueCapturedUpdate(workInProgress2, update) {
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              cloneUpdateQueue(current2, workInProgress2);
            }
            var queue = workInProgress2.updateQueue;
            var last = queue.baseQueue;
            if (last === null) {
              queue.baseQueue = update.next = update;
              update.next = update;
            } else {
              update.next = last.next;
              last.next = update;
            }
          }
          function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
            switch (update.tag) {
              case ReplaceState: {
                var payload = update.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                    if (workInProgress2.mode & StrictMode) {
                      payload.call(instance, prevState, nextProps);
                    }
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.effectTag = workInProgress2.effectTag & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                    if (workInProgress2.mode & StrictMode) {
                      _payload.call(instance, prevState, nextProps);
                    }
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return _assign({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderExpirationTime2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var baseQueue = queue.baseQueue;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              baseQueue = pendingQueue;
              queue.shared.pending = null;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                if (currentQueue !== null) {
                  currentQueue.baseQueue = pendingQueue;
                }
              }
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = queue.baseState;
              var newExpirationTime = NoWork;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              if (first !== null) {
                var update = first;
                do {
                  var updateExpirationTime = update.expirationTime;
                  if (updateExpirationTime < renderExpirationTime2) {
                    var clone = {
                      expirationTime: update.expirationTime,
                      suspenseConfig: update.suspenseConfig,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    if (newBaseQueueLast === null) {
                      newBaseQueueFirst = newBaseQueueLast = clone;
                      newBaseState = newState;
                    } else {
                      newBaseQueueLast = newBaseQueueLast.next = clone;
                    }
                    if (updateExpirationTime > newExpirationTime) {
                      newExpirationTime = updateExpirationTime;
                    }
                  } else {
                    if (newBaseQueueLast !== null) {
                      var _clone = {
                        expirationTime: Sync,
                        suspenseConfig: update.suspenseConfig,
                        tag: update.tag,
                        payload: update.payload,
                        callback: update.callback,
                        next: null
                      };
                      newBaseQueueLast = newBaseQueueLast.next = _clone;
                    }
                    markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig);
                    newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                    var callback = update.callback;
                    if (callback !== null) {
                      workInProgress2.effectTag |= Callback;
                      var effects = queue.effects;
                      if (effects === null) {
                        queue.effects = [update];
                      } else {
                        effects.push(update);
                      }
                    }
                  }
                  update = update.next;
                  if (update === null || update === first) {
                    pendingQueue = queue.shared.pending;
                    if (pendingQueue === null) {
                      break;
                    } else {
                      update = baseQueue.next = pendingQueue.next;
                      pendingQueue.next = first;
                      queue.baseQueue = baseQueue = pendingQueue;
                      queue.shared.pending = null;
                    }
                  }
                } while (true);
              }
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              queue.baseState = newBaseState;
              queue.baseQueue = newBaseQueueLast;
              markUnprocessedUpdateTime(newExpirationTime);
              workInProgress2.expirationTime = newExpirationTime;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context2) {
            if (!(typeof callback === "function")) {
              {
                throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
              }
            }
            callback.call(context2);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i = 0; i < effects.length; i++) {
                var effect = effects[i];
                var callback = effect.callback;
                if (callback !== null) {
                  effect.callback = null;
                  callCallback(callback, instance);
                }
              }
            }
          }
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          function requestCurrentSuspenseConfig() {
            return ReactCurrentBatchConfig.suspense;
          }
          var fakeInternalInstance = {};
          var isArray2 = Array.isArray;
          var emptyRefsObject = new React109.Component().refs;
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentName(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                {
                  {
                    throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
                  }
                }
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            {
              if (workInProgress2.mode & StrictMode) {
                getDerivedStateFromProps(nextProps, prevState);
              }
            }
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : _assign({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.expirationTime === NoWork) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get4(inst);
              var currentTime = requestCurrentTimeForUpdate();
              var suspenseConfig = requestCurrentSuspenseConfig();
              var expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);
              var update = createUpdate(expirationTime, suspenseConfig);
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update.callback = callback;
              }
              enqueueUpdate(fiber, update);
              scheduleWork(fiber, expirationTime);
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get4(inst);
              var currentTime = requestCurrentTimeForUpdate();
              var suspenseConfig = requestCurrentSuspenseConfig();
              var expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);
              var update = createUpdate(expirationTime, suspenseConfig);
              update.tag = ReplaceState;
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update.callback = callback;
              }
              enqueueUpdate(fiber, update);
              scheduleWork(fiber, expirationTime);
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get4(inst);
              var currentTime = requestCurrentTimeForUpdate();
              var suspenseConfig = requestCurrentSuspenseConfig();
              var expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);
              var update = createUpdate(expirationTime, suspenseConfig);
              update.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update.callback = callback;
              }
              enqueueUpdate(fiber, update);
              scheduleWork(fiber, expirationTime);
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              {
                if (workInProgress2.mode & StrictMode) {
                  instance.shouldComponentUpdate(newProps, newState, nextContext);
                }
              }
              startPhaseTimer(workInProgress2, "shouldComponentUpdate");
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              stopPhaseTimer();
              {
                if (shouldUpdate === void 0) {
                  error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name = getComponentName(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
                } else {
                  error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
              }
              if (instance.propTypes) {
                error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
              }
              if (instance.contextType) {
                error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
              }
              {
                if (instance.contextTypes) {
                  error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
              }
              if (instance.defaultProps) {
                error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray2(_state))) {
                error("%s.state: must be set to an object or null", name);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context2 = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context2 = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context2 = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            {
              if (workInProgress2.mode & StrictMode) {
                new ctor(props, context2);
              }
            }
            var instance = new ctor(props, context2);
            var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                var componentName = getComponentName(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentName(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context2);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            startPhaseTimer(workInProgress2, "componentWillMount");
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            stopPhaseTimer();
            if (oldState !== instance.state) {
              {
                error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentName(workInProgress2.type) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            startPhaseTimer(workInProgress2, "componentWillReceiveProps");
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            stopPhaseTimer();
            if (instance.state !== oldState) {
              {
                var componentName = getComponentName(workInProgress2.type) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderExpirationTime2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = emptyRefsObject;
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentName(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            processUpdateQueue(workInProgress2, newProps, instance, renderExpirationTime2);
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderExpirationTime2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              workInProgress2.effectTag |= Update;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderExpirationTime2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderExpirationTime2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                workInProgress2.effectTag |= Update;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                startPhaseTimer(workInProgress2, "componentWillMount");
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
                stopPhaseTimer();
              }
              if (typeof instance.componentDidMount === "function") {
                workInProgress2.effectTag |= Update;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                workInProgress2.effectTag |= Update;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderExpirationTime2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var oldProps = workInProgress2.memoizedProps;
            instance.props = workInProgress2.type === workInProgress2.elementType ? oldProps : resolveDefaultProps(workInProgress2.type, oldProps);
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderExpirationTime2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidUpdate === "function") {
                if (oldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.effectTag |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (oldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.effectTag |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                startPhaseTimer(workInProgress2, "componentWillUpdate");
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
                stopPhaseTimer();
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.effectTag |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.effectTag |= Snapshot;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (oldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.effectTag |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (oldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.effectTag |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (!(typeof child._store === "object")) {
                {
                  throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              child._store.validated = true;
              var currentComponentErrorInfo = 'Each child in a list should have a unique "key" prop. See https://fb.me/react-warning-keys for more information.' + getCurrentFiberStackInDev();
              if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
              error('Each child in a list should have a unique "key" prop. See https://fb.me/react-warning-keys for more information.');
            };
          }
          var isArray$1 = Array.isArray;
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                  var componentName = getComponentName(returnFiber.type) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref%s', mixedRef, getStackByFiberInDevAndProd(returnFiber));
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (!(ownerFiber.tag === ClassComponent)) {
                    {
                      throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref");
                    }
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  {
                    throw Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref = function(value) {
                  var refs = inst.refs;
                  if (refs === emptyRefsObject) {
                    refs = inst.refs = {};
                  }
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref._stringRef = stringRef;
                return ref;
              } else {
                if (!(typeof mixedRef === "string")) {
                  {
                    throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                  }
                }
                if (!element._owner) {
                  {
                    throw Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information.");
                  }
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            if (returnFiber.type !== "textarea") {
              var addendum = "";
              {
                addendum = " If you meant to render a collection of children, use an array instead." + getCurrentFiberStackInDev();
              }
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild) + ")." + addendum);
                }
              }
            }
          }
          function warnOnFunctionType() {
            {
              var currentComponentErrorInfo = "Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it." + getCurrentFiberStackInDev();
              if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var last = returnFiber.lastEffect;
              if (last !== null) {
                last.nextEffect = childToDelete;
                returnFiber.lastEffect = childToDelete;
              } else {
                returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
              }
              childToDelete.nextEffect = null;
              childToDelete.effectTag = Deletion;
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone = createWorkInProgress(fiber, pendingProps);
              clone.index = 0;
              clone.sibling = null;
              return clone;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.effectTag = Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.effectTag = Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.effectTag = Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, expirationTime) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, expirationTime) {
              if (current2 !== null) {
                if (current2.elementType === element.type || isCompatibleFamilyForHotReloading(current2, element)) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, expirationTime);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal2, expirationTime) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal2.containerInfo || current2.stateNode.implementation !== portal2.implementation) {
                var created = createFiberFromPortal(portal2, returnFiber.mode, expirationTime);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal2.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, expirationTime, key) {
              if (current2 === null || current2.tag !== Fragment) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, expirationTime) {
              if (typeof newChild === "string" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, expirationTime);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType();
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      if (newChild.type === REACT_FRAGMENT_TYPE) {
                        return updateFragment2(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                      }
                      return updateElement(returnFiber, oldFiber, newChild, expirationTime);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
                    } else {
                      return null;
                    }
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, expirationTime, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType();
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
              if (typeof newChild === "string" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, expirationTime);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    if (newChild.type === REACT_FRAGMENT_TYPE) {
                      return updateFragment2(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
                    }
                    return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, expirationTime, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType();
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
              {
                var knownKeys = null;
                for (var i = 0; i < newChildren.length; i++) {
                  var child = newChildren[i];
                  knownKeys = warnOnInvalidKey(child, knownKeys);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (!(typeof iteratorFn === "function")) {
                {
                  throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              {
                if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error("Using Maps as children is unsupported and will likely yield unexpected results. Convert it to a sequence/iterable of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (!(newChildren != null)) {
                {
                  throw Error("An iterable object provided no iterator.");
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  switch (child.tag) {
                    case Fragment: {
                      if (element.type === REACT_FRAGMENT_TYPE) {
                        deleteRemainingChildren(returnFiber, child.sibling);
                        var existing = useFiber(child, element.props.children);
                        existing.return = returnFiber;
                        {
                          existing._debugSource = element._source;
                          existing._debugOwner = element._owner;
                        }
                        return existing;
                      }
                      break;
                    }
                    case Block:
                    default: {
                      if (child.elementType === element.type || isCompatibleFamilyForHotReloading(child, element)) {
                        deleteRemainingChildren(returnFiber, child.sibling);
                        var _existing3 = useFiber(child, element.props);
                        _existing3.ref = coerceRef(returnFiber, child, element);
                        _existing3.return = returnFiber;
                        {
                          _existing3._debugSource = element._source;
                          _existing3._debugOwner = element._owner;
                        }
                        return _existing3;
                      }
                      break;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal2, expirationTime) {
              var key = portal2.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal2.containerInfo && child.stateNode.implementation === portal2.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal2.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal2, returnFiber.mode, expirationTime);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, expirationTime) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              var isObject2 = typeof newChild === "object" && newChild !== null;
              if (isObject2) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
                }
              }
              if (typeof newChild === "string" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, expirationTime));
              }
              if (isArray$1(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
              }
              if (isObject2) {
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType();
                }
              }
              if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
                switch (returnFiber.tag) {
                  case ClassComponent: {
                    {
                      var instance = returnFiber.stateNode;
                      if (instance.render._isMockFunction) {
                        break;
                      }
                    }
                  }
                  case FunctionComponent: {
                    var Component6 = returnFiber.type;
                    {
                      {
                        throw Error((Component6.displayName || Component6.name || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
                      }
                    }
                  }
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (!(current2 === null || workInProgress2.child === current2.child)) {
              {
                throw Error("Resuming work not yet implemented.");
              }
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, renderExpirationTime2) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, renderExpirationTime2);
              child = child.sibling;
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c) {
            if (!(c !== NO_CONTEXT)) {
              {
                throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return c;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance, fiber);
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context2 = requiredContext(contextStackCursor$1.current);
            return context2;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context2 = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context2, fiber.type);
            if (context2 === nextContext) {
              return;
            }
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            if (props.fallback === void 0) {
              return false;
            }
            if (props.unstable_avoidThisFallback !== true) {
              return true;
            }
            if (hasInvisibleParent) {
              return false;
            }
            return true;
          }
          function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  var dehydrated = state.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.effectTag & DidCapture) !== NoEffect;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          function createDeprecatedResponderListener(responder, props) {
            var eventResponderListener = {
              responder,
              props
            };
            {
              Object.freeze(eventResponderListener);
            }
            return eventResponderListener;
          }
          var HasEffect = 1;
          var Layout = 2;
          var Passive$1 = 4;
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          {
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderExpirationTime = NoWork;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !Array.isArray(deps)) {
                error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentName(currentlyRenderingFiber$1.type);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                    var oldHookName = hookTypesDev[i];
                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            {
              {
                throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs2(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component6, props, secondArg, nextRenderExpirationTime) {
            renderExpirationTime = nextRenderExpirationTime;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.expirationTime = NoWork;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children2 = Component6(props, secondArg);
            if (workInProgress2.expirationTime === renderExpirationTime) {
              var numberOfReRenders = 0;
              do {
                workInProgress2.expirationTime = NoWork;
                if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
                  {
                    throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                  }
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher.current = HooksDispatcherOnRerenderInDEV;
                children2 = Component6(props, secondArg);
              } while (workInProgress2.expirationTime === renderExpirationTime);
            }
            ReactCurrentDispatcher.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderExpirationTime = NoWork;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
            }
            didScheduleRenderPhaseUpdate = false;
            if (!!didRenderTooFewHooks) {
              {
                throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
              }
            }
            return children2;
          }
          function bailoutHooks(current2, workInProgress2, expirationTime) {
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.effectTag &= ~(Passive | Update);
            if (current2.expirationTime <= expirationTime) {
              current2.expirationTime = NoWork;
            }
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
            }
            renderExpirationTime = NoWork;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (!(nextCurrentHook !== null)) {
                {
                  throw Error("Rendered more hooks than during the previous render.");
                }
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null
            };
          }
          function basicStateReducer(state, action) {
            return typeof action === "function" ? action(state) : action;
          }
          function mountReducer(reducer, initialArg, init) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init !== void 0) {
              initialState = init(initialArg);
            } else {
              initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = hook.queue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState
            };
            var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (!(queue !== null)) {
              {
                throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
              }
            }
            queue.lastRenderedReducer = reducer;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update = first;
              do {
                var updateExpirationTime = update.expirationTime;
                if (updateExpirationTime < renderExpirationTime) {
                  var clone = {
                    expirationTime: update.expirationTime,
                    suspenseConfig: update.suspenseConfig,
                    action: update.action,
                    eagerReducer: update.eagerReducer,
                    eagerState: update.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone;
                  }
                  if (updateExpirationTime > currentlyRenderingFiber$1.expirationTime) {
                    currentlyRenderingFiber$1.expirationTime = updateExpirationTime;
                    markUnprocessedUpdateTime(updateExpirationTime);
                  }
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      expirationTime: Sync,
                      suspenseConfig: update.suspenseConfig,
                      action: update.action,
                      eagerReducer: update.eagerReducer,
                      eagerState: update.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig);
                  if (update.eagerReducer === reducer) {
                    newState = update.eagerState;
                  } else {
                    var action = update.action;
                    newState = reducer(newState, action);
                  }
                }
                update = update.next;
              } while (update !== null && update !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs2(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var dispatch = queue.dispatch;
            return [hook.memoizedState, dispatch];
          }
          function rerenderReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (!(queue !== null)) {
              {
                throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
              }
            }
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                newState = reducer(newState, action);
                update = update.next;
              } while (update !== firstRenderPhaseUpdate);
              if (!objectIs2(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function mountState(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === "function") {
              initialState = initialState();
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = hook.queue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState
            };
            var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateState(initialState) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create, destroy, deps) {
            var effect = {
              tag,
              create,
              destroy,
              deps,
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect.next = effect;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
              }
            }
            return effect;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            hook.memoizedState = ref;
            return ref;
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
            hook.memoizedState = pushEffect(HasEffect | hookEffectTag, create, void 0, nextDeps);
          }
          function updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  pushEffect(hookEffectTag, create, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
            hook.memoizedState = pushEffect(HasEffect | hookEffectTag, create, destroy, nextDeps);
          }
          function mountEffect(create, deps) {
            {
              if (typeof jest !== "undefined") {
                warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
              }
            }
            return mountEffectImpl(Update | Passive, Passive$1, create, deps);
          }
          function updateEffect(create, deps) {
            {
              if (typeof jest !== "undefined") {
                warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
              }
            }
            return updateEffectImpl(Update | Passive, Passive$1, create, deps);
          }
          function mountLayoutEffect(create, deps) {
            return mountEffectImpl(Update, Layout, create, deps);
          }
          function updateLayoutEffect(create, deps) {
            return updateEffectImpl(Update, Layout, create, deps);
          }
          function imperativeHandleEffect(create, ref) {
            if (typeof ref === "function") {
              var refCallback = ref;
              var _inst = create();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref !== null && ref !== void 0) {
              var refObject = ref;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function updateImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value, config) {
            var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];
            mountEffect(function() {
              var previousConfig = ReactCurrentBatchConfig$1.suspense;
              ReactCurrentBatchConfig$1.suspense = config === void 0 ? null : config;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.suspense = previousConfig;
              }
            }, [value, config]);
            return prevValue;
          }
          function updateDeferredValue(value, config) {
            var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];
            updateEffect(function() {
              var previousConfig = ReactCurrentBatchConfig$1.suspense;
              ReactCurrentBatchConfig$1.suspense = config === void 0 ? null : config;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.suspense = previousConfig;
              }
            }, [value, config]);
            return prevValue;
          }
          function rerenderDeferredValue(value, config) {
            var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];
            updateEffect(function() {
              var previousConfig = ReactCurrentBatchConfig$1.suspense;
              ReactCurrentBatchConfig$1.suspense = config === void 0 ? null : config;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.suspense = previousConfig;
              }
            }, [value, config]);
            return prevValue;
          }
          function startTransition(setPending, config, callback) {
            var priorityLevel = getCurrentPriorityLevel();
            runWithPriority$1(priorityLevel < UserBlockingPriority$1 ? UserBlockingPriority$1 : priorityLevel, function() {
              setPending(true);
            });
            runWithPriority$1(priorityLevel > NormalPriority ? NormalPriority : priorityLevel, function() {
              var previousConfig = ReactCurrentBatchConfig$1.suspense;
              ReactCurrentBatchConfig$1.suspense = config === void 0 ? null : config;
              try {
                setPending(false);
                callback();
              } finally {
                ReactCurrentBatchConfig$1.suspense = previousConfig;
              }
            });
          }
          function mountTransition(config) {
            var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1];
            var start = mountCallback(startTransition.bind(null, setPending, config), [setPending, config]);
            return [start, isPending];
          }
          function updateTransition(config) {
            var _updateState2 = updateState(), isPending = _updateState2[0], setPending = _updateState2[1];
            var start = updateCallback(startTransition.bind(null, setPending, config), [setPending, config]);
            return [start, isPending];
          }
          function rerenderTransition(config) {
            var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0], setPending = _rerenderState2[1];
            var start = updateCallback(startTransition.bind(null, setPending, config), [setPending, config]);
            return [start, isPending];
          }
          function dispatchAction(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var currentTime = requestCurrentTimeForUpdate();
            var suspenseConfig = requestCurrentSuspenseConfig();
            var expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);
            var update = {
              expirationTime,
              suspenseConfig,
              action,
              eagerReducer: null,
              eagerState: null,
              next: null
            };
            {
              update.priority = getCurrentPriorityLevel();
            }
            var pending = queue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            queue.pending = update;
            var alternate = fiber.alternate;
            if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
              didScheduleRenderPhaseUpdate = true;
              update.expirationTime = renderExpirationTime;
              currentlyRenderingFiber$1.expirationTime = renderExpirationTime;
            } else {
              if (fiber.expirationTime === NoWork && (alternate === null || alternate.expirationTime === NoWork)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher.current;
                    ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action);
                    update.eagerReducer = lastRenderedReducer;
                    update.eagerState = eagerState;
                    if (objectIs2(eagerState, currentState)) {
                      return;
                    }
                  } catch (error2) {
                  } finally {
                    {
                      ReactCurrentDispatcher.current = prevDispatcher;
                    }
                  }
                }
              }
              {
                if (typeof jest !== "undefined") {
                  warnIfNotScopedWithMatchingAct(fiber);
                  warnIfNotCurrentlyActingUpdatesInDev(fiber);
                }
              }
              scheduleWork(fiber, expirationTime);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useResponder: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://fb.me/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context2, observedBits) {
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useResponder: function(responder, props) {
                currentHookNameInDev = "useResponder";
                mountHookTypesDev();
                return createDeprecatedResponderListener(responder, props);
              },
              useDeferredValue: function(value, config) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value, config);
              },
              useTransition: function(config) {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition(config);
              }
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context2, observedBits) {
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useResponder: function(responder, props) {
                currentHookNameInDev = "useResponder";
                updateHookTypesDev();
                return createDeprecatedResponderListener(responder, props);
              },
              useDeferredValue: function(value, config) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value, config);
              },
              useTransition: function(config) {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition(config);
              }
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context2, observedBits) {
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useResponder: function(responder, props) {
                currentHookNameInDev = "useResponder";
                updateHookTypesDev();
                return createDeprecatedResponderListener(responder, props);
              },
              useDeferredValue: function(value, config) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value, config);
              },
              useTransition: function(config) {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition(config);
              }
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context2, observedBits) {
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useResponder: function(responder, props) {
                currentHookNameInDev = "useResponder";
                updateHookTypesDev();
                return createDeprecatedResponderListener(responder, props);
              },
              useDeferredValue: function(value, config) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value, config);
              },
              useTransition: function(config) {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition(config);
              }
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context2, observedBits) {
                warnInvalidContextAccess();
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useResponder: function(responder, props) {
                currentHookNameInDev = "useResponder";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return createDeprecatedResponderListener(responder, props);
              },
              useDeferredValue: function(value, config) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value, config);
              },
              useTransition: function(config) {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition(config);
              }
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context2, observedBits) {
                warnInvalidContextAccess();
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useResponder: function(responder, props) {
                currentHookNameInDev = "useResponder";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return createDeprecatedResponderListener(responder, props);
              },
              useDeferredValue: function(value, config) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value, config);
              },
              useTransition: function(config) {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition(config);
              }
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context2, observedBits) {
                warnInvalidContextAccess();
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher.current;
                ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useResponder: function(responder, props) {
                currentHookNameInDev = "useResponder";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return createDeprecatedResponderListener(responder, props);
              },
              useDeferredValue: function(value, config) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value, config);
              },
              useTransition: function(config) {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition(config);
              }
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var profilerStartTime = -1;
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChild(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            return true;
          }
          function deleteHydratableInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot:
                  didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
                  break;
                case HostComponent:
                  didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
                  break;
              }
            }
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            childToDelete.effectTag = Deletion;
            if (returnFiber.lastEffect !== null) {
              returnFiber.lastEffect.nextEffect = childToDelete;
              returnFiber.lastEffect = childToDelete;
            } else {
              returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.effectTag = fiber.effectTag & ~Hydrating | Placement;
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableContainerInstance(parentContainer, type);
                      break;
                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableContainerTextInstance(parentContainer, text);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent:
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
                      break;
                    case HostText:
                      var _text = fiber.pendingProps;
                      didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                      break;
                    case SuspenseComponent:
                      didNotFindHydratableSuspenseInstance(parentType, parentProps);
                      break;
                  }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  return true;
                }
                return false;
              }
              case HostText: {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                return false;
              }
              default:
                return false;
            }
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
            }
            hydrationParentFiber = fiber;
            nextHydratableInstance = getFirstHydratableChild(nextInstance);
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            {
              if (shouldUpdate) {
                var returnFiber = hydrationParentFiber;
                if (returnFiber !== null) {
                  switch (returnFiber.tag) {
                    case HostRoot: {
                      var parentContainer = returnFiber.stateNode.containerInfo;
                      didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                      break;
                    }
                    case HostComponent: {
                      var parentType = returnFiber.type;
                      var parentProps = returnFiber.memoizedProps;
                      var parentInstance = returnFiber.stateNode;
                      didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                      break;
                    }
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              {
                throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            var type = fiber.type;
            if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
              var nextInstance = nextHydratableInstance;
              while (nextInstance) {
                deleteHydratableInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderExpirationTime2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderExpirationTime2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderExpirationTime2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderExpirationTime2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderExpirationTime2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderExpirationTime2);
          }
          function updateForwardRef(current2, workInProgress2, Component6, nextProps, renderExpirationTime2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component6.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component6), getCurrentFiberStackInDev);
                }
              }
            }
            var render2 = Component6.render;
            var ref = workInProgress2.ref;
            var nextChildren;
            prepareToReadContext(workInProgress2, renderExpirationTime2);
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderExpirationTime2);
              if (workInProgress2.mode & StrictMode) {
                if (workInProgress2.memoizedState !== null) {
                  nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderExpirationTime2);
                }
              }
              setIsRendering(false);
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderExpirationTime2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderExpirationTime2);
            }
            workInProgress2.effectTag |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderExpirationTime2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component6, nextProps, updateExpirationTime, renderExpirationTime2) {
            if (current2 === null) {
              var type = Component6.type;
              if (isSimpleFunctionComponent(type) && Component6.compare === null && Component6.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, updateExpirationTime, renderExpirationTime2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(type), getCurrentFiberStackInDev);
                }
              }
              var child = createFiberFromTypeAndProps(Component6.type, null, nextProps, null, workInProgress2.mode, renderExpirationTime2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component6.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(_innerPropTypes, nextProps, "prop", getComponentName(_type), getCurrentFiberStackInDev);
              }
            }
            var currentChild = current2.child;
            if (updateExpirationTime < renderExpirationTime2) {
              var prevProps = currentChild.memoizedProps;
              var compare = Component6.compare;
              compare = compare !== null ? compare : shallowEqual;
              if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderExpirationTime2);
              }
            }
            workInProgress2.effectTag |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component6, nextProps, updateExpirationTime, renderExpirationTime2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  outerMemoType = refineResolvedLazyComponent(outerMemoType);
                }
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(outerPropTypes, nextProps, "prop", getComponentName(outerMemoType), getCurrentFiberStackInDev);
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                if (updateExpirationTime < renderExpirationTime2) {
                  workInProgress2.expirationTime = current2.expirationTime;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderExpirationTime2);
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component6, nextProps, renderExpirationTime2);
          }
          function updateFragment(current2, workInProgress2, renderExpirationTime2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderExpirationTime2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderExpirationTime2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderExpirationTime2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderExpirationTime2) {
            {
              workInProgress2.effectTag |= Update;
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderExpirationTime2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
              workInProgress2.effectTag |= Ref;
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component6, nextProps, renderExpirationTime2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component6.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component6), getCurrentFiberStackInDev);
                }
              }
            }
            var context2;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component6, true);
              context2 = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            prepareToReadContext(workInProgress2, renderExpirationTime2);
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component6, nextProps, context2, renderExpirationTime2);
              if (workInProgress2.mode & StrictMode) {
                if (workInProgress2.memoizedState !== null) {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component6, nextProps, context2, renderExpirationTime2);
                }
              }
              setIsRendering(false);
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderExpirationTime2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderExpirationTime2);
            }
            workInProgress2.effectTag |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderExpirationTime2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component6, nextProps, renderExpirationTime2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component6.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component6), getCurrentFiberStackInDev);
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component6)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderExpirationTime2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.effectTag |= Placement;
              }
              constructClassInstance(workInProgress2, Component6, nextProps);
              mountClassInstance(workInProgress2, Component6, nextProps, renderExpirationTime2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component6, nextProps, renderExpirationTime2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component6, nextProps, renderExpirationTime2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component6, shouldUpdate, hasContext, renderExpirationTime2);
            {
              var inst = workInProgress2.stateNode;
              if (inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentName(workInProgress2.type) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component6, shouldUpdate, hasContext, renderExpirationTime2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.effectTag & DidCapture) !== NoEffect;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component6, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderExpirationTime2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component6.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictMode) {
                  instance.render();
                }
                setIsRendering(false);
              }
            }
            workInProgress2.effectTag |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderExpirationTime2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderExpirationTime2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component6, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root3 = workInProgress2.stateNode;
            if (root3.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root3.pendingContext, root3.pendingContext !== root3.context);
            } else if (root3.context) {
              pushTopLevelContextObject(workInProgress2, root3.context, false);
            }
            pushHostContainer(workInProgress2, root3.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderExpirationTime2) {
            pushHostRootContext(workInProgress2);
            var updateQueue = workInProgress2.updateQueue;
            if (!(current2 !== null && updateQueue !== null)) {
              {
                throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState !== null ? prevState.element : null;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderExpirationTime2);
            var nextState = workInProgress2.memoizedState;
            var nextChildren = nextState.element;
            if (nextChildren === prevChildren) {
              resetHydrationState();
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderExpirationTime2);
            }
            var root3 = workInProgress2.stateNode;
            if (root3.hydrate && enterHydrationState(workInProgress2)) {
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderExpirationTime2);
              workInProgress2.child = child;
              var node = child;
              while (node) {
                node.effectTag = node.effectTag & ~Placement | Hydrating;
                node = node.sibling;
              }
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderExpirationTime2);
              resetHydrationState();
            }
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderExpirationTime2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.effectTag |= ContentReset;
            }
            markRef(current2, workInProgress2);
            if (workInProgress2.mode & ConcurrentMode && renderExpirationTime2 !== Never && shouldDeprioritizeSubtree(type, nextProps)) {
              {
                markSpawnedWork(Never);
              }
              workInProgress2.expirationTime = workInProgress2.childExpirationTime = Never;
              return null;
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderExpirationTime2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, updateExpirationTime, renderExpirationTime2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.effectTag |= Placement;
            }
            var props = workInProgress2.pendingProps;
            cancelWorkTimer(workInProgress2);
            var Component6 = readLazyComponentType(elementType);
            workInProgress2.type = Component6;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component6);
            startWorkTimer(workInProgress2);
            var resolvedProps = resolveDefaultProps(Component6, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component6);
                  workInProgress2.type = Component6 = resolveFunctionForHotReloading(Component6);
                }
                child = updateFunctionComponent(null, workInProgress2, Component6, resolvedProps, renderExpirationTime2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component6 = resolveClassForHotReloading(Component6);
                }
                child = updateClassComponent(null, workInProgress2, Component6, resolvedProps, renderExpirationTime2);
                return child;
              }
              case ForwardRef: {
                {
                  workInProgress2.type = Component6 = resolveForwardRefForHotReloading(Component6);
                }
                child = updateForwardRef(null, workInProgress2, Component6, resolvedProps, renderExpirationTime2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component6.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(outerPropTypes, resolvedProps, "prop", getComponentName(Component6), getCurrentFiberStackInDev);
                    }
                  }
                }
                child = updateMemoComponent(null, workInProgress2, Component6, resolveDefaultProps(Component6.type, resolvedProps), updateExpirationTime, renderExpirationTime2);
                return child;
              }
            }
            var hint = "";
            {
              if (Component6 !== null && typeof Component6 === "object" && Component6.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            {
              {
                throw Error("Element type is invalid. Received a promise that resolves to: " + Component6 + ". Lazy element type must resolve to a class or function." + hint);
              }
            }
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component6, nextProps, renderExpirationTime2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.effectTag |= Placement;
            }
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component6)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderExpirationTime2);
            constructClassInstance(workInProgress2, Component6, nextProps);
            mountClassInstance(workInProgress2, Component6, nextProps, renderExpirationTime2);
            return finishClassComponent(null, workInProgress2, Component6, true, hasContext, renderExpirationTime2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component6, renderExpirationTime2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.effectTag |= Placement;
            }
            var props = workInProgress2.pendingProps;
            var context2;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component6, false);
              context2 = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderExpirationTime2);
            var value;
            {
              if (Component6.prototype && typeof Component6.prototype.render === "function") {
                var componentName = getComponentName(Component6) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component6, props, context2, renderExpirationTime2);
              setIsRendering(false);
            }
            workInProgress2.effectTag |= PerformedWork;
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              {
                var _componentName = getComponentName(Component6) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component6)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              var getDerivedStateFromProps = Component6.getDerivedStateFromProps;
              if (typeof getDerivedStateFromProps === "function") {
                applyDerivedStateFromProps(workInProgress2, Component6, getDerivedStateFromProps, props);
              }
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component6, props, renderExpirationTime2);
              return finishClassComponent(null, workInProgress2, Component6, true, hasContext, renderExpirationTime2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictMode) {
                  if (workInProgress2.memoizedState !== null) {
                    value = renderWithHooks(null, workInProgress2, Component6, props, context2, renderExpirationTime2);
                  }
                }
              }
              reconcileChildren(null, workInProgress2, value, renderExpirationTime2);
              {
                validateFunctionComponentInDev(workInProgress2, Component6);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component6) {
            {
              if (Component6) {
                if (Component6.childContextTypes) {
                  error("%s(...): childContextTypes cannot be defined on a function component.", Component6.displayName || Component6.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || workInProgress2._debugID || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (typeof Component6.getDerivedStateFromProps === "function") {
                var _componentName2 = getComponentName(Component6) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]) {
                  error("%s: Function components do not support getDerivedStateFromProps.", _componentName2);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true;
                }
              }
              if (typeof Component6.contextType === "object" && Component6.contextType !== null) {
                var _componentName3 = getComponentName(Component6) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName3]) {
                  error("%s: Function components do not support contextType.", _componentName3);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            retryTime: NoWork
          };
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2) {
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback) && (current2 === null || current2.memoizedState !== null);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderExpirationTime2) {
            var mode = workInProgress2.mode;
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.effectTag |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var nextDidTimeout = false;
            var didSuspend = (workInProgress2.effectTag & DidCapture) !== NoEffect;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              nextDidTimeout = true;
              workInProgress2.effectTag &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                if (nextProps.fallback !== void 0 && nextProps.unstable_avoidThisFallback !== true) {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              if (nextProps.fallback !== void 0) {
                tryToClaimNextHydratableInstance(workInProgress2);
              }
              if (nextDidTimeout) {
                var nextFallbackChildren = nextProps.fallback;
                var primaryChildFragment = createFiberFromFragment(null, mode, NoWork, null);
                primaryChildFragment.return = workInProgress2;
                if ((workInProgress2.mode & BlockingMode) === NoMode) {
                  var progressedState = workInProgress2.memoizedState;
                  var progressedPrimaryChild = progressedState !== null ? workInProgress2.child.child : workInProgress2.child;
                  primaryChildFragment.child = progressedPrimaryChild;
                  var progressedChild = progressedPrimaryChild;
                  while (progressedChild !== null) {
                    progressedChild.return = primaryChildFragment;
                    progressedChild = progressedChild.sibling;
                  }
                }
                var fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime2, null);
                fallbackChildFragment.return = workInProgress2;
                primaryChildFragment.sibling = fallbackChildFragment;
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                workInProgress2.child = primaryChildFragment;
                return fallbackChildFragment;
              } else {
                var nextPrimaryChildren = nextProps.children;
                workInProgress2.memoizedState = null;
                return workInProgress2.child = mountChildFibers(workInProgress2, null, nextPrimaryChildren, renderExpirationTime2);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var currentPrimaryChildFragment = current2.child;
                var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
                if (nextDidTimeout) {
                  var _nextFallbackChildren2 = nextProps.fallback;
                  var _primaryChildFragment2 = createWorkInProgress(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps);
                  _primaryChildFragment2.return = workInProgress2;
                  if ((workInProgress2.mode & BlockingMode) === NoMode) {
                    var _progressedState = workInProgress2.memoizedState;
                    var _progressedPrimaryChild = _progressedState !== null ? workInProgress2.child.child : workInProgress2.child;
                    if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
                      _primaryChildFragment2.child = _progressedPrimaryChild;
                      var _progressedChild2 = _progressedPrimaryChild;
                      while (_progressedChild2 !== null) {
                        _progressedChild2.return = _primaryChildFragment2;
                        _progressedChild2 = _progressedChild2.sibling;
                      }
                    }
                  }
                  if (workInProgress2.mode & ProfileMode) {
                    var _treeBaseDuration = 0;
                    var _hiddenChild = _primaryChildFragment2.child;
                    while (_hiddenChild !== null) {
                      _treeBaseDuration += _hiddenChild.treeBaseDuration;
                      _hiddenChild = _hiddenChild.sibling;
                    }
                    _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
                  }
                  var _fallbackChildFragment2 = createWorkInProgress(currentFallbackChildFragment, _nextFallbackChildren2);
                  _fallbackChildFragment2.return = workInProgress2;
                  _primaryChildFragment2.sibling = _fallbackChildFragment2;
                  _primaryChildFragment2.childExpirationTime = NoWork;
                  workInProgress2.memoizedState = SUSPENDED_MARKER;
                  workInProgress2.child = _primaryChildFragment2;
                  return _fallbackChildFragment2;
                } else {
                  var _nextPrimaryChildren = nextProps.children;
                  var currentPrimaryChild = currentPrimaryChildFragment.child;
                  var primaryChild = reconcileChildFibers(workInProgress2, currentPrimaryChild, _nextPrimaryChildren, renderExpirationTime2);
                  workInProgress2.memoizedState = null;
                  return workInProgress2.child = primaryChild;
                }
              } else {
                var _currentPrimaryChild = current2.child;
                if (nextDidTimeout) {
                  var _nextFallbackChildren3 = nextProps.fallback;
                  var _primaryChildFragment3 = createFiberFromFragment(null, mode, NoWork, null);
                  _primaryChildFragment3.return = workInProgress2;
                  _primaryChildFragment3.child = _currentPrimaryChild;
                  if (_currentPrimaryChild !== null) {
                    _currentPrimaryChild.return = _primaryChildFragment3;
                  }
                  if ((workInProgress2.mode & BlockingMode) === NoMode) {
                    var _progressedState2 = workInProgress2.memoizedState;
                    var _progressedPrimaryChild2 = _progressedState2 !== null ? workInProgress2.child.child : workInProgress2.child;
                    _primaryChildFragment3.child = _progressedPrimaryChild2;
                    var _progressedChild3 = _progressedPrimaryChild2;
                    while (_progressedChild3 !== null) {
                      _progressedChild3.return = _primaryChildFragment3;
                      _progressedChild3 = _progressedChild3.sibling;
                    }
                  }
                  if (workInProgress2.mode & ProfileMode) {
                    var _treeBaseDuration2 = 0;
                    var _hiddenChild2 = _primaryChildFragment3.child;
                    while (_hiddenChild2 !== null) {
                      _treeBaseDuration2 += _hiddenChild2.treeBaseDuration;
                      _hiddenChild2 = _hiddenChild2.sibling;
                    }
                    _primaryChildFragment3.treeBaseDuration = _treeBaseDuration2;
                  }
                  var _fallbackChildFragment3 = createFiberFromFragment(_nextFallbackChildren3, mode, renderExpirationTime2, null);
                  _fallbackChildFragment3.return = workInProgress2;
                  _primaryChildFragment3.sibling = _fallbackChildFragment3;
                  _fallbackChildFragment3.effectTag |= Placement;
                  _primaryChildFragment3.childExpirationTime = NoWork;
                  workInProgress2.memoizedState = SUSPENDED_MARKER;
                  workInProgress2.child = _primaryChildFragment3;
                  return _fallbackChildFragment3;
                } else {
                  workInProgress2.memoizedState = null;
                  var _nextPrimaryChildren2 = nextProps.children;
                  return workInProgress2.child = reconcileChildFibers(workInProgress2, _currentPrimaryChild, _nextPrimaryChildren2, renderExpirationTime2);
                }
              }
            }
          }
          function scheduleWorkOnFiber(fiber, renderExpirationTime2) {
            if (fiber.expirationTime < renderExpirationTime2) {
              fiber.expirationTime = renderExpirationTime2;
            }
            var alternate = fiber.alternate;
            if (alternate !== null && alternate.expirationTime < renderExpirationTime2) {
              alternate.expirationTime = renderExpirationTime2;
            }
            scheduleWorkOnParentPath(fiber.return, renderExpirationTime2);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderExpirationTime2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  scheduleWorkOnFiber(node, renderExpirationTime2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleWorkOnFiber(node, renderExpirationTime2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index3) {
            {
              var isArray3 = Array.isArray(childSlot);
              var isIterable = !isArray3 && typeof getIteratorFn(childSlot) === "function";
              if (isArray3 || isIterable) {
                var type = isArray3 ? "array" : "iterable";
                error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index3, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children2, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children2 !== void 0 && children2 !== null && children2 !== false) {
                if (Array.isArray(children2)) {
                  for (var i = 0; i < children2.length; i++) {
                    if (!validateSuspenseListNestedChild(children2[i], i)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children2);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children2);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i)) {
                          return;
                        }
                        _i++;
                      }
                    }
                  } else {
                    error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailExpiration: 0,
                tailMode,
                lastEffect: lastEffectBeforeRendering
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailExpiration = 0;
              renderState.tailMode = tailMode;
              renderState.lastEffect = lastEffectBeforeRendering;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderExpirationTime2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderExpirationTime2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.effectTag |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.effectTag & DidCapture) !== NoEffect;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderExpirationTime2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & BlockingMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(workInProgress2, false, tail, lastContentRow, tailMode, workInProgress2.lastEffect);
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(workInProgress2, true, _tail, null, tailMode, workInProgress2.lastEffect);
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(workInProgress2, false, null, null, void 0, workInProgress2.lastEffect);
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderExpirationTime2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderExpirationTime2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderExpirationTime2);
            }
            return workInProgress2.child;
          }
          function updateContextProvider(current2, workInProgress2, renderExpirationTime2) {
            var providerType = workInProgress2.type;
            var context2 = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider", getCurrentFiberStackInDev);
              }
            }
            pushProvider(workInProgress2, newValue);
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              var changedBits = calculateChangedBits(context2, newValue, oldValue);
              if (changedBits === 0) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderExpirationTime2);
                }
              } else {
                propagateContextChange(workInProgress2, context2, changedBits, renderExpirationTime2);
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderExpirationTime2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderExpirationTime2) {
            var context2 = workInProgress2.type;
            {
              if (context2._context === void 0) {
                if (context2 !== context2.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context2 = context2._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render2 = newProps.children;
            {
              if (typeof render2 !== "function") {
                error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderExpirationTime2);
            var newValue = readContext(context2, newProps.unstable_observedBits);
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render2(newValue);
              setIsRendering(false);
            }
            workInProgress2.effectTag |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderExpirationTime2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderExpirationTime2) {
            cancelWorkTimer(workInProgress2);
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            var updateExpirationTime = workInProgress2.expirationTime;
            if (updateExpirationTime !== NoWork) {
              markUnprocessedUpdateTime(updateExpirationTime);
            }
            var childExpirationTime = workInProgress2.childExpirationTime;
            if (childExpirationTime < renderExpirationTime2) {
              return null;
            } else {
              cloneChildFibers(current2, workInProgress2);
              return workInProgress2.child;
            }
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var last = returnFiber.lastEffect;
              if (last !== null) {
                last.nextEffect = current2;
                returnFiber.lastEffect = current2;
              } else {
                returnFiber.firstEffect = returnFiber.lastEffect = current2;
              }
              current2.nextEffect = null;
              current2.effectTag = Deletion;
              newWorkInProgress.effectTag |= Placement;
              return newWorkInProgress;
            }
          }
          function beginWork(current2, workInProgress2, renderExpirationTime2) {
            var updateExpirationTime = workInProgress2.expirationTime;
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.expirationTime));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else if (updateExpirationTime < renderExpirationTime2) {
                didReceiveUpdate = false;
                switch (workInProgress2.tag) {
                  case HostRoot:
                    pushHostRootContext(workInProgress2);
                    resetHydrationState();
                    break;
                  case HostComponent:
                    pushHostContext(workInProgress2);
                    if (workInProgress2.mode & ConcurrentMode && renderExpirationTime2 !== Never && shouldDeprioritizeSubtree(workInProgress2.type, newProps)) {
                      {
                        markSpawnedWork(Never);
                      }
                      workInProgress2.expirationTime = workInProgress2.childExpirationTime = Never;
                      return null;
                    }
                    break;
                  case ClassComponent: {
                    var Component6 = workInProgress2.type;
                    if (isContextProvider(Component6)) {
                      pushContextProvider(workInProgress2);
                    }
                    break;
                  }
                  case HostPortal:
                    pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                    break;
                  case ContextProvider: {
                    var newValue = workInProgress2.memoizedProps.value;
                    pushProvider(workInProgress2, newValue);
                    break;
                  }
                  case Profiler:
                    {
                      var hasChildWork = workInProgress2.childExpirationTime >= renderExpirationTime2;
                      if (hasChildWork) {
                        workInProgress2.effectTag |= Update;
                      }
                    }
                    break;
                  case SuspenseComponent: {
                    var state = workInProgress2.memoizedState;
                    if (state !== null) {
                      var primaryChildFragment = workInProgress2.child;
                      var primaryChildExpirationTime = primaryChildFragment.childExpirationTime;
                      if (primaryChildExpirationTime !== NoWork && primaryChildExpirationTime >= renderExpirationTime2) {
                        return updateSuspenseComponent(current2, workInProgress2, renderExpirationTime2);
                      } else {
                        pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                        var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderExpirationTime2);
                        if (child !== null) {
                          return child.sibling;
                        } else {
                          return null;
                        }
                      }
                    } else {
                      pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    }
                    break;
                  }
                  case SuspenseListComponent: {
                    var didSuspendBefore = (current2.effectTag & DidCapture) !== NoEffect;
                    var _hasChildWork = workInProgress2.childExpirationTime >= renderExpirationTime2;
                    if (didSuspendBefore) {
                      if (_hasChildWork) {
                        return updateSuspenseListComponent(current2, workInProgress2, renderExpirationTime2);
                      }
                      workInProgress2.effectTag |= DidCapture;
                    }
                    var renderState = workInProgress2.memoizedState;
                    if (renderState !== null) {
                      renderState.rendering = null;
                      renderState.tail = null;
                    }
                    pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                    if (_hasChildWork) {
                      break;
                    } else {
                      return null;
                    }
                  }
                }
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderExpirationTime2);
              } else {
                didReceiveUpdate = false;
              }
            } else {
              didReceiveUpdate = false;
            }
            workInProgress2.expirationTime = NoWork;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderExpirationTime2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, updateExpirationTime, renderExpirationTime2);
              }
              case FunctionComponent: {
                var _Component = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, _Component, resolvedProps, renderExpirationTime2);
              }
              case ClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component2, _resolvedProps, renderExpirationTime2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderExpirationTime2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderExpirationTime2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderExpirationTime2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderExpirationTime2);
              case ForwardRef: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderExpirationTime2);
              }
              case Fragment:
                return updateFragment(current2, workInProgress2, renderExpirationTime2);
              case Mode:
                return updateMode(current2, workInProgress2, renderExpirationTime2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderExpirationTime2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderExpirationTime2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderExpirationTime2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(outerPropTypes, _resolvedProps3, "prop", getComponentName(_type2), getCurrentFiberStackInDev);
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, updateExpirationTime, renderExpirationTime2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, updateExpirationTime, renderExpirationTime2);
              }
              case IncompleteClassComponent: {
                var _Component3 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component3, _resolvedProps4, renderExpirationTime2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderExpirationTime2);
              }
            }
            {
              {
                throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function markUpdate(workInProgress2) {
            workInProgress2.effectTag |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.effectTag |= Ref;
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent, node.stateNode);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function completeWork(current2, workInProgress2, renderExpirationTime2) {
            var newProps = workInProgress2.pendingProps;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef:
              case Fragment:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                return null;
              case ClassComponent: {
                var Component6 = workInProgress2.type;
                if (isContextProvider(Component6)) {
                  popContext(workInProgress2);
                }
                return null;
              }
              case HostRoot: {
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                var fiberRoot = workInProgress2.stateNode;
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  }
                }
                updateHostContainer(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (!(workInProgress2.stateNode !== null)) {
                      {
                        throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (!(workInProgress2.stateNode !== null)) {
                      {
                        throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if ((workInProgress2.effectTag & DidCapture) !== NoEffect) {
                  workInProgress2.expirationTime = renderExpirationTime2;
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = false;
                if (current2 === null) {
                  if (workInProgress2.memoizedProps.fallback !== void 0) {
                    popHydrationState(workInProgress2);
                  }
                } else {
                  var prevState = current2.memoizedState;
                  prevDidTimeout = prevState !== null;
                  if (!nextDidTimeout && prevState !== null) {
                    var currentFallbackChild = current2.child.sibling;
                    if (currentFallbackChild !== null) {
                      var first = workInProgress2.firstEffect;
                      if (first !== null) {
                        workInProgress2.firstEffect = currentFallbackChild;
                        currentFallbackChild.nextEffect = first;
                      } else {
                        workInProgress2.firstEffect = workInProgress2.lastEffect = currentFallbackChild;
                        currentFallbackChild.nextEffect = null;
                      }
                      currentFallbackChild.effectTag = Deletion;
                    }
                  }
                }
                if (nextDidTimeout && !prevDidTimeout) {
                  if ((workInProgress2.mode & BlockingMode) !== NoMode) {
                    var hasInvisibleChildContext = current2 === null && workInProgress2.memoizedProps.unstable_avoidThisFallback !== true;
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
                {
                  if (nextDidTimeout || prevDidTimeout) {
                    workInProgress2.effectTag |= Update;
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                popProvider(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  return null;
                }
                var didSuspendAlready = (workInProgress2.effectTag & DidCapture) !== NoEffect;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.effectTag & DidCapture) === NoEffect);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.effectTag |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThennables = suspended.updateQueue;
                          if (newThennables !== null) {
                            workInProgress2.updateQueue = newThennables;
                            workInProgress2.effectTag |= Update;
                          }
                          if (renderState.lastEffect === null) {
                            workInProgress2.firstEffect = null;
                          }
                          workInProgress2.lastEffect = renderState.lastEffect;
                          resetChildFibers(workInProgress2, renderExpirationTime2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.effectTag |= DidCapture;
                      didSuspendAlready = true;
                      var _newThennables = _suspended.updateQueue;
                      if (_newThennables !== null) {
                        workInProgress2.updateQueue = _newThennables;
                        workInProgress2.effectTag |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate) {
                        var lastEffect = workInProgress2.lastEffect = renderState.lastEffect;
                        if (lastEffect !== null) {
                          lastEffect.nextEffect = null;
                        }
                        return null;
                      }
                    } else if (now() * 2 - renderState.renderingStartTime > renderState.tailExpiration && renderExpirationTime2 > Never) {
                      workInProgress2.effectTag |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      var nextPriority = renderExpirationTime2 - 1;
                      workInProgress2.expirationTime = workInProgress2.childExpirationTime = nextPriority;
                      {
                        markSpawnedWork(nextPriority);
                      }
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  if (renderState.tailExpiration === 0) {
                    var TAIL_EXPIRATION_TIMEOUT_MS = 500;
                    renderState.tailExpiration = now() + TAIL_EXPIRATION_TIMEOUT_MS;
                  }
                  var next = renderState.tail;
                  renderState.rendering = next;
                  renderState.tail = next.sibling;
                  renderState.lastEffect = workInProgress2.lastEffect;
                  renderState.renderingStartTime = now();
                  next.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next;
                }
                return null;
              }
            }
            {
              {
                throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function unwindWork(workInProgress2, renderExpirationTime2) {
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component6 = workInProgress2.type;
                if (isContextProvider(Component6)) {
                  popContext(workInProgress2);
                }
                var effectTag = workInProgress2.effectTag;
                if (effectTag & ShouldCapture) {
                  workInProgress2.effectTag = effectTag & ~ShouldCapture | DidCapture;
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                var _effectTag = workInProgress2.effectTag;
                if (!((_effectTag & DidCapture) === NoEffect)) {
                  {
                    throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
                  }
                }
                workInProgress2.effectTag = _effectTag & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var _effectTag2 = workInProgress2.effectTag;
                if (_effectTag2 & ShouldCapture) {
                  workInProgress2.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                popProvider(workInProgress2);
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(interruptedWork) {
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                popProvider(interruptedWork);
                break;
            }
          }
          function createCapturedValue(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
          }
          function logCapturedError(capturedError) {
            var error2 = capturedError.error;
            {
              var componentName = capturedError.componentName, componentStack = capturedError.componentStack, errorBoundaryName = capturedError.errorBoundaryName, errorBoundaryFound = capturedError.errorBoundaryFound, willRetry = capturedError.willRetry;
              if (error2 != null && error2._suppressLogging) {
                if (errorBoundaryFound && willRetry) {
                  return;
                }
                console["error"](error2);
              }
              var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
              var errorBoundaryMessage;
              if (errorBoundaryFound && errorBoundaryName) {
                if (willRetry) {
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                } else {
                  errorBoundaryMessage = "This error was initially handled by the error boundary " + errorBoundaryName + ".\nRecreating the tree from scratch failed so React will unmount the tree.";
                }
              } else {
                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://fb.me/react-error-boundaries to learn more about error boundaries.";
              }
              var combinedMessage = "" + componentNameMessage + componentStack + "\n\n" + ("" + errorBoundaryMessage);
              console["error"](combinedMessage);
            }
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          function logError(boundary, errorInfo) {
            var source = errorInfo.source;
            var stack = errorInfo.stack;
            if (stack === null && source !== null) {
              stack = getStackByFiberInDevAndProd(source);
            }
            var capturedError = {
              componentName: source !== null ? getComponentName(source.type) : null,
              componentStack: stack !== null ? stack : "",
              error: errorInfo.value,
              errorBoundary: null,
              errorBoundaryName: null,
              errorBoundaryFound: false,
              willRetry: false
            };
            if (boundary !== null && boundary.tag === ClassComponent) {
              capturedError.errorBoundary = boundary.stateNode;
              capturedError.errorBoundaryName = getComponentName(boundary.type);
              capturedError.errorBoundaryFound = true;
              capturedError.willRetry = true;
            }
            try {
              logCapturedError(capturedError);
            } catch (e) {
              setTimeout(function() {
                throw e;
              });
            }
          }
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            startPhaseTimer(current2, "componentWillUnmount");
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            instance.componentWillUnmount();
            stopPhaseTimer();
          };
          function safelyCallComponentWillUnmount(current2, instance) {
            {
              invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current2, instance);
              if (hasCaughtError()) {
                var unmountError = clearCaughtError();
                captureCommitPhaseError(current2, unmountError);
              }
            }
          }
          function safelyDetachRef(current2) {
            var ref = current2.ref;
            if (ref !== null) {
              if (typeof ref === "function") {
                {
                  invokeGuardedCallback(null, ref, null, null);
                  if (hasCaughtError()) {
                    var refError = clearCaughtError();
                    captureCommitPhaseError(current2, refError);
                  }
                }
              } else {
                ref.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, destroy) {
            {
              invokeGuardedCallback(null, destroy, null);
              if (hasCaughtError()) {
                var error2 = clearCaughtError();
                captureCommitPhaseError(current2, error2);
              }
            }
          }
          function commitBeforeMutationLifeCycles(current2, finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent:
              case Block: {
                return;
              }
              case ClassComponent: {
                if (finishedWork.effectTag & Snapshot) {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                    stopPhaseTimer();
                  }
                }
                return;
              }
              case HostRoot:
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                return;
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function commitHookEffectListUnmount(tag, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & tag) === tag) {
                  var destroy = effect.destroy;
                  effect.destroy = void 0;
                  if (destroy !== void 0) {
                    destroy();
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitHookEffectListMount(tag, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & tag) === tag) {
                  var create = effect.create;
                  effect.destroy = create();
                  {
                    var destroy = effect.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error("An effect function must not return anything besides a function, which is used for clean-up.%s%s", addendum, getStackByFiberInDevAndProd(finishedWork));
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitPassiveHookEffects(finishedWork) {
            if ((finishedWork.effectTag & Passive) !== NoEffect) {
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent:
                case Block: {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork);
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                  break;
                }
              }
            }
          }
          function commitLifeCycles(finishedRoot, current2, finishedWork, committedExpirationTime) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent:
              case Block: {
                commitHookEffectListMount(Layout | HasEffect, finishedWork);
                return;
              }
              case ClassComponent: {
                var instance = finishedWork.stateNode;
                if (finishedWork.effectTag & Update) {
                  if (current2 === null) {
                    startPhaseTimer(finishedWork, "componentDidMount");
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    instance.componentDidMount();
                    stopPhaseTimer();
                  } else {
                    var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                    var prevState = current2.memoizedState;
                    startPhaseTimer(finishedWork, "componentDidUpdate");
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                    stopPhaseTimer();
                  }
                }
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue, instance);
                }
                return;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                return;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current2 === null && finishedWork.effectTag & Update) {
                  var type = finishedWork.type;
                  var props = finishedWork.memoizedProps;
                  commitMount(_instance2, type, props);
                }
                return;
              }
              case HostText: {
                return;
              }
              case HostPortal: {
                return;
              }
              case Profiler: {
                {
                  var onRender = finishedWork.memoizedProps.onRender;
                  if (typeof onRender === "function") {
                    {
                      onRender(finishedWork.memoizedProps.id, current2 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);
                    }
                  }
                }
                return;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                return;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case FundamentalComponent:
              case ScopeComponent:
                return;
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  var instance = node.stateNode;
                  if (isHidden) {
                    hideInstance(instance);
                  } else {
                    unhideInstance(node.stateNode, node.memoizedProps);
                  }
                } else if (node.tag === HostText) {
                  var _instance3 = node.stateNode;
                  if (isHidden) {
                    hideTextInstance(_instance3);
                  } else {
                    unhideTextInstance(_instance3, node.memoizedProps);
                  }
                } else if (node.tag === SuspenseComponent && node.memoizedState !== null && node.memoizedState.dehydrated === null) {
                  var fallbackChildFragment = node.child.sibling;
                  fallbackChildFragment.return = node;
                  node = fallbackChildFragment;
                  continue;
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref === "function") {
                ref(instanceToUse);
              } else {
                {
                  if (!ref.hasOwnProperty("current")) {
                    error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().%s", getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));
                  }
                }
                ref.current = instanceToUse;
              }
            }
          }
          function commitDetachRef(current2) {
            var currentRef = current2.ref;
            if (currentRef !== null) {
              if (typeof currentRef === "function") {
                currentRef(null);
              } else {
                currentRef.current = null;
              }
            }
          }
          function commitUnmount(finishedRoot, current2, renderPriorityLevel) {
            onCommitUnmount(current2);
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
              case Block: {
                var updateQueue = current2.updateQueue;
                if (updateQueue !== null) {
                  var lastEffect = updateQueue.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    {
                      var priorityLevel = renderPriorityLevel > NormalPriority ? NormalPriority : renderPriorityLevel;
                      runWithPriority$1(priorityLevel, function() {
                        var effect = firstEffect;
                        do {
                          var _destroy = effect.destroy;
                          if (_destroy !== void 0) {
                            safelyCallDestroy(current2, _destroy);
                          }
                          effect = effect.next;
                        } while (effect !== firstEffect);
                      });
                    }
                  }
                }
                return;
              }
              case ClassComponent: {
                safelyDetachRef(current2);
                var instance = current2.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(current2, instance);
                }
                return;
              }
              case HostComponent: {
                safelyDetachRef(current2);
                return;
              }
              case HostPortal: {
                {
                  unmountHostComponents(finishedRoot, current2, renderPriorityLevel);
                }
                return;
              }
              case FundamentalComponent: {
                return;
              }
              case DehydratedFragment: {
                return;
              }
              case ScopeComponent: {
                return;
              }
            }
          }
          function commitNestedUnmounts(finishedRoot, root3, renderPriorityLevel) {
            var node = root3;
            while (true) {
              commitUnmount(finishedRoot, node, renderPriorityLevel);
              if (node.child !== null && node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === root3) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === root3) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function detachFiber(current2) {
            var alternate = current2.alternate;
            current2.return = null;
            current2.child = null;
            current2.memoizedState = null;
            current2.updateQueue = null;
            current2.dependencies = null;
            current2.alternate = null;
            current2.firstEffect = null;
            current2.lastEffect = null;
            current2.pendingProps = null;
            current2.memoizedProps = null;
            current2.stateNode = null;
            if (alternate !== null) {
              detachFiber(alternate);
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            {
              {
                throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings:
              while (true) {
                while (node.sibling === null) {
                  if (node.return === null || isHostParent(node.return)) {
                    return null;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                  if (node.effectTag & Placement) {
                    continue siblings;
                  }
                  if (node.child === null || node.tag === HostPortal) {
                    continue siblings;
                  } else {
                    node.child.return = node;
                    node = node.child;
                  }
                }
                if (!(node.effectTag & Placement)) {
                  return node.stateNode;
                }
              }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            var parent;
            var isContainer;
            var parentStateNode = parentFiber.stateNode;
            switch (parentFiber.tag) {
              case HostComponent:
                parent = parentStateNode;
                isContainer = false;
                break;
              case HostRoot:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
              case HostPortal:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
              case FundamentalComponent:
              default: {
                {
                  throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            if (parentFiber.effectTag & ContentReset) {
              resetTextContent(parent);
              parentFiber.effectTag &= ~ContentReset;
            }
            var before = getHostSibling(finishedWork);
            if (isContainer) {
              insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
            } else {
              insertOrAppendPlacementNode(finishedWork, before, parent);
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost || enableFundamentalAPI) {
              var stateNode = isHost ? node.stateNode : node.stateNode.instance;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost || enableFundamentalAPI) {
              var stateNode = isHost ? node.stateNode : node.stateNode.instance;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function unmountHostComponents(finishedRoot, current2, renderPriorityLevel) {
            var node = current2;
            var currentParentIsValid = false;
            var currentParent;
            var currentParentIsContainer;
            while (true) {
              if (!currentParentIsValid) {
                var parent = node.return;
                findParent:
                  while (true) {
                    if (!(parent !== null)) {
                      {
                        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                    var parentStateNode = parent.stateNode;
                    switch (parent.tag) {
                      case HostComponent:
                        currentParent = parentStateNode;
                        currentParentIsContainer = false;
                        break findParent;
                      case HostRoot:
                        currentParent = parentStateNode.containerInfo;
                        currentParentIsContainer = true;
                        break findParent;
                      case HostPortal:
                        currentParent = parentStateNode.containerInfo;
                        currentParentIsContainer = true;
                        break findParent;
                    }
                    parent = parent.return;
                  }
                currentParentIsValid = true;
              }
              if (node.tag === HostComponent || node.tag === HostText) {
                commitNestedUnmounts(finishedRoot, node, renderPriorityLevel);
                if (currentParentIsContainer) {
                  removeChildFromContainer(currentParent, node.stateNode);
                } else {
                  removeChild(currentParent, node.stateNode);
                }
              } else if (node.tag === HostPortal) {
                if (node.child !== null) {
                  currentParent = node.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
              } else {
                commitUnmount(finishedRoot, node, renderPriorityLevel);
                if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
              }
              if (node === current2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === current2) {
                  return;
                }
                node = node.return;
                if (node.tag === HostPortal) {
                  currentParentIsValid = false;
                }
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function commitDeletion(finishedRoot, current2, renderPriorityLevel) {
            {
              unmountHostComponents(finishedRoot, current2, renderPriorityLevel);
            }
            detachFiber(current2);
          }
          function commitWork(current2, finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
              case Block: {
                commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
                return;
              }
              case ClassComponent: {
                return;
              }
              case HostComponent: {
                var instance = finishedWork.stateNode;
                if (instance != null) {
                  var newProps = finishedWork.memoizedProps;
                  var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                  var type = finishedWork.type;
                  var updatePayload = finishedWork.updateQueue;
                  finishedWork.updateQueue = null;
                  if (updatePayload !== null) {
                    commitUpdate(instance, updatePayload, type, oldProps, newProps);
                  }
                }
                return;
              }
              case HostText: {
                if (!(finishedWork.stateNode !== null)) {
                  {
                    throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps;
                var oldText = current2 !== null ? current2.memoizedProps : newText;
                commitTextUpdate(textInstance, oldText, newText);
                return;
              }
              case HostRoot: {
                {
                  var _root = finishedWork.stateNode;
                  if (_root.hydrate) {
                    _root.hydrate = false;
                    commitHydratedContainer(_root.containerInfo);
                  }
                }
                return;
              }
              case Profiler: {
                return;
              }
              case SuspenseComponent: {
                commitSuspenseComponent(finishedWork);
                attachSuspenseRetryListeners(finishedWork);
                return;
              }
              case SuspenseListComponent: {
                attachSuspenseRetryListeners(finishedWork);
                return;
              }
              case IncompleteClassComponent: {
                return;
              }
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function commitSuspenseComponent(finishedWork) {
            var newState = finishedWork.memoizedState;
            var newDidTimeout;
            var primaryChildParent = finishedWork;
            if (newState === null) {
              newDidTimeout = false;
            } else {
              newDidTimeout = true;
              primaryChildParent = finishedWork.child;
              markCommitTimeOfFallback();
            }
            if (primaryChildParent !== null) {
              hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
            }
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var thenables = finishedWork.updateQueue;
            if (thenables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              thenables.forEach(function(thenable) {
                var retry = resolveRetryThenable.bind(null, finishedWork, thenable);
                if (!retryCache.has(thenable)) {
                  {
                    if (thenable.__reactDoNotTraceInteractions !== true) {
                      retry = tracing.unstable_wrap(retry);
                    }
                  }
                  retryCache.add(thenable);
                  thenable.then(retry, retry);
                }
              });
            }
          }
          function commitResetTextContent(current2) {
            resetTextContent(current2.stateNode);
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
            var update = createUpdate(expirationTime, null);
            update.tag = CaptureUpdate;
            update.payload = {
              element: null
            };
            var error2 = errorInfo.value;
            update.callback = function() {
              onUncaughtError(error2);
              logError(fiber, errorInfo);
            };
            return update;
          }
          function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
            var update = createUpdate(expirationTime, null);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update.payload = function() {
                logError(fiber, errorInfo);
                return getDerivedStateFromError(error$1);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                  logError(fiber, errorInfo);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (fiber.expirationTime !== Sync) {
                      error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown");
                    }
                  }
                }
              };
            } else {
              update.callback = function() {
                markFailedErrorBoundaryForHotReloading(fiber);
              };
            }
            return update;
          }
          function attachPingListener(root3, renderExpirationTime2, thenable) {
            var pingCache = root3.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root3.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(thenable, threadIDs);
            } else {
              threadIDs = pingCache.get(thenable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(thenable, threadIDs);
              }
            }
            if (!threadIDs.has(renderExpirationTime2)) {
              threadIDs.add(renderExpirationTime2);
              var ping = pingSuspendedRoot.bind(null, root3, thenable, renderExpirationTime2);
              thenable.then(ping, ping);
            }
          }
          function throwException(root3, returnFiber, sourceFiber, value, renderExpirationTime2) {
            sourceFiber.effectTag |= Incomplete;
            sourceFiber.firstEffect = sourceFiber.lastEffect = null;
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var thenable = value;
              if ((sourceFiber.mode & BlockingMode) === NoMode) {
                var currentSource = sourceFiber.alternate;
                if (currentSource) {
                  sourceFiber.updateQueue = currentSource.updateQueue;
                  sourceFiber.memoizedState = currentSource.memoizedState;
                  sourceFiber.expirationTime = currentSource.expirationTime;
                } else {
                  sourceFiber.updateQueue = null;
                  sourceFiber.memoizedState = null;
                }
              }
              var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext);
              var _workInProgress = returnFiber;
              do {
                if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
                  var thenables = _workInProgress.updateQueue;
                  if (thenables === null) {
                    var updateQueue = /* @__PURE__ */ new Set();
                    updateQueue.add(thenable);
                    _workInProgress.updateQueue = updateQueue;
                  } else {
                    thenables.add(thenable);
                  }
                  if ((_workInProgress.mode & BlockingMode) === NoMode) {
                    _workInProgress.effectTag |= DidCapture;
                    sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
                    if (sourceFiber.tag === ClassComponent) {
                      var currentSourceFiber = sourceFiber.alternate;
                      if (currentSourceFiber === null) {
                        sourceFiber.tag = IncompleteClassComponent;
                      } else {
                        var update = createUpdate(Sync, null);
                        update.tag = ForceUpdate;
                        enqueueUpdate(sourceFiber, update);
                      }
                    }
                    sourceFiber.expirationTime = Sync;
                    return;
                  }
                  attachPingListener(root3, renderExpirationTime2, thenable);
                  _workInProgress.effectTag |= ShouldCapture;
                  _workInProgress.expirationTime = renderExpirationTime2;
                  return;
                }
                _workInProgress = _workInProgress.return;
              } while (_workInProgress !== null);
              value = new Error((getComponentName(sourceFiber.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + getStackByFiberInDevAndProd(sourceFiber));
            }
            renderDidError();
            value = createCapturedValue(value, sourceFiber);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.effectTag |= ShouldCapture;
                  workInProgress2.expirationTime = renderExpirationTime2;
                  var _update = createRootErrorUpdate(workInProgress2, _errorInfo, renderExpirationTime2);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.effectTag |= ShouldCapture;
                    workInProgress2.expirationTime = renderExpirationTime2;
                    var _update2 = createClassErrorUpdate(workInProgress2, errorInfo, renderExpirationTime2);
                    enqueueCapturedUpdate(workInProgress2, _update2);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          var ceil = Math.ceil;
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
          var NoContext = 0;
          var BatchedContext = 1;
          var EventContext = 2;
          var DiscreteEventContext = 4;
          var LegacyUnbatchedContext = 8;
          var RenderContext = 16;
          var CommitContext = 32;
          var RootIncomplete = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var renderExpirationTime$1 = NoWork;
          var workInProgressRootExitStatus = RootIncomplete;
          var workInProgressRootFatalError = null;
          var workInProgressRootLatestProcessedExpirationTime = Sync;
          var workInProgressRootLatestSuspenseTimeout = Sync;
          var workInProgressRootCanSuspendUsingConfig = null;
          var workInProgressRootNextUnprocessedUpdateTime = NoWork;
          var workInProgressRootHasPendingPing = false;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var nextEffect = null;
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsRenderPriority = NoPriority;
          var pendingPassiveEffectsExpirationTime = NoWork;
          var rootsWithPendingDiscreteUpdates = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var interruptedBy = null;
          var spawnedWorkDuringRender = null;
          var currentEventTime = NoWork;
          function requestCurrentTimeForUpdate() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return msToExpirationTime(now());
            }
            if (currentEventTime !== NoWork) {
              return currentEventTime;
            }
            currentEventTime = msToExpirationTime(now());
            return currentEventTime;
          }
          function getCurrentTime() {
            return msToExpirationTime(now());
          }
          function computeExpirationForFiber(currentTime, fiber, suspenseConfig) {
            var mode = fiber.mode;
            if ((mode & BlockingMode) === NoMode) {
              return Sync;
            }
            var priorityLevel = getCurrentPriorityLevel();
            if ((mode & ConcurrentMode) === NoMode) {
              return priorityLevel === ImmediatePriority ? Sync : Batched;
            }
            if ((executionContext & RenderContext) !== NoContext) {
              return renderExpirationTime$1;
            }
            var expirationTime;
            if (suspenseConfig !== null) {
              expirationTime = computeSuspenseExpiration(currentTime, suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION);
            } else {
              switch (priorityLevel) {
                case ImmediatePriority:
                  expirationTime = Sync;
                  break;
                case UserBlockingPriority$1:
                  expirationTime = computeInteractiveExpiration(currentTime);
                  break;
                case NormalPriority:
                case LowPriority:
                  expirationTime = computeAsyncExpiration(currentTime);
                  break;
                case IdlePriority:
                  expirationTime = Idle;
                  break;
                default: {
                  {
                    throw Error("Expected a valid priority level");
                  }
                }
              }
            }
            if (workInProgressRoot !== null && expirationTime === renderExpirationTime$1) {
              expirationTime -= 1;
            }
            return expirationTime;
          }
          function scheduleUpdateOnFiber(fiber, expirationTime) {
            checkForNestedUpdates();
            warnAboutRenderPhaseUpdatesInDEV(fiber);
            var root3 = markUpdateTimeFromFiberToRoot(fiber, expirationTime);
            if (root3 === null) {
              warnAboutUpdateOnUnmountedFiberInDEV(fiber);
              return;
            }
            checkForInterruption(fiber, expirationTime);
            recordScheduleUpdate();
            var priorityLevel = getCurrentPriorityLevel();
            if (expirationTime === Sync) {
              if ((executionContext & LegacyUnbatchedContext) !== NoContext && (executionContext & (RenderContext | CommitContext)) === NoContext) {
                schedulePendingInteractions(root3, expirationTime);
                performSyncWorkOnRoot(root3);
              } else {
                ensureRootIsScheduled(root3);
                schedulePendingInteractions(root3, expirationTime);
                if (executionContext === NoContext) {
                  flushSyncCallbackQueue();
                }
              }
            } else {
              ensureRootIsScheduled(root3);
              schedulePendingInteractions(root3, expirationTime);
            }
            if ((executionContext & DiscreteEventContext) !== NoContext && (priorityLevel === UserBlockingPriority$1 || priorityLevel === ImmediatePriority)) {
              if (rootsWithPendingDiscreteUpdates === null) {
                rootsWithPendingDiscreteUpdates = /* @__PURE__ */ new Map([[root3, expirationTime]]);
              } else {
                var lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root3);
                if (lastDiscreteTime === void 0 || lastDiscreteTime > expirationTime) {
                  rootsWithPendingDiscreteUpdates.set(root3, expirationTime);
                }
              }
            }
          }
          var scheduleWork = scheduleUpdateOnFiber;
          function markUpdateTimeFromFiberToRoot(fiber, expirationTime) {
            if (fiber.expirationTime < expirationTime) {
              fiber.expirationTime = expirationTime;
            }
            var alternate = fiber.alternate;
            if (alternate !== null && alternate.expirationTime < expirationTime) {
              alternate.expirationTime = expirationTime;
            }
            var node = fiber.return;
            var root3 = null;
            if (node === null && fiber.tag === HostRoot) {
              root3 = fiber.stateNode;
            } else {
              while (node !== null) {
                alternate = node.alternate;
                if (node.childExpirationTime < expirationTime) {
                  node.childExpirationTime = expirationTime;
                  if (alternate !== null && alternate.childExpirationTime < expirationTime) {
                    alternate.childExpirationTime = expirationTime;
                  }
                } else if (alternate !== null && alternate.childExpirationTime < expirationTime) {
                  alternate.childExpirationTime = expirationTime;
                }
                if (node.return === null && node.tag === HostRoot) {
                  root3 = node.stateNode;
                  break;
                }
                node = node.return;
              }
            }
            if (root3 !== null) {
              if (workInProgressRoot === root3) {
                markUnprocessedUpdateTime(expirationTime);
                if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                  markRootSuspendedAtTime(root3, renderExpirationTime$1);
                }
              }
              markRootUpdatedAtTime(root3, expirationTime);
            }
            return root3;
          }
          function getNextRootExpirationTimeToWorkOn(root3) {
            var lastExpiredTime = root3.lastExpiredTime;
            if (lastExpiredTime !== NoWork) {
              return lastExpiredTime;
            }
            var firstPendingTime = root3.firstPendingTime;
            if (!isRootSuspendedAtTime(root3, firstPendingTime)) {
              return firstPendingTime;
            }
            var lastPingedTime = root3.lastPingedTime;
            var nextKnownPendingLevel = root3.nextKnownPendingLevel;
            var nextLevel = lastPingedTime > nextKnownPendingLevel ? lastPingedTime : nextKnownPendingLevel;
            if (nextLevel <= Idle && firstPendingTime !== nextLevel) {
              return NoWork;
            }
            return nextLevel;
          }
          function ensureRootIsScheduled(root3) {
            var lastExpiredTime = root3.lastExpiredTime;
            if (lastExpiredTime !== NoWork) {
              root3.callbackExpirationTime = Sync;
              root3.callbackPriority = ImmediatePriority;
              root3.callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3));
              return;
            }
            var expirationTime = getNextRootExpirationTimeToWorkOn(root3);
            var existingCallbackNode = root3.callbackNode;
            if (expirationTime === NoWork) {
              if (existingCallbackNode !== null) {
                root3.callbackNode = null;
                root3.callbackExpirationTime = NoWork;
                root3.callbackPriority = NoPriority;
              }
              return;
            }
            var currentTime = requestCurrentTimeForUpdate();
            var priorityLevel = inferPriorityFromExpirationTime(currentTime, expirationTime);
            if (existingCallbackNode !== null) {
              var existingCallbackPriority = root3.callbackPriority;
              var existingCallbackExpirationTime = root3.callbackExpirationTime;
              if (existingCallbackExpirationTime === expirationTime && existingCallbackPriority >= priorityLevel) {
                return;
              }
              cancelCallback(existingCallbackNode);
            }
            root3.callbackExpirationTime = expirationTime;
            root3.callbackPriority = priorityLevel;
            var callbackNode;
            if (expirationTime === Sync) {
              callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3));
            } else {
              callbackNode = scheduleCallback(priorityLevel, performConcurrentWorkOnRoot.bind(null, root3), {
                timeout: expirationTimeToMs(expirationTime) - now()
              });
            }
            root3.callbackNode = callbackNode;
          }
          function performConcurrentWorkOnRoot(root3, didTimeout) {
            currentEventTime = NoWork;
            if (didTimeout) {
              var currentTime = requestCurrentTimeForUpdate();
              markRootExpiredAtTime(root3, currentTime);
              ensureRootIsScheduled(root3);
              return null;
            }
            var expirationTime = getNextRootExpirationTimeToWorkOn(root3);
            if (expirationTime !== NoWork) {
              var originalCallbackNode = root3.callbackNode;
              if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
                {
                  throw Error("Should not already be working.");
                }
              }
              flushPassiveEffects();
              if (root3 !== workInProgressRoot || expirationTime !== renderExpirationTime$1) {
                prepareFreshStack(root3, expirationTime);
                startWorkOnPendingInteractions(root3, expirationTime);
              }
              if (workInProgress !== null) {
                var prevExecutionContext = executionContext;
                executionContext |= RenderContext;
                var prevDispatcher = pushDispatcher();
                var prevInteractions = pushInteractions(root3);
                startWorkLoopTimer(workInProgress);
                do {
                  try {
                    workLoopConcurrent();
                    break;
                  } catch (thrownValue) {
                    handleError(root3, thrownValue);
                  }
                } while (true);
                resetContextDependencies();
                executionContext = prevExecutionContext;
                popDispatcher(prevDispatcher);
                {
                  popInteractions(prevInteractions);
                }
                if (workInProgressRootExitStatus === RootFatalErrored) {
                  var fatalError = workInProgressRootFatalError;
                  stopInterruptedWorkLoopTimer();
                  prepareFreshStack(root3, expirationTime);
                  markRootSuspendedAtTime(root3, expirationTime);
                  ensureRootIsScheduled(root3);
                  throw fatalError;
                }
                if (workInProgress !== null) {
                  stopInterruptedWorkLoopTimer();
                } else {
                  stopFinishedWorkLoopTimer();
                  var finishedWork = root3.finishedWork = root3.current.alternate;
                  root3.finishedExpirationTime = expirationTime;
                  finishConcurrentRender(root3, finishedWork, workInProgressRootExitStatus, expirationTime);
                }
                ensureRootIsScheduled(root3);
                if (root3.callbackNode === originalCallbackNode) {
                  return performConcurrentWorkOnRoot.bind(null, root3);
                }
              }
            }
            return null;
          }
          function finishConcurrentRender(root3, finishedWork, exitStatus, expirationTime) {
            workInProgressRoot = null;
            switch (exitStatus) {
              case RootIncomplete:
              case RootFatalErrored: {
                {
                  {
                    throw Error("Root did not complete. This is a bug in React.");
                  }
                }
              }
              case RootErrored: {
                markRootExpiredAtTime(root3, expirationTime > Idle ? Idle : expirationTime);
                break;
              }
              case RootSuspended: {
                markRootSuspendedAtTime(root3, expirationTime);
                var lastSuspendedTime = root3.lastSuspendedTime;
                if (expirationTime === lastSuspendedTime) {
                  root3.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);
                }
                var hasNotProcessedNewUpdates = workInProgressRootLatestProcessedExpirationTime === Sync;
                if (hasNotProcessedNewUpdates && !IsThisRendererActing.current) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                  if (msUntilTimeout > 10) {
                    if (workInProgressRootHasPendingPing) {
                      var lastPingedTime = root3.lastPingedTime;
                      if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {
                        root3.lastPingedTime = expirationTime;
                        prepareFreshStack(root3, expirationTime);
                        break;
                      }
                    }
                    var nextTime = getNextRootExpirationTimeToWorkOn(root3);
                    if (nextTime !== NoWork && nextTime !== expirationTime) {
                      break;
                    }
                    if (lastSuspendedTime !== NoWork && lastSuspendedTime !== expirationTime) {
                      root3.lastPingedTime = lastSuspendedTime;
                      break;
                    }
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root3);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspendedAtTime(root3, expirationTime);
                var _lastSuspendedTime = root3.lastSuspendedTime;
                if (expirationTime === _lastSuspendedTime) {
                  root3.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);
                }
                if (!IsThisRendererActing.current) {
                  if (workInProgressRootHasPendingPing) {
                    var _lastPingedTime = root3.lastPingedTime;
                    if (_lastPingedTime === NoWork || _lastPingedTime >= expirationTime) {
                      root3.lastPingedTime = expirationTime;
                      prepareFreshStack(root3, expirationTime);
                      break;
                    }
                  }
                  var _nextTime = getNextRootExpirationTimeToWorkOn(root3);
                  if (_nextTime !== NoWork && _nextTime !== expirationTime) {
                    break;
                  }
                  if (_lastSuspendedTime !== NoWork && _lastSuspendedTime !== expirationTime) {
                    root3.lastPingedTime = _lastSuspendedTime;
                    break;
                  }
                  var _msUntilTimeout;
                  if (workInProgressRootLatestSuspenseTimeout !== Sync) {
                    _msUntilTimeout = expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();
                  } else if (workInProgressRootLatestProcessedExpirationTime === Sync) {
                    _msUntilTimeout = 0;
                  } else {
                    var eventTimeMs = inferTimeFromExpirationTime(workInProgressRootLatestProcessedExpirationTime);
                    var currentTimeMs = now();
                    var timeUntilExpirationMs = expirationTimeToMs(expirationTime) - currentTimeMs;
                    var timeElapsed = currentTimeMs - eventTimeMs;
                    if (timeElapsed < 0) {
                      timeElapsed = 0;
                    }
                    _msUntilTimeout = jnd(timeElapsed) - timeElapsed;
                    if (timeUntilExpirationMs < _msUntilTimeout) {
                      _msUntilTimeout = timeUntilExpirationMs;
                    }
                  }
                  if (_msUntilTimeout > 10) {
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root3);
                break;
              }
              case RootCompleted: {
                if (!IsThisRendererActing.current && workInProgressRootLatestProcessedExpirationTime !== Sync && workInProgressRootCanSuspendUsingConfig !== null) {
                  var _msUntilTimeout2 = computeMsUntilSuspenseLoadingDelay(workInProgressRootLatestProcessedExpirationTime, expirationTime, workInProgressRootCanSuspendUsingConfig);
                  if (_msUntilTimeout2 > 10) {
                    markRootSuspendedAtTime(root3, expirationTime);
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3), _msUntilTimeout2);
                    break;
                  }
                }
                commitRoot(root3);
                break;
              }
              default: {
                {
                  {
                    throw Error("Unknown root exit status.");
                  }
                }
              }
            }
          }
          function performSyncWorkOnRoot(root3) {
            var lastExpiredTime = root3.lastExpiredTime;
            var expirationTime = lastExpiredTime !== NoWork ? lastExpiredTime : Sync;
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            flushPassiveEffects();
            if (root3 !== workInProgressRoot || expirationTime !== renderExpirationTime$1) {
              prepareFreshStack(root3, expirationTime);
              startWorkOnPendingInteractions(root3, expirationTime);
            }
            if (workInProgress !== null) {
              var prevExecutionContext = executionContext;
              executionContext |= RenderContext;
              var prevDispatcher = pushDispatcher();
              var prevInteractions = pushInteractions(root3);
              startWorkLoopTimer(workInProgress);
              do {
                try {
                  workLoopSync();
                  break;
                } catch (thrownValue) {
                  handleError(root3, thrownValue);
                }
              } while (true);
              resetContextDependencies();
              executionContext = prevExecutionContext;
              popDispatcher(prevDispatcher);
              {
                popInteractions(prevInteractions);
              }
              if (workInProgressRootExitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                stopInterruptedWorkLoopTimer();
                prepareFreshStack(root3, expirationTime);
                markRootSuspendedAtTime(root3, expirationTime);
                ensureRootIsScheduled(root3);
                throw fatalError;
              }
              if (workInProgress !== null) {
                {
                  {
                    throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
              } else {
                stopFinishedWorkLoopTimer();
                root3.finishedWork = root3.current.alternate;
                root3.finishedExpirationTime = expirationTime;
                finishSyncRender(root3);
              }
              ensureRootIsScheduled(root3);
            }
            return null;
          }
          function finishSyncRender(root3) {
            workInProgressRoot = null;
            commitRoot(root3);
          }
          function flushDiscreteUpdates() {
            if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
              {
                if ((executionContext & RenderContext) !== NoContext) {
                  error("unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.");
                }
              }
              return;
            }
            flushPendingDiscreteUpdates();
            flushPassiveEffects();
          }
          function syncUpdates(fn, a, b, c) {
            return runWithPriority$1(ImmediatePriority, fn.bind(null, a, b, c));
          }
          function flushPendingDiscreteUpdates() {
            if (rootsWithPendingDiscreteUpdates !== null) {
              var roots = rootsWithPendingDiscreteUpdates;
              rootsWithPendingDiscreteUpdates = null;
              roots.forEach(function(expirationTime, root3) {
                markRootExpiredAtTime(root3, expirationTime);
                ensureRootIsScheduled(root3);
              });
              flushSyncCallbackQueue();
            }
          }
          function batchedUpdates$1(fn, a) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                flushSyncCallbackQueue();
              }
            }
          }
          function batchedEventUpdates$1(fn, a) {
            var prevExecutionContext = executionContext;
            executionContext |= EventContext;
            try {
              return fn(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                flushSyncCallbackQueue();
              }
            }
          }
          function discreteUpdates$1(fn, a, b, c, d) {
            var prevExecutionContext = executionContext;
            executionContext |= DiscreteEventContext;
            try {
              return runWithPriority$1(UserBlockingPriority$1, fn.bind(null, a, b, c, d));
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                flushSyncCallbackQueue();
              }
            }
          }
          function unbatchedUpdates(fn, a) {
            var prevExecutionContext = executionContext;
            executionContext &= ~BatchedContext;
            executionContext |= LegacyUnbatchedContext;
            try {
              return fn(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                flushSyncCallbackQueue();
              }
            }
          }
          function flushSync(fn, a) {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              {
                {
                  throw Error("flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.");
                }
              }
            }
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return runWithPriority$1(ImmediatePriority, fn.bind(null, a));
            } finally {
              executionContext = prevExecutionContext;
              flushSyncCallbackQueue();
            }
          }
          function prepareFreshStack(root3, expirationTime) {
            root3.finishedWork = null;
            root3.finishedExpirationTime = NoWork;
            var timeoutHandle = root3.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root3.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                unwindInterruptedWork(interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root3;
            workInProgress = createWorkInProgress(root3.current, null);
            renderExpirationTime$1 = expirationTime;
            workInProgressRootExitStatus = RootIncomplete;
            workInProgressRootFatalError = null;
            workInProgressRootLatestProcessedExpirationTime = Sync;
            workInProgressRootLatestSuspenseTimeout = Sync;
            workInProgressRootCanSuspendUsingConfig = null;
            workInProgressRootNextUnprocessedUpdateTime = NoWork;
            workInProgressRootHasPendingPing = false;
            {
              spawnedWorkDuringRender = null;
            }
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
          }
          function handleError(root3, thrownValue) {
            do {
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                if (workInProgress === null || workInProgress.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return null;
                }
                if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
                }
                throwException(root3, workInProgress.return, workInProgress, thrownValue, renderExpirationTime$1);
                workInProgress = completeUnitOfWork(workInProgress);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher(root3) {
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
          function pushInteractions(root3) {
            {
              var prevInteractions = tracing.__interactionsRef.current;
              tracing.__interactionsRef.current = root3.memoizedInteractions;
              return prevInteractions;
            }
          }
          function popInteractions(prevInteractions) {
            {
              tracing.__interactionsRef.current = prevInteractions;
            }
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now();
          }
          function markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {
            if (expirationTime < workInProgressRootLatestProcessedExpirationTime && expirationTime > Idle) {
              workInProgressRootLatestProcessedExpirationTime = expirationTime;
            }
            if (suspenseConfig !== null) {
              if (expirationTime < workInProgressRootLatestSuspenseTimeout && expirationTime > Idle) {
                workInProgressRootLatestSuspenseTimeout = expirationTime;
                workInProgressRootCanSuspendUsingConfig = suspenseConfig;
              }
            }
          }
          function markUnprocessedUpdateTime(expirationTime) {
            if (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {
              workInProgressRootNextUnprocessedUpdateTime = expirationTime;
            }
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootIncomplete) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRootNextUnprocessedUpdateTime !== NoWork && workInProgressRoot !== null) {
              markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime$1);
              markRootUpdatedAtTime(workInProgressRoot, workInProgressRootNextUnprocessedUpdateTime);
            }
          }
          function renderDidError() {
            if (workInProgressRootExitStatus !== RootCompleted) {
              workInProgressRootExitStatus = RootErrored;
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootIncomplete;
          }
          function inferTimeFromExpirationTime(expirationTime) {
            var earliestExpirationTimeMs = expirationTimeToMs(expirationTime);
            return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
          }
          function inferTimeFromExpirationTimeWithSuspenseConfig(expirationTime, suspenseConfig) {
            var earliestExpirationTimeMs = expirationTimeToMs(expirationTime);
            return earliestExpirationTimeMs - (suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION);
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              workInProgress = performUnitOfWork(workInProgress);
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              workInProgress = performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            startWorkTimer(unitOfWork);
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next = beginWork$1(current2, unitOfWork, renderExpirationTime$1);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next = beginWork$1(current2, unitOfWork, renderExpirationTime$1);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
              next = completeUnitOfWork(unitOfWork);
            }
            ReactCurrentOwner$2.current = null;
            return next;
          }
          function completeUnitOfWork(unitOfWork) {
            workInProgress = unitOfWork;
            do {
              var current2 = workInProgress.alternate;
              var returnFiber = workInProgress.return;
              if ((workInProgress.effectTag & Incomplete) === NoEffect) {
                setCurrentFiber(workInProgress);
                var next = void 0;
                if ((workInProgress.mode & ProfileMode) === NoMode) {
                  next = completeWork(current2, workInProgress, renderExpirationTime$1);
                } else {
                  startProfilerTimer(workInProgress);
                  next = completeWork(current2, workInProgress, renderExpirationTime$1);
                  stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
                }
                stopWorkTimer(workInProgress);
                resetCurrentFiber();
                resetChildExpirationTime(workInProgress);
                if (next !== null) {
                  return next;
                }
                if (returnFiber !== null && (returnFiber.effectTag & Incomplete) === NoEffect) {
                  if (returnFiber.firstEffect === null) {
                    returnFiber.firstEffect = workInProgress.firstEffect;
                  }
                  if (workInProgress.lastEffect !== null) {
                    if (returnFiber.lastEffect !== null) {
                      returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
                    }
                    returnFiber.lastEffect = workInProgress.lastEffect;
                  }
                  var effectTag = workInProgress.effectTag;
                  if (effectTag > PerformedWork) {
                    if (returnFiber.lastEffect !== null) {
                      returnFiber.lastEffect.nextEffect = workInProgress;
                    } else {
                      returnFiber.firstEffect = workInProgress;
                    }
                    returnFiber.lastEffect = workInProgress;
                  }
                }
              } else {
                var _next = unwindWork(workInProgress);
                if ((workInProgress.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
                  var actualDuration = workInProgress.actualDuration;
                  var child = workInProgress.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  workInProgress.actualDuration = actualDuration;
                }
                if (_next !== null) {
                  stopFailedWorkTimer(workInProgress);
                  _next.effectTag &= HostEffectMask;
                  return _next;
                }
                stopWorkTimer(workInProgress);
                if (returnFiber !== null) {
                  returnFiber.firstEffect = returnFiber.lastEffect = null;
                  returnFiber.effectTag |= Incomplete;
                }
              }
              var siblingFiber = workInProgress.sibling;
              if (siblingFiber !== null) {
                return siblingFiber;
              }
              workInProgress = returnFiber;
            } while (workInProgress !== null);
            if (workInProgressRootExitStatus === RootIncomplete) {
              workInProgressRootExitStatus = RootCompleted;
            }
            return null;
          }
          function getRemainingExpirationTime(fiber) {
            var updateExpirationTime = fiber.expirationTime;
            var childExpirationTime = fiber.childExpirationTime;
            return updateExpirationTime > childExpirationTime ? updateExpirationTime : childExpirationTime;
          }
          function resetChildExpirationTime(completedWork) {
            if (renderExpirationTime$1 !== Never && completedWork.childExpirationTime === Never) {
              return;
            }
            var newChildExpirationTime = NoWork;
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
              var child = completedWork.child;
              while (child !== null) {
                var childUpdateExpirationTime = child.expirationTime;
                var childChildExpirationTime = child.childExpirationTime;
                if (childUpdateExpirationTime > newChildExpirationTime) {
                  newChildExpirationTime = childUpdateExpirationTime;
                }
                if (childChildExpirationTime > newChildExpirationTime) {
                  newChildExpirationTime = childChildExpirationTime;
                }
                if (shouldBubbleActualDurations) {
                  actualDuration += child.actualDuration;
                }
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                var _childUpdateExpirationTime = _child.expirationTime;
                var _childChildExpirationTime = _child.childExpirationTime;
                if (_childUpdateExpirationTime > newChildExpirationTime) {
                  newChildExpirationTime = _childUpdateExpirationTime;
                }
                if (_childChildExpirationTime > newChildExpirationTime) {
                  newChildExpirationTime = _childChildExpirationTime;
                }
                _child = _child.sibling;
              }
            }
            completedWork.childExpirationTime = newChildExpirationTime;
          }
          function commitRoot(root3) {
            var renderPriorityLevel = getCurrentPriorityLevel();
            runWithPriority$1(ImmediatePriority, commitRootImpl.bind(null, root3, renderPriorityLevel));
            return null;
          }
          function commitRootImpl(root3, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            var finishedWork = root3.finishedWork;
            var expirationTime = root3.finishedExpirationTime;
            if (finishedWork === null) {
              return null;
            }
            root3.finishedWork = null;
            root3.finishedExpirationTime = NoWork;
            if (!(finishedWork !== root3.current)) {
              {
                throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            root3.callbackNode = null;
            root3.callbackExpirationTime = NoWork;
            root3.callbackPriority = NoPriority;
            root3.nextKnownPendingLevel = NoWork;
            startCommitTimer();
            var remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(finishedWork);
            markRootFinishedAtTime(root3, expirationTime, remainingExpirationTimeBeforeCommit);
            if (root3 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              renderExpirationTime$1 = NoWork;
            }
            var firstEffect;
            if (finishedWork.effectTag > PerformedWork) {
              if (finishedWork.lastEffect !== null) {
                finishedWork.lastEffect.nextEffect = finishedWork;
                firstEffect = finishedWork.firstEffect;
              } else {
                firstEffect = finishedWork;
              }
            } else {
              firstEffect = finishedWork.firstEffect;
            }
            if (firstEffect !== null) {
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              var prevInteractions = pushInteractions(root3);
              ReactCurrentOwner$2.current = null;
              startCommitSnapshotEffectsTimer();
              prepareForCommit(root3.containerInfo);
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitBeforeMutationEffects, null);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var error2 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, error2);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              stopCommitSnapshotEffectsTimer();
              {
                recordCommitTime();
              }
              startCommitHostEffectsTimer();
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitMutationEffects, null, root3, renderPriorityLevel);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var _error = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              stopCommitHostEffectsTimer();
              resetAfterCommit(root3.containerInfo);
              root3.current = finishedWork;
              startCommitLifeCyclesTimer();
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitLayoutEffects, null, root3, expirationTime);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var _error2 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error2);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              stopCommitLifeCyclesTimer();
              nextEffect = null;
              requestPaint();
              {
                popInteractions(prevInteractions);
              }
              executionContext = prevExecutionContext;
            } else {
              root3.current = finishedWork;
              startCommitSnapshotEffectsTimer();
              stopCommitSnapshotEffectsTimer();
              {
                recordCommitTime();
              }
              startCommitHostEffectsTimer();
              stopCommitHostEffectsTimer();
              startCommitLifeCyclesTimer();
              stopCommitLifeCyclesTimer();
            }
            stopCommitTimer();
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root3;
              pendingPassiveEffectsExpirationTime = expirationTime;
              pendingPassiveEffectsRenderPriority = renderPriorityLevel;
            } else {
              nextEffect = firstEffect;
              while (nextEffect !== null) {
                var nextNextEffect = nextEffect.nextEffect;
                nextEffect.nextEffect = null;
                nextEffect = nextNextEffect;
              }
            }
            var remainingExpirationTime = root3.firstPendingTime;
            if (remainingExpirationTime !== NoWork) {
              {
                if (spawnedWorkDuringRender !== null) {
                  var expirationTimes = spawnedWorkDuringRender;
                  spawnedWorkDuringRender = null;
                  for (var i = 0; i < expirationTimes.length; i++) {
                    scheduleInteractions(root3, expirationTimes[i], root3.memoizedInteractions);
                  }
                }
                schedulePendingInteractions(root3, remainingExpirationTime);
              }
            } else {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                finishPendingInteractions(root3, expirationTime);
              }
            }
            if (remainingExpirationTime === Sync) {
              if (root3 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root3;
              }
            } else {
              nestedUpdateCount = 0;
            }
            onCommitRoot(finishedWork.stateNode, expirationTime);
            ensureRootIsScheduled(root3);
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var _error3 = firstUncaughtError;
              firstUncaughtError = null;
              throw _error3;
            }
            if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
              return null;
            }
            flushSyncCallbackQueue();
            return null;
          }
          function commitBeforeMutationEffects() {
            while (nextEffect !== null) {
              var effectTag = nextEffect.effectTag;
              if ((effectTag & Snapshot) !== NoEffect) {
                setCurrentFiber(nextEffect);
                recordEffect();
                var current2 = nextEffect.alternate;
                commitBeforeMutationLifeCycles(current2, nextEffect);
                resetCurrentFiber();
              }
              if ((effectTag & Passive) !== NoEffect) {
                if (!rootDoesHavePassiveEffects) {
                  rootDoesHavePassiveEffects = true;
                  scheduleCallback(NormalPriority, function() {
                    flushPassiveEffects();
                    return null;
                  });
                }
              }
              nextEffect = nextEffect.nextEffect;
            }
          }
          function commitMutationEffects(root3, renderPriorityLevel) {
            while (nextEffect !== null) {
              setCurrentFiber(nextEffect);
              var effectTag = nextEffect.effectTag;
              if (effectTag & ContentReset) {
                commitResetTextContent(nextEffect);
              }
              if (effectTag & Ref) {
                var current2 = nextEffect.alternate;
                if (current2 !== null) {
                  commitDetachRef(current2);
                }
              }
              var primaryEffectTag = effectTag & (Placement | Update | Deletion | Hydrating);
              switch (primaryEffectTag) {
                case Placement: {
                  commitPlacement(nextEffect);
                  nextEffect.effectTag &= ~Placement;
                  break;
                }
                case PlacementAndUpdate: {
                  commitPlacement(nextEffect);
                  nextEffect.effectTag &= ~Placement;
                  var _current = nextEffect.alternate;
                  commitWork(_current, nextEffect);
                  break;
                }
                case Hydrating: {
                  nextEffect.effectTag &= ~Hydrating;
                  break;
                }
                case HydratingAndUpdate: {
                  nextEffect.effectTag &= ~Hydrating;
                  var _current2 = nextEffect.alternate;
                  commitWork(_current2, nextEffect);
                  break;
                }
                case Update: {
                  var _current3 = nextEffect.alternate;
                  commitWork(_current3, nextEffect);
                  break;
                }
                case Deletion: {
                  commitDeletion(root3, nextEffect, renderPriorityLevel);
                  break;
                }
              }
              recordEffect();
              resetCurrentFiber();
              nextEffect = nextEffect.nextEffect;
            }
          }
          function commitLayoutEffects(root3, committedExpirationTime) {
            while (nextEffect !== null) {
              setCurrentFiber(nextEffect);
              var effectTag = nextEffect.effectTag;
              if (effectTag & (Update | Callback)) {
                recordEffect();
                var current2 = nextEffect.alternate;
                commitLifeCycles(root3, current2, nextEffect);
              }
              if (effectTag & Ref) {
                recordEffect();
                commitAttachRef(nextEffect);
              }
              resetCurrentFiber();
              nextEffect = nextEffect.nextEffect;
            }
          }
          function flushPassiveEffects() {
            if (pendingPassiveEffectsRenderPriority !== NoPriority) {
              var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority ? NormalPriority : pendingPassiveEffectsRenderPriority;
              pendingPassiveEffectsRenderPriority = NoPriority;
              return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
            }
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var root3 = rootWithPendingPassiveEffects;
            var expirationTime = pendingPassiveEffectsExpirationTime;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsExpirationTime = NoWork;
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Cannot flush passive effects while already rendering.");
              }
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            var prevInteractions = pushInteractions(root3);
            {
              var _effect2 = root3.current.firstEffect;
              while (_effect2 !== null) {
                {
                  setCurrentFiber(_effect2);
                  invokeGuardedCallback(null, commitPassiveHookEffects, null, _effect2);
                  if (hasCaughtError()) {
                    if (!(_effect2 !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var _error5 = clearCaughtError();
                    captureCommitPhaseError(_effect2, _error5);
                  }
                  resetCurrentFiber();
                }
                var nextNextEffect = _effect2.nextEffect;
                _effect2.nextEffect = null;
                _effect2 = nextNextEffect;
              }
            }
            {
              popInteractions(prevInteractions);
              finishPendingInteractions(root3, expirationTime);
            }
            executionContext = prevExecutionContext;
            flushSyncCallbackQueue();
            nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error2) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error2;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
            var errorInfo = createCapturedValue(error2, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, Sync);
            enqueueUpdate(rootFiber, update);
            var root3 = markUpdateTimeFromFiberToRoot(rootFiber, Sync);
            if (root3 !== null) {
              ensureRootIsScheduled(root3);
              schedulePendingInteractions(root3, Sync);
            }
          }
          function captureCommitPhaseError(sourceFiber, error2) {
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error2);
              return;
            }
            var fiber = sourceFiber.return;
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error2);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValue(error2, sourceFiber);
                  var update = createClassErrorUpdate(fiber, errorInfo, Sync);
                  enqueueUpdate(fiber, update);
                  var root3 = markUpdateTimeFromFiberToRoot(fiber, Sync);
                  if (root3 !== null) {
                    ensureRootIsScheduled(root3);
                    schedulePendingInteractions(root3, Sync);
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
          }
          function pingSuspendedRoot(root3, thenable, suspendedTime) {
            var pingCache = root3.pingCache;
            if (pingCache !== null) {
              pingCache.delete(thenable);
            }
            if (workInProgressRoot === root3 && renderExpirationTime$1 === suspendedTime) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && workInProgressRootLatestProcessedExpirationTime === Sync && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root3, renderExpirationTime$1);
              } else {
                workInProgressRootHasPendingPing = true;
              }
              return;
            }
            if (!isRootSuspendedAtTime(root3, suspendedTime)) {
              return;
            }
            var lastPingedTime = root3.lastPingedTime;
            if (lastPingedTime !== NoWork && lastPingedTime < suspendedTime) {
              return;
            }
            root3.lastPingedTime = suspendedTime;
            ensureRootIsScheduled(root3);
            schedulePendingInteractions(root3, suspendedTime);
          }
          function retryTimedOutBoundary(boundaryFiber, retryTime) {
            if (retryTime === NoWork) {
              var suspenseConfig = null;
              var currentTime = requestCurrentTimeForUpdate();
              retryTime = computeExpirationForFiber(currentTime, boundaryFiber, suspenseConfig);
            }
            var root3 = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);
            if (root3 !== null) {
              ensureRootIsScheduled(root3);
              schedulePendingInteractions(root3, retryTime);
            }
          }
          function resolveRetryThenable(boundaryFiber, thenable) {
            var retryTime = NoWork;
            var retryCache;
            {
              retryCache = boundaryFiber.stateNode;
            }
            if (retryCache !== null) {
              retryCache.delete(thenable);
            }
            retryTimedOutBoundary(boundaryFiber, retryTime);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
          }
          function computeMsUntilSuspenseLoadingDelay(mostRecentEventTime, committedExpirationTime, suspenseConfig) {
            var busyMinDurationMs = suspenseConfig.busyMinDurationMs | 0;
            if (busyMinDurationMs <= 0) {
              return 0;
            }
            var busyDelayMs = suspenseConfig.busyDelayMs | 0;
            var currentTimeMs = now();
            var eventTimeMs = inferTimeFromExpirationTimeWithSuspenseConfig(mostRecentEventTime, suspenseConfig);
            var timeElapsed = currentTimeMs - eventTimeMs;
            if (timeElapsed <= busyDelayMs) {
              return 0;
            }
            var msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed;
            return msUntilTimeout;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              {
                {
                  throw Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
                }
              }
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          function stopFinishedWorkLoopTimer() {
            var didCompleteRoot = true;
            stopWorkLoopTimer(interruptedBy, didCompleteRoot);
            interruptedBy = null;
          }
          function stopInterruptedWorkLoopTimer() {
            var didCompleteRoot = false;
            stopWorkLoopTimer(interruptedBy, didCompleteRoot);
            interruptedBy = null;
          }
          function checkForInterruption(fiberThatReceivedUpdate, updateExpirationTime) {
            if (workInProgressRoot !== null && updateExpirationTime > renderExpirationTime$1) {
              interruptedBy = fiberThatReceivedUpdate;
            }
          }
          var didWarnStateUpdateForUnmountedComponent = null;
          function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
            {
              var tag = fiber.tag;
              if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
                return;
              }
              var componentName = getComponentName(fiber.type) || "ReactComponent";
              if (didWarnStateUpdateForUnmountedComponent !== null) {
                if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForUnmountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForUnmountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              error("Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in %s.%s", tag === ClassComponent ? "the componentWillUnmount method" : "a useEffect cleanup function", getStackByFiberInDevAndProd(fiber));
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, expirationTime) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, expirationTime);
              } catch (originalError) {
                if (originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, expirationTime);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  throw replayError;
                } else {
                  throw originalError;
                }
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && (executionContext & RenderContext) !== NoContext) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentName(fiber.type) || "Unknown";
                      error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://fb.me/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          var IsThisRendererActing = {
            current: false
          };
          function warnIfNotScopedWithMatchingAct(fiber) {
            {
              if (IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
                error("It looks like you're using the wrong act() around your test interactions.\nBe sure to use the matching version of act() corresponding to your renderer:\n\n// for react-dom:\nimport {act} from 'react-dom/test-utils';\n// ...\nact(() => ...);\n\n// for react-test-renderer:\nimport TestRenderer from 'react-test-renderer';\nconst {act} = TestRenderer;\n// ...\nact(() => ...);%s", getStackByFiberInDevAndProd(fiber));
              }
            }
          }
          function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
            {
              if ((fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
                error("An update to %s ran an effect, but was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://fb.me/react-wrap-tests-with-act%s", getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));
              }
            }
          }
          function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
            {
              if (executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
                error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://fb.me/react-wrap-tests-with-act%s", getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));
              }
            }
          }
          var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;
          var didWarnAboutUnmockedScheduler = false;
          function warnIfUnmockedScheduler(fiber) {
            {
              if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === void 0) {
                if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
                  didWarnAboutUnmockedScheduler = true;
                  error(`In Concurrent or Sync modes, the "scheduler" module needs to be mocked to guarantee consistent behaviour across tests and browsers. For example, with jest: 
jest.mock('scheduler', () => require('scheduler/unstable_mock'));

For more info, visit https://fb.me/react-mock-scheduler`);
                }
              }
            }
          }
          function computeThreadID(root3, expirationTime) {
            return expirationTime * 1e3 + root3.interactionThreadID;
          }
          function markSpawnedWork(expirationTime) {
            if (spawnedWorkDuringRender === null) {
              spawnedWorkDuringRender = [expirationTime];
            } else {
              spawnedWorkDuringRender.push(expirationTime);
            }
          }
          function scheduleInteractions(root3, expirationTime, interactions) {
            if (interactions.size > 0) {
              var pendingInteractionMap = root3.pendingInteractionMap;
              var pendingInteractions = pendingInteractionMap.get(expirationTime);
              if (pendingInteractions != null) {
                interactions.forEach(function(interaction) {
                  if (!pendingInteractions.has(interaction)) {
                    interaction.__count++;
                  }
                  pendingInteractions.add(interaction);
                });
              } else {
                pendingInteractionMap.set(expirationTime, new Set(interactions));
                interactions.forEach(function(interaction) {
                  interaction.__count++;
                });
              }
              var subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null) {
                var threadID = computeThreadID(root3, expirationTime);
                subscriber.onWorkScheduled(interactions, threadID);
              }
            }
          }
          function schedulePendingInteractions(root3, expirationTime) {
            scheduleInteractions(root3, expirationTime, tracing.__interactionsRef.current);
          }
          function startWorkOnPendingInteractions(root3, expirationTime) {
            var interactions = /* @__PURE__ */ new Set();
            root3.pendingInteractionMap.forEach(function(scheduledInteractions, scheduledExpirationTime) {
              if (scheduledExpirationTime >= expirationTime) {
                scheduledInteractions.forEach(function(interaction) {
                  return interactions.add(interaction);
                });
              }
            });
            root3.memoizedInteractions = interactions;
            if (interactions.size > 0) {
              var subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null) {
                var threadID = computeThreadID(root3, expirationTime);
                try {
                  subscriber.onWorkStarted(interactions, threadID);
                } catch (error2) {
                  scheduleCallback(ImmediatePriority, function() {
                    throw error2;
                  });
                }
              }
            }
          }
          function finishPendingInteractions(root3, committedExpirationTime) {
            var earliestRemainingTimeAfterCommit = root3.firstPendingTime;
            var subscriber;
            try {
              subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null && root3.memoizedInteractions.size > 0) {
                var threadID = computeThreadID(root3, committedExpirationTime);
                subscriber.onWorkStopped(root3.memoizedInteractions, threadID);
              }
            } catch (error2) {
              scheduleCallback(ImmediatePriority, function() {
                throw error2;
              });
            } finally {
              var pendingInteractionMap = root3.pendingInteractionMap;
              pendingInteractionMap.forEach(function(scheduledInteractions, scheduledExpirationTime) {
                if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {
                  pendingInteractionMap.delete(scheduledExpirationTime);
                  scheduledInteractions.forEach(function(interaction) {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      try {
                        subscriber.onInteractionScheduledWorkCompleted(interaction);
                      } catch (error2) {
                        scheduleCallback(ImmediatePriority, function() {
                          throw error2;
                        });
                      }
                    }
                  });
                }
              });
            }
          }
          var onScheduleFiberRoot = null;
          var onCommitFiberRoot = null;
          var onCommitFiberUnmount = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://fb.me/react-devtools");
              }
              return true;
            }
            try {
              var rendererID = hook.inject(internals);
              if (true) {
                if (typeof hook.onScheduleFiberRoot === "function") {
                  onScheduleFiberRoot = function(root3, children2) {
                    try {
                      hook.onScheduleFiberRoot(rendererID, root3, children2);
                    } catch (err) {
                      if (!hasLoggedError) {
                        hasLoggedError = true;
                        error("React instrumentation encountered an error: %s", err);
                      }
                    }
                  };
                }
              }
              onCommitFiberRoot = function(root3, expirationTime) {
                try {
                  var didError = (root3.current.effectTag & DidCapture) === DidCapture;
                  if (enableProfilerTimer) {
                    var currentTime = getCurrentTime();
                    var priorityLevel = inferPriorityFromExpirationTime(currentTime, expirationTime);
                    hook.onCommitFiberRoot(rendererID, root3, priorityLevel, didError);
                  } else {
                    hook.onCommitFiberRoot(rendererID, root3, void 0, didError);
                  }
                } catch (err) {
                  if (true) {
                    if (!hasLoggedError) {
                      hasLoggedError = true;
                      error("React instrumentation encountered an error: %s", err);
                    }
                  }
                }
              };
              onCommitFiberUnmount = function(fiber) {
                try {
                  hook.onCommitFiberUnmount(rendererID, fiber);
                } catch (err) {
                  if (true) {
                    if (!hasLoggedError) {
                      hasLoggedError = true;
                      error("React instrumentation encountered an error: %s", err);
                    }
                  }
                }
              };
            } catch (err) {
              {
                error("React instrumentation encountered an error: %s.", err);
              }
            }
            return true;
          }
          function onScheduleRoot(root3, children2) {
            if (typeof onScheduleFiberRoot === "function") {
              onScheduleFiberRoot(root3, children2);
            }
          }
          function onCommitRoot(root3, expirationTime) {
            if (typeof onCommitFiberRoot === "function") {
              onCommitFiberRoot(root3, expirationTime);
            }
          }
          function onCommitUnmount(fiber) {
            if (typeof onCommitFiberUnmount === "function") {
              onCommitFiberUnmount(fiber);
            }
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              var testMap = /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              var testSet = /* @__PURE__ */ new Set([nonExtensibleObject]);
              testMap.set(0, 0);
              testSet.add(0);
            } catch (e) {
              hasBadMapPolyfill = true;
            }
          }
          var debugCounter = 1;
          function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.effectTag = NoEffect;
            this.nextEffect = null;
            this.firstEffect = null;
            this.lastEffect = null;
            this.expirationTime = NoWork;
            this.childExpirationTime = NoWork;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugID = debugCounter++;
              this._debugIsCurrentlyTiming = false;
            }
            {
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          };
          function shouldConstruct(Component6) {
            var prototype2 = Component6.prototype;
            return !!(prototype2 && prototype2.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component6) {
            if (typeof Component6 === "function") {
              return shouldConstruct(Component6) ? ClassComponent : FunctionComponent;
            } else if (Component6 !== void 0 && Component6 !== null) {
              var $$typeof = Component6.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                {
                  workInProgress2._debugID = current2._debugID;
                }
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.effectTag = NoEffect;
              workInProgress2.nextEffect = null;
              workInProgress2.firstEffect = null;
              workInProgress2.lastEffect = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.childExpirationTime = current2.childExpirationTime;
            workInProgress2.expirationTime = current2.expirationTime;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              expirationTime: currentDependencies.expirationTime,
              firstContext: currentDependencies.firstContext,
              responders: currentDependencies.responders
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderExpirationTime2) {
            workInProgress2.effectTag &= Placement;
            workInProgress2.nextEffect = null;
            workInProgress2.firstEffect = null;
            workInProgress2.lastEffect = null;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childExpirationTime = NoWork;
              workInProgress2.expirationTime = renderExpirationTime2;
              workInProgress2.child = null;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childExpirationTime = current2.childExpirationTime;
              workInProgress2.expirationTime = current2.expirationTime;
              workInProgress2.child = current2.child;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                expirationTime: currentDependencies.expirationTime,
                firstContext: currentDependencies.firstContext,
                responders: currentDependencies.responders
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag) {
            var mode;
            if (tag === ConcurrentRoot) {
              mode = ConcurrentMode | BlockingMode | StrictMode;
            } else if (tag === BlockingRoot) {
              mode = BlockingMode | StrictMode;
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime) {
            var fiber;
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag:
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);
                  case REACT_CONCURRENT_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= ConcurrentMode | BlockingMode | StrictMode;
                    break;
                  case REACT_STRICT_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= StrictMode;
                    break;
                  case REACT_PROFILER_TYPE:
                    return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
                  case REACT_SUSPENSE_TYPE:
                    return createFiberFromSuspense(pendingProps, mode, expirationTime, key);
                  case REACT_SUSPENSE_LIST_TYPE:
                    return createFiberFromSuspenseList(pendingProps, mode, expirationTime, key);
                  default: {
                    if (typeof type === "object" && type !== null) {
                      switch (type.$$typeof) {
                        case REACT_PROVIDER_TYPE:
                          fiberTag = ContextProvider;
                          break getTag;
                        case REACT_CONTEXT_TYPE:
                          fiberTag = ContextConsumer;
                          break getTag;
                        case REACT_FORWARD_REF_TYPE:
                          fiberTag = ForwardRef;
                          {
                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                          }
                          break getTag;
                        case REACT_MEMO_TYPE:
                          fiberTag = MemoComponent;
                          break getTag;
                        case REACT_LAZY_TYPE:
                          fiberTag = LazyComponent;
                          resolvedType = null;
                          break getTag;
                        case REACT_BLOCK_TYPE:
                          fiberTag = Block;
                          break getTag;
                      }
                    }
                    var info = "";
                    {
                      if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                        info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                      }
                      var ownerName = owner ? getComponentName(owner.type) : null;
                      if (ownerName) {
                        info += "\n\nCheck the render method of `" + ownerName + "`.";
                      }
                    }
                    {
                      {
                        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info);
                      }
                    }
                  }
                }
            }
            fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.expirationTime = expirationTime;
            return fiber;
          }
          function createFiberFromElement(element, mode, expirationTime) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode, expirationTime, key) {
            var fiber = createFiber(Fragment, elements, key, mode);
            fiber.expirationTime = expirationTime;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
            {
              if (typeof pendingProps.id !== "string" || typeof pendingProps.onRender !== "function") {
                error('Profiler must specify an "id" string and "onRender" function as props');
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.type = REACT_PROFILER_TYPE;
            fiber.expirationTime = expirationTime;
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.type = REACT_SUSPENSE_TYPE;
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.expirationTime = expirationTime;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, expirationTime, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            {
              fiber.type = REACT_SUSPENSE_LIST_TYPE;
            }
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.expirationTime = expirationTime;
            return fiber;
          }
          function createFiberFromText(content, mode, expirationTime) {
            var fiber = createFiber(HostText, content, null, mode);
            fiber.expirationTime = expirationTime;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            fiber.type = "DELETED";
            return fiber;
          }
          function createFiberFromPortal(portal2, mode, expirationTime) {
            var pendingProps = portal2.children !== null ? portal2.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal2.key, mode);
            fiber.expirationTime = expirationTime;
            fiber.stateNode = {
              containerInfo: portal2.containerInfo,
              pendingChildren: null,
              implementation: portal2.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.effectTag = source.effectTag;
            target.nextEffect = source.nextEffect;
            target.firstEffect = source.firstEffect;
            target.lastEffect = source.lastEffect;
            target.expirationTime = source.expirationTime;
            target.childExpirationTime = source.childExpirationTime;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            {
              target._debugID = source._debugID;
            }
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag, hydrate2) {
            this.tag = tag;
            this.current = null;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.pingCache = null;
            this.finishedExpirationTime = NoWork;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.hydrate = hydrate2;
            this.callbackNode = null;
            this.callbackPriority = NoPriority;
            this.firstPendingTime = NoWork;
            this.firstSuspendedTime = NoWork;
            this.lastSuspendedTime = NoWork;
            this.nextKnownPendingLevel = NoWork;
            this.lastPingedTime = NoWork;
            this.lastExpiredTime = NoWork;
            {
              this.interactionThreadID = tracing.unstable_getThreadID();
              this.memoizedInteractions = /* @__PURE__ */ new Set();
              this.pendingInteractionMap = /* @__PURE__ */ new Map();
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate2, hydrationCallbacks) {
            var root3 = new FiberRootNode(containerInfo, tag, hydrate2);
            var uninitializedFiber = createHostRootFiber(tag);
            root3.current = uninitializedFiber;
            uninitializedFiber.stateNode = root3;
            initializeUpdateQueue(uninitializedFiber);
            return root3;
          }
          function isRootSuspendedAtTime(root3, expirationTime) {
            var firstSuspendedTime = root3.firstSuspendedTime;
            var lastSuspendedTime = root3.lastSuspendedTime;
            return firstSuspendedTime !== NoWork && firstSuspendedTime >= expirationTime && lastSuspendedTime <= expirationTime;
          }
          function markRootSuspendedAtTime(root3, expirationTime) {
            var firstSuspendedTime = root3.firstSuspendedTime;
            var lastSuspendedTime = root3.lastSuspendedTime;
            if (firstSuspendedTime < expirationTime) {
              root3.firstSuspendedTime = expirationTime;
            }
            if (lastSuspendedTime > expirationTime || firstSuspendedTime === NoWork) {
              root3.lastSuspendedTime = expirationTime;
            }
            if (expirationTime <= root3.lastPingedTime) {
              root3.lastPingedTime = NoWork;
            }
            if (expirationTime <= root3.lastExpiredTime) {
              root3.lastExpiredTime = NoWork;
            }
          }
          function markRootUpdatedAtTime(root3, expirationTime) {
            var firstPendingTime = root3.firstPendingTime;
            if (expirationTime > firstPendingTime) {
              root3.firstPendingTime = expirationTime;
            }
            var firstSuspendedTime = root3.firstSuspendedTime;
            if (firstSuspendedTime !== NoWork) {
              if (expirationTime >= firstSuspendedTime) {
                root3.firstSuspendedTime = root3.lastSuspendedTime = root3.nextKnownPendingLevel = NoWork;
              } else if (expirationTime >= root3.lastSuspendedTime) {
                root3.lastSuspendedTime = expirationTime + 1;
              }
              if (expirationTime > root3.nextKnownPendingLevel) {
                root3.nextKnownPendingLevel = expirationTime;
              }
            }
          }
          function markRootFinishedAtTime(root3, finishedExpirationTime, remainingExpirationTime) {
            root3.firstPendingTime = remainingExpirationTime;
            if (finishedExpirationTime <= root3.lastSuspendedTime) {
              root3.firstSuspendedTime = root3.lastSuspendedTime = root3.nextKnownPendingLevel = NoWork;
            } else if (finishedExpirationTime <= root3.firstSuspendedTime) {
              root3.firstSuspendedTime = finishedExpirationTime - 1;
            }
            if (finishedExpirationTime <= root3.lastPingedTime) {
              root3.lastPingedTime = NoWork;
            }
            if (finishedExpirationTime <= root3.lastExpiredTime) {
              root3.lastExpiredTime = NoWork;
            }
          }
          function markRootExpiredAtTime(root3, expirationTime) {
            var lastExpiredTime = root3.lastExpiredTime;
            if (lastExpiredTime === NoWork || lastExpiredTime > expirationTime) {
              root3.lastExpiredTime = expirationTime;
            }
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get4(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component6 = fiber.type;
              if (isContextProvider(Component6)) {
                return processChildContext(fiber, Component6, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get4(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  {
                    {
                      throw Error("Unable to find node on an unmounted component.");
                    }
                  }
                } else {
                  {
                    {
                      throw Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
                    }
                  }
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictMode) {
                var componentName = getComponentName(fiber.type) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  if (fiber.mode & StrictMode) {
                    error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://fb.me/react-strict-mode-find-node%s", methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
                  } else {
                    error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://fb.me/react-strict-mode-find-node%s", methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrate2, hydrationCallbacks) {
            return createFiberRoot(containerInfo, tag, hydrate2);
          }
          function updateContainer(element, container, parentComponent, callback) {
            {
              onScheduleRoot(container, element);
            }
            var current$1 = container.current;
            var currentTime = requestCurrentTimeForUpdate();
            {
              if (typeof jest !== "undefined") {
                warnIfUnmockedScheduler(current$1);
                warnIfNotScopedWithMatchingAct(current$1);
              }
            }
            var suspenseConfig = requestCurrentSuspenseConfig();
            var expirationTime = computeExpirationForFiber(currentTime, current$1, suspenseConfig);
            var context2 = getContextForSubtree(parentComponent);
            if (container.context === null) {
              container.context = context2;
            } else {
              container.pendingContext = context2;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentName(current.type) || "Unknown");
              }
            }
            var update = createUpdate(expirationTime, suspenseConfig);
            update.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update.callback = callback;
            }
            enqueueUpdate(current$1, update);
            scheduleWork(current$1, expirationTime);
            return expirationTime;
          }
          function getPublicRootInstance(container) {
            var containerFiber = container.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function markRetryTimeImpl(fiber, retryTime) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              if (suspenseState.retryTime < retryTime) {
                suspenseState.retryTime = retryTime;
              }
            }
          }
          function markRetryTimeIfNotHydrated(fiber, retryTime) {
            markRetryTimeImpl(fiber, retryTime);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryTimeImpl(alternate, retryTime);
            }
          }
          function attemptUserBlockingHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var expTime = computeInteractiveExpiration(requestCurrentTimeForUpdate());
            scheduleWork(fiber, expTime);
            markRetryTimeIfNotHydrated(fiber, expTime);
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            scheduleWork(fiber, ContinuousHydration);
            markRetryTimeIfNotHydrated(fiber, ContinuousHydration);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var currentTime = requestCurrentTimeForUpdate();
            var expTime = computeExpirationForFiber(currentTime, fiber, null);
            scheduleWork(fiber, expTime);
            markRetryTimeIfNotHydrated(fiber, expTime);
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.tag === FundamentalComponent) {
              return hostFiber.stateNode.instance;
            }
            return hostFiber.stateNode;
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideProps = null;
          var scheduleUpdate = null;
          var setSuspenseHandler = null;
          {
            var copyWithSetImpl = function(obj, path, idx, value) {
              if (idx >= path.length) {
                return value;
              }
              var key = path[idx];
              var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            overrideHookState = function(fiber, id, path, value) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id > 0) {
                currentHook2 = currentHook2.next;
                id--;
              }
              if (currentHook2 !== null) {
                var newState = copyWithSet(currentHook2.memoizedState, path, value);
                currentHook2.memoizedState = newState;
                currentHook2.baseState = newState;
                fiber.memoizedProps = _assign({}, fiber.memoizedProps);
                scheduleWork(fiber, Sync);
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              scheduleWork(fiber, Sync);
            };
            scheduleUpdate = function(fiber) {
              scheduleWork(fiber, Sync);
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals(_assign({}, devToolsConfig, {
              overrideHookState,
              overrideProps,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber: function(fiber) {
                var hostFiber = findCurrentHostFiber(fiber);
                if (hostFiber === null) {
                  return null;
                }
                return hostFiber.stateNode;
              },
              findFiberByHostInstance: function(instance) {
                if (!findFiberByHostInstance) {
                  return null;
                }
                return findFiberByHostInstance(instance);
              },
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              getCurrentFiber: function() {
                return current;
              }
            }));
          }
          var IsSomeRendererActing$1 = ReactSharedInternals.IsSomeRendererActing;
          function ReactDOMRoot(container, options) {
            this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
          }
          function ReactDOMBlockingRoot(container, tag, options) {
            this._internalRoot = createRootImpl(container, tag, options);
          }
          ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(children2) {
            var root3 = this._internalRoot;
            {
              if (typeof arguments[1] === "function") {
                error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
              var container = root3.containerInfo;
              if (container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root3.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children2, root3, null, null);
          };
          ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root3 = this._internalRoot;
            var container = root3.containerInfo;
            updateContainer(null, root3, null, function() {
              unmarkContainerAsRoot(container);
            });
          };
          function createRootImpl(container, tag, options) {
            var hydrate2 = options != null && options.hydrate === true;
            var hydrationCallbacks = options != null && options.hydrationOptions || null;
            var root3 = createContainer(container, tag, hydrate2);
            markContainerAsRoot(root3.current, container);
            if (hydrate2 && tag !== LegacyRoot) {
              var doc = container.nodeType === DOCUMENT_NODE ? container : container.ownerDocument;
              eagerlyTrapReplayableEvents(container, doc);
            }
            return root3;
          }
          function createLegacyRoot(container, options) {
            return new ReactDOMBlockingRoot(container, LegacyRoot, options);
          }
          function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          var warnedAboutHydrateAPI = false;
          {
            topLevelUpdateWarnings = function(container) {
              if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container) {
            if (!container) {
              return null;
            }
            if (container.nodeType === DOCUMENT_NODE) {
              return container.documentElement;
            } else {
              return container.firstChild;
            }
          }
          function shouldHydrateDueToLegacyHeuristic(container) {
            var rootElement = getReactRootElementInContainer(container);
            return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
          }
          function legacyCreateRootFromDOMContainer(container, forceHydrate) {
            var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
            if (!shouldHydrate) {
              var warned = false;
              var rootSibling;
              while (rootSibling = container.lastChild) {
                {
                  if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
                    warned = true;
                    error("render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.");
                  }
                }
                container.removeChild(rootSibling);
              }
            }
            {
              if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
                warnedAboutHydrateAPI = true;
                warn("render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v17. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML.");
              }
            }
            return createLegacyRoot(container, shouldHydrate ? {
              hydrate: true
            } : void 0);
          }
          function warnOnInvalidCallback$1(callback, callerName) {
            {
              if (callback !== null && typeof callback !== "function") {
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children2, container, forceHydrate, callback) {
            {
              topLevelUpdateWarnings(container);
              warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
            }
            var root3 = container._reactRootContainer;
            var fiberRoot;
            if (!root3) {
              root3 = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
              fiberRoot = root3._internalRoot;
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(fiberRoot);
                  originalCallback.call(instance);
                };
              }
              unbatchedUpdates(function() {
                updateContainer(children2, fiberRoot, parentComponent, callback);
              });
            } else {
              fiberRoot = root3._internalRoot;
              if (typeof callback === "function") {
                var _originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(fiberRoot);
                  _originalCallback.call(instance);
                };
              }
              updateContainer(children2, fiberRoot, parentComponent, callback);
            }
            return getPublicRootInstance(fiberRoot);
          }
          function findDOMNode4(componentOrElement) {
            {
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate(element, container, callback) {
            if (!isValidContainer(container)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call createRoot(container, {hydrate: true}).render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
          }
          function render(element, container, callback) {
            if (!isValidContainer(container)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            if (!isValidContainer(containerNode)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            if (!(parentComponent != null && has(parentComponent))) {
              {
                throw Error("parentComponent must be a valid React Component");
              }
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
          }
          function unmountComponentAtNode(container) {
            if (!isValidContainer(container)) {
              {
                throw Error("unmountComponentAtNode(...): Target container is not a DOM element.");
              }
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
                if (renderedByDifferentReact) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              unbatchedUpdates(function() {
                legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                  container._reactRootContainer = null;
                  unmarkContainerAsRoot(container);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));
                var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          function createPortal2(children2, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            return {
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children: children2,
              containerInfo,
              implementation
            };
          }
          var ReactVersion = "16.14.0";
          setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          var didWarnAboutUnstableCreatePortal = false;
          {
            if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);
          function createPortal$1(children2, container) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            return createPortal2(children2, container, null, key);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
          }
          function unstable_createPortal(children2, container) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            {
              if (!didWarnAboutUnstableCreatePortal) {
                didWarnAboutUnstableCreatePortal = true;
                warn('The ReactDOM.unstable_createPortal() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactDOM.createPortal() instead. It has the exact same API, but without the "unstable_" prefix.');
              }
            }
            return createPortal$1(children2, container, key);
          }
          var Internals = {
            Events: [getInstanceFromNode$1, getNodeFromInstance$1, getFiberCurrentPropsFromNode$1, injectEventPluginsByName, eventNameDispatchConfigs, accumulateTwoPhaseDispatches, accumulateDirectDispatches, enqueueStateRestore, restoreStateIfNeeded, dispatchEvent, runEventsInBatch, flushPassiveEffects, IsThisRendererActing]
          };
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM3 && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol = window.location.protocol;
                if (/^(https?|file):$/.test(protocol)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://fb.me/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://fb.me/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports.createPortal = createPortal$1;
          exports.findDOMNode = findDOMNode4;
          exports.flushSync = flushSync;
          exports.hydrate = hydrate;
          exports.render = render;
          exports.unmountComponentAtNode = unmountComponentAtNode;
          exports.unstable_batchedUpdates = batchedUpdates$1;
          exports.unstable_createPortal = unstable_createPortal;
          exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports.version = ReactVersion;
        })();
      }
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module2) {
      "use strict";
      if (false) {
        checkDCE();
        module2.exports = null;
      } else {
        module2.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol2 = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol2 ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol2 ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol2 ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol2 ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol2 ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol2 ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol2 ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol2 ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol2 ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol2 ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol2 ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol2 ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol2 ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol2 ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol2 ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol2 ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol2 ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol2 ? Symbol.for("react.scope") : 60119;
          function isValidElementType2(type) {
            return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal2 = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal2;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType2;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/react-is/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_is_development();
      }
    }
  });

  // node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module2) {
      "use strict";
      var ReactIs = require_react_is();
      var assign2 = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var has = require_has();
      var checkPropTypes = require_checkPropTypes();
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module2.exports = function(isValidElement3, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bigint: createPrimitiveTypeChecker("bigint"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is(x, y) {
          if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function PropTypeError(message, data) {
          this.message = message;
          this.data = data && typeof data === "object" ? data : {};
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                  printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i = 0; i < propValue.length; i++) {
              var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement3(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for (var i = 0; i < expectedValues.length; i++) {
              if (is(propValue, expectedValues[i])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              var type = getPreciseType(value);
              if (type === "symbol") {
                return String(value);
              }
              return value;
            });
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has(propValue, key)) {
                var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                if (error instanceof Error) {
                  return error;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== "function") {
              printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate(props, propName, componentName, location, propFullName) {
            var expectedTypes = [];
            for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
              var checker2 = arrayOfTypeCheckers[i2];
              var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
              if (checkerResult == null) {
                return null;
              }
              if (checkerResult.data && has(checkerResult.data, "expectedType")) {
                expectedTypes.push(checkerResult.data.expectedType);
              }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createNodeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            if (!isNode2(props[propName])) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function invalidValidatorError(componentName, location, propFullName, key, type) {
          return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (typeof checker !== "function") {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign2({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (has(shapeTypes, key) && typeof checker !== "function") {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              if (!checker) {
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
              }
              var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function isNode2(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode2);
              }
              if (propValue === null || isValidElement3(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode2(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode2(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value) {
          var type = getPreciseType(value);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js"(exports, module2) {
      if (true) {
        ReactIs = require_react_is();
        throwOnDirectAccess = true;
        module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module2.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // node_modules/react-fast-compare/index.js
  var require_react_fast_compare = __commonJS({
    "node_modules/react-fast-compare/index.js"(exports, module2) {
      var hasElementType = typeof Element !== "undefined";
      var hasMap = typeof Map === "function";
      var hasSet = typeof Set === "function";
      var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
      function equal2(a, b) {
        if (a === b)
          return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor)
            return false;
          var length, i, keys;
          if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length)
              return false;
            for (i = length; i-- !== 0; )
              if (!equal2(a[i], b[i]))
                return false;
            return true;
          }
          var it;
          if (hasMap && a instanceof Map && b instanceof Map) {
            if (a.size !== b.size)
              return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!b.has(i.value[0]))
                return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!equal2(i.value[1], b.get(i.value[0])))
                return false;
            return true;
          }
          if (hasSet && a instanceof Set && b instanceof Set) {
            if (a.size !== b.size)
              return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!b.has(i.value[0]))
                return false;
            return true;
          }
          if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
            length = a.length;
            if (length != b.length)
              return false;
            for (i = length; i-- !== 0; )
              if (a[i] !== b[i])
                return false;
            return true;
          }
          if (a.constructor === RegExp)
            return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf)
            return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString)
            return a.toString() === b.toString();
          keys = Object.keys(a);
          length = keys.length;
          if (length !== Object.keys(b).length)
            return false;
          for (i = length; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
              return false;
          if (hasElementType && a instanceof Element)
            return false;
          for (i = length; i-- !== 0; ) {
            if ((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) {
              continue;
            }
            if (!equal2(a[keys[i]], b[keys[i]]))
              return false;
          }
          return true;
        }
        return a !== a && b !== b;
      }
      module2.exports = function isEqual2(a, b) {
        try {
          return equal2(a, b);
        } catch (error) {
          if ((error.message || "").match(/stack|recursion/i)) {
            console.warn("react-fast-compare cannot handle circular refs");
            return false;
          }
          throw error;
        }
      };
    }
  });

  // node_modules/react-router/node_modules/isarray/index.js
  var require_isarray = __commonJS({
    "node_modules/react-router/node_modules/isarray/index.js"(exports, module2) {
      module2.exports = Array.isArray || function(arr) {
        return Object.prototype.toString.call(arr) == "[object Array]";
      };
    }
  });

  // node_modules/react-router/node_modules/path-to-regexp/index.js
  var require_path_to_regexp = __commonJS({
    "node_modules/react-router/node_modules/path-to-regexp/index.js"(exports, module2) {
      var isarray = require_isarray();
      module2.exports = pathToRegexp2;
      module2.exports.parse = parse2;
      module2.exports.compile = compile;
      module2.exports.tokensToFunction = tokensToFunction;
      module2.exports.tokensToRegExp = tokensToRegExp;
      var PATH_REGEXP = new RegExp([
        "(\\\\.)",
        "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
      ].join("|"), "g");
      function parse2(str, options) {
        var tokens2 = [];
        var key = 0;
        var index2 = 0;
        var path = "";
        var defaultDelimiter = options && options.delimiter || "/";
        var res;
        while ((res = PATH_REGEXP.exec(str)) != null) {
          var m = res[0];
          var escaped = res[1];
          var offset = res.index;
          path += str.slice(index2, offset);
          index2 = offset + m.length;
          if (escaped) {
            path += escaped[1];
            continue;
          }
          var next = str[index2];
          var prefix2 = res[2];
          var name = res[3];
          var capture = res[4];
          var group = res[5];
          var modifier = res[6];
          var asterisk = res[7];
          if (path) {
            tokens2.push(path);
            path = "";
          }
          var partial = prefix2 != null && next != null && next !== prefix2;
          var repeat = modifier === "+" || modifier === "*";
          var optional = modifier === "?" || modifier === "*";
          var delimiter = res[2] || defaultDelimiter;
          var pattern = capture || group;
          tokens2.push({
            name: name || key++,
            prefix: prefix2 || "",
            delimiter,
            optional,
            repeat,
            partial,
            asterisk: !!asterisk,
            pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
          });
        }
        if (index2 < str.length) {
          path += str.substr(index2);
        }
        if (path) {
          tokens2.push(path);
        }
        return tokens2;
      }
      function compile(str, options) {
        return tokensToFunction(parse2(str, options), options);
      }
      function encodeURIComponentPretty(str) {
        return encodeURI(str).replace(/[\/?#]/g, function(c) {
          return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      function encodeAsterisk(str) {
        return encodeURI(str).replace(/[?#]/g, function(c) {
          return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      function tokensToFunction(tokens2, options) {
        var matches2 = new Array(tokens2.length);
        for (var i = 0; i < tokens2.length; i++) {
          if (typeof tokens2[i] === "object") {
            matches2[i] = new RegExp("^(?:" + tokens2[i].pattern + ")$", flags(options));
          }
        }
        return function(obj, opts) {
          var path = "";
          var data = obj || {};
          var options2 = opts || {};
          var encode = options2.pretty ? encodeURIComponentPretty : encodeURIComponent;
          for (var i2 = 0; i2 < tokens2.length; i2++) {
            var token = tokens2[i2];
            if (typeof token === "string") {
              path += token;
              continue;
            }
            var value = data[token.name];
            var segment;
            if (value == null) {
              if (token.optional) {
                if (token.partial) {
                  path += token.prefix;
                }
                continue;
              } else {
                throw new TypeError('Expected "' + token.name + '" to be defined');
              }
            }
            if (isarray(value)) {
              if (!token.repeat) {
                throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
              }
              if (value.length === 0) {
                if (token.optional) {
                  continue;
                } else {
                  throw new TypeError('Expected "' + token.name + '" to not be empty');
                }
              }
              for (var j = 0; j < value.length; j++) {
                segment = encode(value[j]);
                if (!matches2[i2].test(segment)) {
                  throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
                }
                path += (j === 0 ? token.prefix : token.delimiter) + segment;
              }
              continue;
            }
            segment = token.asterisk ? encodeAsterisk(value) : encode(value);
            if (!matches2[i2].test(segment)) {
              throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
            }
            path += token.prefix + segment;
          }
          return path;
        };
      }
      function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
      }
      function escapeGroup(group) {
        return group.replace(/([=!:$\/()])/g, "\\$1");
      }
      function attachKeys(re, keys) {
        re.keys = keys;
        return re;
      }
      function flags(options) {
        return options && options.sensitive ? "" : "i";
      }
      function regexpToRegexp(path, keys) {
        var groups = path.source.match(/\((?!\?)/g);
        if (groups) {
          for (var i = 0; i < groups.length; i++) {
            keys.push({
              name: i,
              prefix: null,
              delimiter: null,
              optional: false,
              repeat: false,
              partial: false,
              asterisk: false,
              pattern: null
            });
          }
        }
        return attachKeys(path, keys);
      }
      function arrayToRegexp(path, keys, options) {
        var parts = [];
        for (var i = 0; i < path.length; i++) {
          parts.push(pathToRegexp2(path[i], keys, options).source);
        }
        var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
        return attachKeys(regexp, keys);
      }
      function stringToRegexp(path, keys, options) {
        return tokensToRegExp(parse2(path, options), keys, options);
      }
      function tokensToRegExp(tokens2, keys, options) {
        if (!isarray(keys)) {
          options = keys || options;
          keys = [];
        }
        options = options || {};
        var strict = options.strict;
        var end = options.end !== false;
        var route = "";
        for (var i = 0; i < tokens2.length; i++) {
          var token = tokens2[i];
          if (typeof token === "string") {
            route += escapeString(token);
          } else {
            var prefix2 = escapeString(token.prefix);
            var capture = "(?:" + token.pattern + ")";
            keys.push(token);
            if (token.repeat) {
              capture += "(?:" + prefix2 + capture + ")*";
            }
            if (token.optional) {
              if (!token.partial) {
                capture = "(?:" + prefix2 + "(" + capture + "))?";
              } else {
                capture = prefix2 + "(" + capture + ")?";
              }
            } else {
              capture = prefix2 + "(" + capture + ")";
            }
            route += capture;
          }
        }
        var delimiter = escapeString(options.delimiter || "/");
        var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
        if (!strict) {
          route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
        }
        if (end) {
          route += "$";
        } else {
          route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
        }
        return attachKeys(new RegExp("^" + route, flags(options)), keys);
      }
      function pathToRegexp2(path, keys, options) {
        if (!isarray(keys)) {
          options = keys || options;
          keys = [];
        }
        options = options || {};
        if (path instanceof RegExp) {
          return regexpToRegexp(path, keys);
        }
        if (isarray(path)) {
          return arrayToRegexp(path, keys, options);
        }
        return stringToRegexp(path, keys, options);
      }
    }
  });

  // node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
  var require_hoist_non_react_statics_cjs = __commonJS({
    "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module2) {
      "use strict";
      var reactIs = require_react_is();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty(targetComponent, key, descriptor);
              } catch (e) {
              }
            }
          }
        }
        return targetComponent;
      }
      module2.exports = hoistNonReactStatics;
    }
  });

  // node_modules/@babel/runtime/helpers/classCallCheck.js
  var require_classCallCheck = __commonJS({
    "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module2) {
      function _classCallCheck23(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      module2.exports = _classCallCheck23;
    }
  });

  // node_modules/@babel/runtime/helpers/createClass.js
  var require_createClass = __commonJS({
    "node_modules/@babel/runtime/helpers/createClass.js"(exports, module2) {
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass23(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      module2.exports = _createClass23;
    }
  });

  // node_modules/@babel/runtime/helpers/typeof.js
  var require_typeof = __commonJS({
    "node_modules/@babel/runtime/helpers/typeof.js"(exports, module2) {
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          module2.exports = _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          module2.exports = _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      module2.exports = _typeof;
    }
  });

  // node_modules/@babel/runtime/helpers/assertThisInitialized.js
  var require_assertThisInitialized = __commonJS({
    "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module2) {
      function _assertThisInitialized16(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      module2.exports = _assertThisInitialized16;
    }
  });

  // node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
  var require_possibleConstructorReturn = __commonJS({
    "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module2) {
      var _typeof = require_typeof();
      var assertThisInitialized = require_assertThisInitialized();
      function _possibleConstructorReturn16(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return assertThisInitialized(self2);
      }
      module2.exports = _possibleConstructorReturn16;
    }
  });

  // node_modules/@babel/runtime/helpers/getPrototypeOf.js
  var require_getPrototypeOf = __commonJS({
    "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module2) {
      function _getPrototypeOf16(o) {
        module2.exports = _getPrototypeOf16 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf17(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf16(o);
      }
      module2.exports = _getPrototypeOf16;
    }
  });

  // node_modules/@babel/runtime/helpers/setPrototypeOf.js
  var require_setPrototypeOf = __commonJS({
    "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module2) {
      function _setPrototypeOf4(o, p) {
        module2.exports = _setPrototypeOf4 = Object.setPrototypeOf || function _setPrototypeOf5(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf4(o, p);
      }
      module2.exports = _setPrototypeOf4;
    }
  });

  // node_modules/@babel/runtime/helpers/inherits.js
  var require_inherits = __commonJS({
    "node_modules/@babel/runtime/helpers/inherits.js"(exports, module2) {
      var setPrototypeOf2 = require_setPrototypeOf();
      function _inherits16(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass)
          setPrototypeOf2(subClass, superClass);
      }
      module2.exports = _inherits16;
    }
  });

  // node_modules/@babel/runtime/helpers/defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module2) {
      function _defineProperty20(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      module2.exports = _defineProperty20;
    }
  });

  // node_modules/@babel/runtime/helpers/extends.js
  var require_extends = __commonJS({
    "node_modules/@babel/runtime/helpers/extends.js"(exports, module2) {
      function _extends10() {
        module2.exports = _extends10 = Object.assign || function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends10.apply(this, arguments);
      }
      module2.exports = _extends10;
    }
  });

  // node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
  var require_objectWithoutPropertiesLoose = __commonJS({
    "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module2) {
      function _objectWithoutPropertiesLoose4(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      module2.exports = _objectWithoutPropertiesLoose4;
    }
  });

  // node_modules/@babel/runtime/helpers/objectWithoutProperties.js
  var require_objectWithoutProperties = __commonJS({
    "node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module2) {
      var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
      function _objectWithoutProperties4(source, excluded) {
        if (source == null)
          return {};
        var target = objectWithoutPropertiesLoose(source, excluded);
        var key, i;
        if (Object.getOwnPropertySymbols) {
          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
          for (i = 0; i < sourceSymbolKeys.length; i++) {
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0)
              continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key))
              continue;
            target[key] = source[key];
          }
        }
        return target;
      }
      module2.exports = _objectWithoutProperties4;
    }
  });

  // node_modules/@babel/runtime/helpers/arrayLikeToArray.js
  var require_arrayLikeToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module2) {
      function _arrayLikeToArray3(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      module2.exports = _arrayLikeToArray3;
    }
  });

  // node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
  var require_arrayWithoutHoles = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module2) {
      var arrayLikeToArray = require_arrayLikeToArray();
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return arrayLikeToArray(arr);
      }
      module2.exports = _arrayWithoutHoles;
    }
  });

  // node_modules/@babel/runtime/helpers/iterableToArray.js
  var require_iterableToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module2) {
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
          return Array.from(iter);
      }
      module2.exports = _iterableToArray;
    }
  });

  // node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
  var require_unsupportedIterableToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module2) {
      var arrayLikeToArray = require_arrayLikeToArray();
      function _unsupportedIterableToArray3(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return arrayLikeToArray(o, minLen);
      }
      module2.exports = _unsupportedIterableToArray3;
    }
  });

  // node_modules/@babel/runtime/helpers/nonIterableSpread.js
  var require_nonIterableSpread = __commonJS({
    "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module2) {
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module2.exports = _nonIterableSpread;
    }
  });

  // node_modules/@babel/runtime/helpers/toConsumableArray.js
  var require_toConsumableArray = __commonJS({
    "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module2) {
      var arrayWithoutHoles = require_arrayWithoutHoles();
      var iterableToArray = require_iterableToArray();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableSpread = require_nonIterableSpread();
      function _toConsumableArray3(arr) {
        return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
      }
      module2.exports = _toConsumableArray3;
    }
  });

  // node_modules/@babel/runtime/helpers/arrayWithHoles.js
  var require_arrayWithHoles = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module2) {
      function _arrayWithHoles2(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      module2.exports = _arrayWithHoles2;
    }
  });

  // node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
  var require_iterableToArrayLimit = __commonJS({
    "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module2) {
      function _iterableToArrayLimit2(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      module2.exports = _iterableToArrayLimit2;
    }
  });

  // node_modules/@babel/runtime/helpers/nonIterableRest.js
  var require_nonIterableRest = __commonJS({
    "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module2) {
      function _nonIterableRest2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module2.exports = _nonIterableRest2;
    }
  });

  // node_modules/@babel/runtime/helpers/slicedToArray.js
  var require_slicedToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module2) {
      var arrayWithHoles = require_arrayWithHoles();
      var iterableToArrayLimit = require_iterableToArrayLimit();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableRest = require_nonIterableRest();
      function _slicedToArray3(arr, i) {
        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
      }
      module2.exports = _slicedToArray3;
    }
  });

  // node_modules/ts-invariant/node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/ts-invariant/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends4;
      var __assign4;
      var __rest4;
      var __decorate4;
      var __param4;
      var __metadata4;
      var __awaiter4;
      var __generator4;
      var __exportStar4;
      var __values4;
      var __read4;
      var __spread4;
      var __spreadArrays4;
      var __spreadArray4;
      var __await4;
      var __asyncGenerator4;
      var __asyncDelegator4;
      var __asyncValues4;
      var __makeTemplateObject4;
      var __importStar4;
      var __importDefault4;
      var __classPrivateFieldGet4;
      var __classPrivateFieldSet4;
      var __classPrivateFieldIn4;
      var __createBinding4;
      (function(factory) {
        var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root2, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root2, createExporter(module2.exports)));
        } else {
          factory(createExporter(root2));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root2) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends4 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __2() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
        };
        __assign4 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest4 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate4 = function(decorators, target, key, desc) {
          var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r2 = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
          return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
        };
        __param4 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata4 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter4 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result2) {
              result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator4 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar4 = function(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding4(o, m, p);
        };
        __createBinding4 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m[k];
            } };
          }
          Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values4 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read4 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r2, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
              ar.push(r2.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r2 && !r2.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread4 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read4(arguments[i]));
          return ar;
        };
        __spreadArrays4 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r2[k] = a[j];
          return r2;
        };
        __spreadArray4 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await4 = function(v) {
          return this instanceof __await4 ? (this.v = v, this) : new __await4(v);
        };
        __asyncGenerator4 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r2) {
            r2.value instanceof __await4 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator4 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await4(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues4 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values4 === "function" ? __values4(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject4 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar4 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result2 = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding4(result2, mod, k);
          }
          __setModuleDefault(result2, mod);
          return result2;
        };
        __importDefault4 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet4 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet4 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        __classPrivateFieldIn4 = function(state, receiver) {
          if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
            throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        };
        exporter("__extends", __extends4);
        exporter("__assign", __assign4);
        exporter("__rest", __rest4);
        exporter("__decorate", __decorate4);
        exporter("__param", __param4);
        exporter("__metadata", __metadata4);
        exporter("__awaiter", __awaiter4);
        exporter("__generator", __generator4);
        exporter("__exportStar", __exportStar4);
        exporter("__createBinding", __createBinding4);
        exporter("__values", __values4);
        exporter("__read", __read4);
        exporter("__spread", __spread4);
        exporter("__spreadArrays", __spreadArrays4);
        exporter("__spreadArray", __spreadArray4);
        exporter("__await", __await4);
        exporter("__asyncGenerator", __asyncGenerator4);
        exporter("__asyncDelegator", __asyncDelegator4);
        exporter("__asyncValues", __asyncValues4);
        exporter("__makeTemplateObject", __makeTemplateObject4);
        exporter("__importStar", __importStar4);
        exporter("__importDefault", __importDefault4);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet4);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet4);
        exporter("__classPrivateFieldIn", __classPrivateFieldIn4);
      });
    }
  });

  // node_modules/@apollo/client/node_modules/tslib/tslib.js
  var require_tslib2 = __commonJS({
    "node_modules/@apollo/client/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends4;
      var __assign4;
      var __rest4;
      var __decorate4;
      var __param4;
      var __metadata4;
      var __awaiter4;
      var __generator4;
      var __exportStar4;
      var __values4;
      var __read4;
      var __spread4;
      var __spreadArrays4;
      var __spreadArray4;
      var __await4;
      var __asyncGenerator4;
      var __asyncDelegator4;
      var __asyncValues4;
      var __makeTemplateObject4;
      var __importStar4;
      var __importDefault4;
      var __classPrivateFieldGet4;
      var __classPrivateFieldSet4;
      var __classPrivateFieldIn4;
      var __createBinding4;
      (function(factory) {
        var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root2, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root2, createExporter(module2.exports)));
        } else {
          factory(createExporter(root2));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root2) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends4 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __2() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
        };
        __assign4 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest4 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate4 = function(decorators, target, key, desc) {
          var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r2 = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
          return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
        };
        __param4 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata4 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter4 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result2) {
              result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator4 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar4 = function(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding4(o, m, p);
        };
        __createBinding4 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m[k];
            } };
          }
          Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values4 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read4 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r2, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
              ar.push(r2.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r2 && !r2.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread4 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read4(arguments[i]));
          return ar;
        };
        __spreadArrays4 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r2[k] = a[j];
          return r2;
        };
        __spreadArray4 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await4 = function(v) {
          return this instanceof __await4 ? (this.v = v, this) : new __await4(v);
        };
        __asyncGenerator4 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r2) {
            r2.value instanceof __await4 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator4 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await4(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues4 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values4 === "function" ? __values4(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject4 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar4 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result2 = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding4(result2, mod, k);
          }
          __setModuleDefault(result2, mod);
          return result2;
        };
        __importDefault4 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet4 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet4 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        __classPrivateFieldIn4 = function(state, receiver) {
          if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
            throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        };
        exporter("__extends", __extends4);
        exporter("__assign", __assign4);
        exporter("__rest", __rest4);
        exporter("__decorate", __decorate4);
        exporter("__param", __param4);
        exporter("__metadata", __metadata4);
        exporter("__awaiter", __awaiter4);
        exporter("__generator", __generator4);
        exporter("__exportStar", __exportStar4);
        exporter("__createBinding", __createBinding4);
        exporter("__values", __values4);
        exporter("__read", __read4);
        exporter("__spread", __spread4);
        exporter("__spreadArrays", __spreadArrays4);
        exporter("__spreadArray", __spreadArray4);
        exporter("__await", __await4);
        exporter("__asyncGenerator", __asyncGenerator4);
        exporter("__asyncDelegator", __asyncDelegator4);
        exporter("__asyncValues", __asyncValues4);
        exporter("__makeTemplateObject", __makeTemplateObject4);
        exporter("__importStar", __importStar4);
        exporter("__importDefault", __importDefault4);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet4);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet4);
        exporter("__classPrivateFieldIn", __classPrivateFieldIn4);
      });
    }
  });

  // node_modules/graphql-tag/node_modules/tslib/tslib.js
  var require_tslib3 = __commonJS({
    "node_modules/graphql-tag/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends4;
      var __assign4;
      var __rest4;
      var __decorate4;
      var __param4;
      var __metadata4;
      var __awaiter4;
      var __generator4;
      var __exportStar4;
      var __values4;
      var __read4;
      var __spread4;
      var __spreadArrays4;
      var __spreadArray4;
      var __await4;
      var __asyncGenerator4;
      var __asyncDelegator4;
      var __asyncValues4;
      var __makeTemplateObject4;
      var __importStar4;
      var __importDefault4;
      var __classPrivateFieldGet4;
      var __classPrivateFieldSet4;
      var __classPrivateFieldIn4;
      var __createBinding4;
      (function(factory) {
        var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root2, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root2, createExporter(module2.exports)));
        } else {
          factory(createExporter(root2));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root2) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends4 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __2() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
        };
        __assign4 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest4 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate4 = function(decorators, target, key, desc) {
          var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r2 = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
          return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
        };
        __param4 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata4 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter4 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result2) {
              result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator4 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar4 = function(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding4(o, m, p);
        };
        __createBinding4 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m[k];
            } };
          }
          Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values4 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read4 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r2, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
              ar.push(r2.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r2 && !r2.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread4 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read4(arguments[i]));
          return ar;
        };
        __spreadArrays4 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r2[k] = a[j];
          return r2;
        };
        __spreadArray4 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await4 = function(v) {
          return this instanceof __await4 ? (this.v = v, this) : new __await4(v);
        };
        __asyncGenerator4 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r2) {
            r2.value instanceof __await4 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator4 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await4(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues4 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values4 === "function" ? __values4(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject4 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar4 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result2 = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding4(result2, mod, k);
          }
          __setModuleDefault(result2, mod);
          return result2;
        };
        __importDefault4 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet4 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet4 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        __classPrivateFieldIn4 = function(state, receiver) {
          if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
            throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        };
        exporter("__extends", __extends4);
        exporter("__assign", __assign4);
        exporter("__rest", __rest4);
        exporter("__decorate", __decorate4);
        exporter("__param", __param4);
        exporter("__metadata", __metadata4);
        exporter("__awaiter", __awaiter4);
        exporter("__generator", __generator4);
        exporter("__exportStar", __exportStar4);
        exporter("__createBinding", __createBinding4);
        exporter("__values", __values4);
        exporter("__read", __read4);
        exporter("__spread", __spread4);
        exporter("__spreadArrays", __spreadArrays4);
        exporter("__spreadArray", __spreadArray4);
        exporter("__await", __await4);
        exporter("__asyncGenerator", __asyncGenerator4);
        exporter("__asyncDelegator", __asyncDelegator4);
        exporter("__asyncValues", __asyncValues4);
        exporter("__makeTemplateObject", __makeTemplateObject4);
        exporter("__importStar", __importStar4);
        exporter("__importDefault", __importDefault4);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet4);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet4);
        exporter("__classPrivateFieldIn", __classPrivateFieldIn4);
      });
    }
  });

  // node_modules/@shopify/polaris/build/esm/types.js
  var Key;
  (function(Key2) {
    Key2[Key2["Backspace"] = 8] = "Backspace";
    Key2[Key2["Tab"] = 9] = "Tab";
    Key2[Key2["Enter"] = 13] = "Enter";
    Key2[Key2["Shift"] = 16] = "Shift";
    Key2[Key2["Ctrl"] = 17] = "Ctrl";
    Key2[Key2["Alt"] = 18] = "Alt";
    Key2[Key2["Pause"] = 19] = "Pause";
    Key2[Key2["CapsLock"] = 20] = "CapsLock";
    Key2[Key2["Escape"] = 27] = "Escape";
    Key2[Key2["Space"] = 32] = "Space";
    Key2[Key2["PageUp"] = 33] = "PageUp";
    Key2[Key2["PageDown"] = 34] = "PageDown";
    Key2[Key2["End"] = 35] = "End";
    Key2[Key2["Home"] = 36] = "Home";
    Key2[Key2["LeftArrow"] = 37] = "LeftArrow";
    Key2[Key2["UpArrow"] = 38] = "UpArrow";
    Key2[Key2["RightArrow"] = 39] = "RightArrow";
    Key2[Key2["DownArrow"] = 40] = "DownArrow";
    Key2[Key2["Insert"] = 45] = "Insert";
    Key2[Key2["Delete"] = 46] = "Delete";
    Key2[Key2["Key0"] = 48] = "Key0";
    Key2[Key2["Key1"] = 49] = "Key1";
    Key2[Key2["Key2"] = 50] = "Key2";
    Key2[Key2["Key3"] = 51] = "Key3";
    Key2[Key2["Key4"] = 52] = "Key4";
    Key2[Key2["Key5"] = 53] = "Key5";
    Key2[Key2["Key6"] = 54] = "Key6";
    Key2[Key2["Key7"] = 55] = "Key7";
    Key2[Key2["Key8"] = 56] = "Key8";
    Key2[Key2["Key9"] = 57] = "Key9";
    Key2[Key2["KeyA"] = 65] = "KeyA";
    Key2[Key2["KeyB"] = 66] = "KeyB";
    Key2[Key2["KeyC"] = 67] = "KeyC";
    Key2[Key2["KeyD"] = 68] = "KeyD";
    Key2[Key2["KeyE"] = 69] = "KeyE";
    Key2[Key2["KeyF"] = 70] = "KeyF";
    Key2[Key2["KeyG"] = 71] = "KeyG";
    Key2[Key2["KeyH"] = 72] = "KeyH";
    Key2[Key2["KeyI"] = 73] = "KeyI";
    Key2[Key2["KeyJ"] = 74] = "KeyJ";
    Key2[Key2["KeyK"] = 75] = "KeyK";
    Key2[Key2["KeyL"] = 76] = "KeyL";
    Key2[Key2["KeyM"] = 77] = "KeyM";
    Key2[Key2["KeyN"] = 78] = "KeyN";
    Key2[Key2["KeyO"] = 79] = "KeyO";
    Key2[Key2["KeyP"] = 80] = "KeyP";
    Key2[Key2["KeyQ"] = 81] = "KeyQ";
    Key2[Key2["KeyR"] = 82] = "KeyR";
    Key2[Key2["KeyS"] = 83] = "KeyS";
    Key2[Key2["KeyT"] = 84] = "KeyT";
    Key2[Key2["KeyU"] = 85] = "KeyU";
    Key2[Key2["KeyV"] = 86] = "KeyV";
    Key2[Key2["KeyW"] = 87] = "KeyW";
    Key2[Key2["KeyX"] = 88] = "KeyX";
    Key2[Key2["KeyY"] = 89] = "KeyY";
    Key2[Key2["KeyZ"] = 90] = "KeyZ";
    Key2[Key2["LeftMeta"] = 91] = "LeftMeta";
    Key2[Key2["RightMeta"] = 92] = "RightMeta";
    Key2[Key2["Select"] = 93] = "Select";
    Key2[Key2["Numpad0"] = 96] = "Numpad0";
    Key2[Key2["Numpad1"] = 97] = "Numpad1";
    Key2[Key2["Numpad2"] = 98] = "Numpad2";
    Key2[Key2["Numpad3"] = 99] = "Numpad3";
    Key2[Key2["Numpad4"] = 100] = "Numpad4";
    Key2[Key2["Numpad5"] = 101] = "Numpad5";
    Key2[Key2["Numpad6"] = 102] = "Numpad6";
    Key2[Key2["Numpad7"] = 103] = "Numpad7";
    Key2[Key2["Numpad8"] = 104] = "Numpad8";
    Key2[Key2["Numpad9"] = 105] = "Numpad9";
    Key2[Key2["Multiply"] = 106] = "Multiply";
    Key2[Key2["Add"] = 107] = "Add";
    Key2[Key2["Subtract"] = 109] = "Subtract";
    Key2[Key2["Decimal"] = 110] = "Decimal";
    Key2[Key2["Divide"] = 111] = "Divide";
    Key2[Key2["F1"] = 112] = "F1";
    Key2[Key2["F2"] = 113] = "F2";
    Key2[Key2["F3"] = 114] = "F3";
    Key2[Key2["F4"] = 115] = "F4";
    Key2[Key2["F5"] = 116] = "F5";
    Key2[Key2["F6"] = 117] = "F6";
    Key2[Key2["F7"] = 118] = "F7";
    Key2[Key2["F8"] = 119] = "F8";
    Key2[Key2["F9"] = 120] = "F9";
    Key2[Key2["F10"] = 121] = "F10";
    Key2[Key2["F11"] = 122] = "F11";
    Key2[Key2["F12"] = 123] = "F12";
    Key2[Key2["NumLock"] = 144] = "NumLock";
    Key2[Key2["ScrollLock"] = 145] = "ScrollLock";
    Key2[Key2["Semicolon"] = 186] = "Semicolon";
    Key2[Key2["Equals"] = 187] = "Equals";
    Key2[Key2["Comma"] = 188] = "Comma";
    Key2[Key2["Dash"] = 189] = "Dash";
    Key2[Key2["Period"] = 190] = "Period";
    Key2[Key2["ForwardSlash"] = 191] = "ForwardSlash";
    Key2[Key2["GraveAccent"] = 192] = "GraveAccent";
    Key2[Key2["OpenBracket"] = 219] = "OpenBracket";
    Key2[Key2["BackSlash"] = 220] = "BackSlash";
    Key2[Key2["CloseBracket"] = 221] = "CloseBracket";
    Key2[Key2["SingleQuote"] = 222] = "SingleQuote";
  })(Key || (Key = {}));

  // node_modules/@shopify/polaris/build/esm/components/shared.js
  var scrollable = {
    props: {
      "data-polaris-scrollable": true
    },
    selector: "[data-polaris-scrollable]"
  };
  var overlay = {
    props: {
      "data-polaris-overlay": true
    },
    selector: "[data-polaris-overlay]"
  };
  var layer = {
    props: {
      "data-polaris-layer": true
    },
    selector: "[data-polaris-layer]"
  };
  var unstyled = {
    props: {
      "data-polaris-unstyled": true
    },
    selector: "[data-polaris-unstyled]"
  };
  var dataPolarisTopBar = {
    props: {
      "data-polaris-top-bar": true
    },
    selector: "[data-polaris-top-bar]"
  };
  var portal = {
    props: ["data-portal-id"],
    selector: "[data-portal-id]"
  };

  // node_modules/@shopify/polaris/build/esm/utilities/within-content-context.js
  var import_react = __toESM(require_react());
  var WithinContentContext = /* @__PURE__ */ (0, import_react.createContext)(false);

  // node_modules/@shopify/polaris/build/esm/components/AppProvider/AppProvider.js
  var import_react17 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/CustomProperties/CustomProperties.js
  var import_react2 = __toESM(require_react());
  var DEFAULT_COLOR_SCHEME = "light";
  function CustomProperties(props) {
    const {
      as: Component6 = "div",
      children: children2,
      className,
      colorScheme = DEFAULT_COLOR_SCHEME,
      style: style4
    } = props;
    if (true) {
      console.warn("Deprecation: The `CustomProperties` component has been deprecated. See the v10 migration guide for replacing dark color scheme styles. https://github.com/Shopify/polaris/blob/main/documentation/guides/migrating-from-v9-to-v10.md");
    }
    return /* @__PURE__ */ import_react2.default.createElement(Component6, {
      "p-color-scheme": colorScheme,
      className,
      style: {
        color: "var(--p-text)",
        ...style4
      }
    }, children2);
  }

  // node_modules/@shopify/polaris-tokens/dist/esm/token-groups/breakpoints.mjs
  var breakpoints = {
    "breakpoints-xs": {
      value: "0px"
    },
    "breakpoints-sm": {
      value: "490px"
    },
    "breakpoints-md": {
      value: "768px"
    },
    "breakpoints-lg": {
      value: "1040px"
    },
    "breakpoints-xl": {
      value: "1440px"
    }
  };

  // node_modules/@shopify/polaris-tokens/dist/esm/token-groups/depth.mjs
  var depth = {
    "shadow-transparent": {
      value: "0 0 0 0 transparent"
    },
    "shadow-faint": {
      value: "0 1px 0 0 rgba(22, 29, 37, 0.05)"
    },
    "shadow-base": {
      value: "0 0 0 1px rgba(63, 63, 68, 0.05), 0 1px 3px 0 rgba(63, 63, 68, 0.15)"
    },
    "shadow-deep": {
      value: "0 0 0 1px rgba(6, 44, 82, 0.1), 0 2px 16px rgba(33, 43, 54, 0.08)"
    },
    "shadow-button": {
      value: "0 1px 0 rgba(0, 0, 0, 0.05)"
    },
    "shadow-top-bar": {
      value: "0 2px 2px -1px rgba(0, 0, 0, 0.15)"
    },
    "shadow-card": {
      value: "0 0 5px rgba(23, 24, 24, 0.05), 0 1px 2px rgba(0, 0, 0, 0.15)"
    },
    "shadow-popover": {
      value: "0 3px 6px -3px rgba(23, 24, 24, 0.08), 0 8px 20px -4px rgba(23, 24, 24, 0.12)"
    },
    "shadow-layer": {
      value: "0 31px 41px 0 rgba(32, 42, 53, 0.2), 0 2px 16px 0 rgba(32, 42, 54, 0.08)"
    },
    "shadow-modal": {
      value: "0 26px 80px rgba(0, 0, 0, 0.2), 0 0px 1px rgba(0, 0, 0, 0.2)"
    },
    "shadows-inset-button": {
      value: "inset 0 -1px 0 rgba(0, 0, 0, 0.2)"
    },
    "shadows-inset-button-pressed": {
      value: "inset 0 1px 0 rgba(0, 0, 0, 0.15)"
    }
  };

  // node_modules/@shopify/polaris-tokens/dist/esm/token-groups/legacy.mjs
  var legacy = {
    "override-loading-z-index": {
      value: "514"
    },
    "choice-size": {
      value: "20px"
    },
    "icon-size-small": {
      value: "8px"
    },
    "icon-size-medium": {
      value: "20px"
    },
    "choice-margin": {
      value: "1px"
    },
    "control-border-width": {
      value: "2px"
    },
    "banner-border-default": {
      value: "inset 0 1px 0 0 var(--p-border-neutral-subdued), inset 0 0 0 1px var(--p-border-neutral-subdued)"
    },
    "banner-border-success": {
      value: "inset 0 1px 0 0 var(--p-border-success-subdued), inset 0 0 0 1px var(--p-border-success-subdued)"
    },
    "banner-border-highlight": {
      value: "inset 0 1px 0 0 var(--p-border-highlight-subdued), inset 0 0 0 1px var(--p-border-highlight-subdued)"
    },
    "banner-border-warning": {
      value: "inset 0 1px 0 0 var(--p-border-warning-subdued), inset 0 0 0 1px var(--p-border-warning-subdued)"
    },
    "banner-border-critical": {
      value: "inset 0 1px 0 0 var(--p-border-critical-subdued), inset 0 0 0 1px var(--p-border-critical-subdued)"
    },
    "thin-border-subdued": {
      value: "1px solid var(--p-border-subdued)"
    },
    "text-field-spinner-offset": {
      value: "2px"
    },
    "text-field-focus-ring-offset": {
      value: "-4px"
    },
    "button-group-item-spacing": {
      value: "-1px"
    },
    "range-slider-thumb-size-base": {
      value: "16px"
    },
    "range-slider-thumb-size-active": {
      value: "24px"
    },
    "frame-offset": {
      value: "0px"
    }
  };

  // node_modules/@shopify/polaris-tokens/dist/esm/token-groups/color.dark.mjs
  var colors = {
    background: {
      value: "rgba(11, 12, 13, 1)"
    },
    "background-hovered": {
      value: "rgba(11, 12, 13, 1)"
    },
    "background-pressed": {
      value: "rgba(11, 12, 13, 1)"
    },
    "background-selected": {
      value: "rgba(11, 12, 13, 1)"
    },
    surface: {
      value: "rgba(32, 33, 35, 1)"
    },
    "surface-neutral": {
      value: "rgba(49, 51, 53, 1)"
    },
    "surface-neutral-hovered": {
      value: "rgba(49, 51, 53, 1)"
    },
    "surface-neutral-pressed": {
      value: "rgba(49, 51, 53, 1)"
    },
    "surface-neutral-disabled": {
      value: "rgba(49, 51, 53, 1)"
    },
    "surface-neutral-subdued": {
      value: "rgba(68, 71, 74, 1)"
    },
    "surface-subdued": {
      value: "rgba(26, 28, 29, 1)"
    },
    "surface-disabled": {
      value: "rgba(26, 28, 29, 1)"
    },
    "surface-hovered": {
      value: "rgba(47, 49, 51, 1)"
    },
    "surface-pressed": {
      value: "rgba(62, 64, 67, 1)"
    },
    "surface-depressed": {
      value: "rgba(80, 83, 86, 1)"
    },
    "surface-search-field": {
      value: "rgba(47, 49, 51, 1)"
    },
    backdrop: {
      value: "rgba(0, 0, 0, 0.5)"
    },
    overlay: {
      value: "rgba(33, 33, 33, 0.5)"
    },
    "shadow-color-picker": {
      value: "rgba(0, 0, 0, 0)"
    },
    "shadow-color-picker-dragger": {
      value: "rgba(0, 0, 0, 0)"
    },
    "hint-from-direct-light": {
      value: "rgba(185, 185, 185, 0.2)"
    },
    border: {
      value: "rgba(80, 83, 86, 1)"
    },
    "border-neutral-subdued": {
      value: "rgba(130, 135, 139, 1)"
    },
    "border-hovered": {
      value: "rgba(80, 83, 86, 1)"
    },
    "border-disabled": {
      value: "rgba(103, 107, 111, 1)"
    },
    "border-subdued": {
      value: "rgba(130, 135, 139, 1)"
    },
    "border-depressed": {
      value: "rgba(142, 145, 145, 1)"
    },
    "border-shadow": {
      value: "rgba(91, 95, 98, 1)"
    },
    "border-shadow-subdued": {
      value: "rgba(130, 135, 139, 1)"
    },
    divider: {
      value: "rgba(69, 71, 73, 1)"
    },
    icon: {
      value: "rgba(166, 172, 178, 1)"
    },
    "icon-hovered": {
      value: "rgba(225, 227, 229, 1)"
    },
    "icon-pressed": {
      value: "rgba(166, 172, 178, 1)"
    },
    "icon-disabled": {
      value: "rgba(84, 87, 90, 1)"
    },
    "icon-subdued": {
      value: "rgba(120, 125, 129, 1)"
    },
    text: {
      value: "rgba(227, 229, 231, 1)"
    },
    "text-disabled": {
      value: "rgba(111, 115, 119, 1)"
    },
    "text-subdued": {
      value: "rgba(153, 159, 164, 1)"
    },
    interactive: {
      value: "rgba(54, 163, 255, 1)"
    },
    "interactive-disabled": {
      value: "rgba(38, 98, 182, 1)"
    },
    "interactive-hovered": {
      value: "rgba(103, 175, 255, 1)"
    },
    "interactive-pressed": {
      value: "rgba(136, 188, 255, 1)"
    },
    focused: {
      value: "rgba(38, 98, 182, 1)"
    },
    "surface-selected": {
      value: "rgba(2, 14, 35, 1)"
    },
    "surface-selected-hovered": {
      value: "rgba(7, 29, 61, 1)"
    },
    "surface-selected-pressed": {
      value: "rgba(13, 43, 86, 1)"
    },
    "icon-on-interactive": {
      value: "rgba(255, 255, 255, 1)"
    },
    "text-on-interactive": {
      value: "rgba(255, 255, 255, 1)"
    },
    "action-secondary": {
      value: "rgba(77, 80, 83, 1)"
    },
    "action-secondary-disabled": {
      value: "rgba(32, 34, 35, 1)"
    },
    "action-secondary-hovered": {
      value: "rgba(84, 87, 91, 1)"
    },
    "action-secondary-pressed": {
      value: "rgba(96, 100, 103, 1)"
    },
    "action-secondary-depressed": {
      value: "rgba(123, 127, 132, 1)"
    },
    "action-primary": {
      value: "rgba(0, 128, 96, 1)"
    },
    "action-primary-disabled": {
      value: "rgba(0, 86, 64, 1)"
    },
    "action-primary-hovered": {
      value: "rgba(0, 150, 113, 1)"
    },
    "action-primary-pressed": {
      value: "rgba(0, 164, 124, 1)"
    },
    "action-primary-depressed": {
      value: "rgba(0, 179, 136, 1)"
    },
    "icon-on-primary": {
      value: "rgba(230, 255, 244, 1)"
    },
    "text-on-primary": {
      value: "rgba(255, 255, 255, 1)"
    },
    "text-primary": {
      value: "rgba(0, 141, 106, 1)"
    },
    "text-primary-hovered": {
      value: "rgba(0, 158, 120, 1)"
    },
    "text-primary-pressed": {
      value: "rgba(0, 176, 133, 1)"
    },
    "surface-primary-selected": {
      value: "rgba(12, 18, 16, 1)"
    },
    "surface-primary-selected-hovered": {
      value: "rgba(40, 48, 44, 1)"
    },
    "surface-primary-selected-pressed": {
      value: "rgba(54, 64, 59, 1)"
    },
    "border-critical": {
      value: "rgba(227, 47, 14, 1)"
    },
    "border-critical-subdued": {
      value: "rgba(227, 47, 14, 1)"
    },
    "border-critical-disabled": {
      value: "rgba(131, 23, 4, 1)"
    },
    "icon-critical": {
      value: "rgba(218, 45, 13, 1)"
    },
    "surface-critical": {
      value: "rgba(69, 7, 1, 1)"
    },
    "surface-critical-subdued": {
      value: "rgba(69, 7, 1, 1)"
    },
    "surface-critical-subdued-hovered": {
      value: "rgba(68, 23, 20, 1)"
    },
    "surface-critical-subdued-pressed": {
      value: "rgba(107, 16, 3, 1)"
    },
    "surface-critical-subdued-depressed": {
      value: "rgba(135, 24, 5, 1)"
    },
    "text-critical": {
      value: "rgba(233, 128, 122, 1)"
    },
    "action-critical": {
      value: "rgba(205, 41, 12, 1)"
    },
    "action-critical-disabled": {
      value: "rgba(187, 37, 10, 1)"
    },
    "action-critical-hovered": {
      value: "rgba(227, 47, 14, 1)"
    },
    "action-critical-pressed": {
      value: "rgba(250, 53, 17, 1)"
    },
    "action-critical-depressed": {
      value: "rgba(253, 87, 73, 1)"
    },
    "icon-on-critical": {
      value: "rgba(255, 248, 247, 1)"
    },
    "text-on-critical": {
      value: "rgba(255, 255, 255, 1)"
    },
    "interactive-critical": {
      value: "rgba(253, 114, 106, 1)"
    },
    "interactive-critical-disabled": {
      value: "rgba(254, 172, 168, 1)"
    },
    "interactive-critical-hovered": {
      value: "rgba(253, 138, 132, 1)"
    },
    "interactive-critical-pressed": {
      value: "rgba(253, 159, 155, 1)"
    },
    "border-warning": {
      value: "rgba(153, 112, 0, 1)"
    },
    "border-warning-subdued": {
      value: "rgba(153, 112, 0, 1)"
    },
    "icon-warning": {
      value: "rgba(104, 75, 0, 1)"
    },
    "surface-warning": {
      value: "rgba(153, 112, 0, 1)"
    },
    "surface-warning-subdued": {
      value: "rgba(77, 59, 29, 1)"
    },
    "surface-warning-subdued-hovered": {
      value: "rgba(82, 63, 32, 1)"
    },
    "surface-warning-subdued-pressed": {
      value: "rgba(87, 67, 34, 1)"
    },
    "text-warning": {
      value: "rgba(202, 149, 0, 1)"
    },
    "border-highlight": {
      value: "rgba(68, 157, 167, 1)"
    },
    "border-highlight-subdued": {
      value: "rgba(68, 157, 167, 1)"
    },
    "icon-highlight": {
      value: "rgba(44, 108, 115, 1)"
    },
    "surface-highlight": {
      value: "rgba(0, 105, 113, 1)"
    },
    "surface-highlight-subdued": {
      value: "rgba(18, 53, 57, 1)"
    },
    "surface-highlight-subdued-hovered": {
      value: "rgba(20, 58, 62, 1)"
    },
    "surface-highlight-subdued-pressed": {
      value: "rgba(24, 65, 70, 1)"
    },
    "text-highlight": {
      value: "rgba(162, 239, 250, 1)"
    },
    "border-success": {
      value: "rgba(0, 135, 102, 1)"
    },
    "border-success-subdued": {
      value: "rgba(0, 135, 102, 1)"
    },
    "icon-success": {
      value: "rgba(0, 94, 70, 1)"
    },
    "surface-success": {
      value: "rgba(0, 94, 70, 1)"
    },
    "surface-success-subdued": {
      value: "rgba(28, 53, 44, 1)"
    },
    "surface-success-subdued-hovered": {
      value: "rgba(31, 58, 48, 1)"
    },
    "surface-success-subdued-pressed": {
      value: "rgba(35, 65, 54, 1)"
    },
    "text-success": {
      value: "rgba(88, 173, 142, 1)"
    },
    "icon-attention": {
      value: "rgba(138, 97, 22)"
    },
    "surface-attention": {
      value: "rgba(255, 234, 138)"
    },
    "decorative-one-icon": {
      value: "rgba(255, 186, 67, 1)"
    },
    "decorative-one-surface": {
      value: "rgba(142, 102, 9, 1)"
    },
    "decorative-one-text": {
      value: "rgba(255, 255, 255, 1)"
    },
    "decorative-two-icon": {
      value: "rgba(245, 182, 192, 1)"
    },
    "decorative-two-surface": {
      value: "rgba(206, 88, 20, 1)"
    },
    "decorative-two-text": {
      value: "rgba(255, 255, 255, 1)"
    },
    "decorative-three-icon": {
      value: "rgba(0, 227, 141, 1)"
    },
    "decorative-three-surface": {
      value: "rgba(0, 124, 90, 1)"
    },
    "decorative-three-text": {
      value: "rgba(255, 255, 255, 1)"
    },
    "decorative-four-icon": {
      value: "rgba(0, 221, 218, 1)"
    },
    "decorative-four-surface": {
      value: "rgba(22, 124, 121, 1)"
    },
    "decorative-four-text": {
      value: "rgba(255, 255, 255, 1)"
    },
    "decorative-five-icon": {
      value: "rgba(244, 183, 191, 1)"
    },
    "decorative-five-surface": {
      value: "rgba(194, 51, 86, 1)"
    },
    "decorative-five-text": {
      value: "rgba(255, 255, 255, 1)"
    }
  };

  // node_modules/@shopify/polaris-tokens/dist/esm/token-groups/color.light.mjs
  var colors2 = {
    background: {
      value: "rgba(246, 246, 247, 1)",
      description: "For use as a background color, in components such as Page and Frame backgrounds."
    },
    "background-hovered": {
      value: "rgba(241, 242, 243, 1)",
      description: "For use when an action or navigation is used on a background."
    },
    "background-pressed": {
      value: "rgba(237, 238, 239, 1)",
      description: "For use when an action or navigation is used on a background."
    },
    "background-selected": {
      value: "rgba(237, 238, 239, 1)",
      description: "For use in the selected item in navigation"
    },
    surface: {
      value: "rgba(255, 255, 255, 1)",
      description: "For use as a background color, in components such as Card, Modal, and Popover."
    },
    "surface-dark": {
      value: "rgba(32, 33, 35, 1)",
      description: "For use as a dark background color, in components such as Card, Modal, and Popover."
    },
    "surface-neutral": {
      value: "rgba(228, 229, 231, 1)",
      description: "For use as a background color in neutral badges."
    },
    "surface-neutral-hovered": {
      value: "rgba(219, 221, 223, 1)",
      description: "For use as a hovered background color in neutral badges."
    },
    "surface-neutral-pressed": {
      value: "rgba(201, 204, 208, 1)",
      description: "For use as a pressed background color in neutral badges."
    },
    "surface-neutral-disabled": {
      value: "rgba(241, 242, 243, 1)",
      description: "For use as a disabled background color in neutral badges."
    },
    "surface-neutral-subdued": {
      value: "rgba(246, 246, 247, 1)",
      description: "For use as a background color in neutral banners."
    },
    "surface-neutral-subdued-dark": {
      value: "rgba(68, 71, 74, 1)",
      description: "For use as a dark background color in neutral banners."
    },
    "surface-subdued": {
      value: "rgba(250, 251, 251, 1)",
      description: "For use as a subdued background color, in components such as Card, Modal, and Popover."
    },
    "surface-disabled": {
      value: "rgba(250, 251, 251, 1)",
      description: "For use as a surface color on disabled interactive elements such as option list items and action list items when in a disabled state."
    },
    "surface-hovered": {
      value: "rgba(246, 246, 247, 1)",
      description: "For use as a surface color on interactive elements such as resource list items and action list items when in a hovered state."
    },
    "surface-hovered-dark": {
      value: "rgba(47, 49, 51, 1)",
      description: "For use as a dark surface color on interactive elements such as resource list items and action list items when in a hovered state."
    },
    "surface-pressed": {
      value: "rgba(241, 242, 243, 1)",
      description: "For use as a surface color on interactive elements such as resource list items and action list items when in a pressed state."
    },
    "surface-pressed-dark": {
      value: "rgba(62, 64, 67, 1)",
      description: "For use as a dark surface color on interactive elements such as resource list items and action list items when in a pressed state."
    },
    "surface-depressed": {
      value: "rgba(237, 238, 239, 1)",
      description: "For use as a surface color on interactive elements such as resource list items and action list items when in a depressed state."
    },
    "surface-search-field": {
      value: "rgba(241, 242, 243, 1)",
      description: "For use as a background color, in components on surface elements such as SearchField"
    },
    "surface-search-field-dark": {
      value: "rgba(47, 49, 51, 1)",
      description: "For use as a dark background color, in components on surface elements such as SearchField"
    },
    backdrop: {
      value: "rgba(0, 0, 0, 0.5)",
      description: "For use as the background color of the backdrop component for navigation and modal. This color has an alpha of `0.5`."
    },
    overlay: {
      value: "rgba(255, 255, 255, 0.5)",
      description: "For use as the background color of elements which lay on top of surfaces to obscure their contents. This color has an alpha of `0.5`."
    },
    "shadow-color-picker": {
      value: "rgba(0, 0, 0, 0.5)"
    },
    "shadow-color-picker-dragger": {
      value: "rgba(33, 43, 54, 0.32)"
    },
    "hint-from-direct-light": {
      value: "rgba(0, 0, 0, 0.15)",
      description: "For use in building shadows scrollables."
    },
    border: {
      value: "rgba(140, 145, 150, 1)",
      description: "For use as the default border on elements."
    },
    "border-on-dark": {
      value: "rgba(80, 83, 86, 1)",
      description: "For use as the default border on dark elements."
    },
    "border-neutral-subdued": {
      value: "rgba(186, 191, 195, 1)",
      description: "For use as the border on banners."
    },
    "border-hovered": {
      value: "rgba(153, 158, 164, 1)",
      description: "Used for borders on hovered interactive elements"
    },
    "border-disabled": {
      value: "rgba(210, 213, 216, 1)",
      description: "Used for disabled borders on interactive elements"
    },
    "border-subdued": {
      value: "rgba(201, 204, 207, 1)",
      description: "For use as a subdued border on elements."
    },
    "border-depressed": {
      value: "rgba(87, 89, 89, 1)",
      description: "For use as a border on depressed elements."
    },
    "border-shadow": {
      value: "rgba(174, 180, 185, 1)",
      description: "For use as an additional bottom border on elements."
    },
    "border-shadow-subdued": {
      value: "rgba(186, 191, 196, 1)",
      description: "For use as an additional, subdued bottom border on elements."
    },
    divider: {
      value: "rgba(225, 227, 229, 1)",
      description: "For use as a divider between elements."
    },
    "divider-dark": {
      value: "rgba(69, 71, 73, 1)",
      description: "For use as a dark divider between elements."
    },
    icon: {
      value: "rgba(92, 95, 98, 1)",
      description: "For use as the fill color of icons."
    },
    "icon-on-dark": {
      value: "rgba(166, 172, 178, 1)",
      description: "For use as the fill color of dark icons."
    },
    "icon-hovered": {
      value: "rgba(26, 28, 29, 1)",
      description: "For use as the fill color of hovered icons."
    },
    "icon-pressed": {
      value: "rgba(68, 71, 74, 1)",
      description: "For use as the fill color of pressed icons."
    },
    "icon-disabled": {
      value: "rgba(186, 190, 195, 1)",
      description: "For use as the fill color of disabled icons."
    },
    "icon-subdued": {
      value: "rgba(140, 145, 150, 1)",
      description: "For use as the fill color of subdued icons."
    },
    text: {
      value: "rgba(32, 34, 35, 1)",
      description: "For use as a text color."
    },
    "text-on-dark": {
      value: "rgba(227, 229, 231, 1)",
      description: "For use as a text color on dark elements."
    },
    "text-disabled": {
      value: "rgba(140, 145, 150, 1)",
      description: "For use as a disabled text color and as a placeholder text color."
    },
    "text-subdued": {
      value: "rgba(109, 113, 117, 1)",
      description: "For use as a subdued text color."
    },
    "text-subdued-on-dark": {
      value: "rgba(153, 159, 164, 1)",
      description: "For use as a subdued text color on dark elements."
    },
    interactive: {
      value: "rgba(44, 110, 203, 1)",
      description: "Used for links, plain buttons, and as the fill color for selected checkboxes and radio buttons."
    },
    "interactive-on-dark": {
      value: "rgba(54, 163, 255, 1)",
      description: "Used for links, plain buttons, and as the fill color for selected checkboxes and radio buttons when on a dark element."
    },
    "interactive-disabled": {
      value: "rgba(189, 193, 204, 1)",
      description: "Used for disabled links and plain buttons."
    },
    "interactive-hovered": {
      value: "rgba(31, 81, 153, 1)",
      description: "Used for hovered links and plain buttons."
    },
    "interactive-pressed": {
      value: "rgba(16, 50, 98, 1)",
      description: "Used for pressed links and plain buttons."
    },
    "interactive-pressed-on-dark": {
      value: "rgba(136, 188, 255, 1)",
      description: "Used for pressed links and plain buttons on dark elements."
    },
    focused: {
      value: "rgba(69, 143, 255, 1)",
      description: "For use in the focus ring on interactive elements."
    },
    "surface-selected": {
      value: "rgba(242, 247, 254, 1)",
      description: "For use as a surface color in selected interactive elements, in components such as action list and resource list."
    },
    "surface-selected-hovered": {
      value: "rgba(237, 244, 254, 1)",
      description: "For use as a surface color in selected interactive elements that are hovered, in components such as action list and resource list."
    },
    "surface-selected-pressed": {
      value: "rgba(229, 239, 253, 1)",
      description: "For use as a surface color in selected interactive elements that are pressed, in components such as action list and resource list."
    },
    "icon-on-interactive": {
      value: "rgba(255, 255, 255, 1)",
      description: "For use as a fill color for icons on interactive elements."
    },
    "text-on-interactive": {
      value: "rgba(255, 255, 255, 1)",
      description: "For use as a text color on interactive elements."
    },
    "action-secondary": {
      value: "rgba(255, 255, 255, 1)",
      description: "Used for secondary buttons and tertiary buttons, as well as in form elements as a background color and pontentially other secondary surfaces."
    },
    "action-secondary-disabled": {
      value: "rgba(255, 255, 255, 1)",
      description: "Used as a disabled state for secondary buttons"
    },
    "action-secondary-hovered": {
      value: "rgba(246, 246, 247, 1)",
      description: "Used as a hovered state for secondary buttons"
    },
    "action-secondary-hovered-dark": {
      value: "rgba(84, 87, 91, 1)",
      description: "Used as a dark hovered state for secondary buttons"
    },
    "action-secondary-pressed": {
      value: "rgba(241, 242, 243, 1)",
      description: "Used as a pressed state for secondary buttons"
    },
    "action-secondary-pressed-dark": {
      value: "rgba(96, 100, 103, 1)",
      description: "Used as a dark pressed state for secondary buttons"
    },
    "action-secondary-depressed": {
      value: "rgba(109, 113, 117, 1)",
      description: "Used as a depressed state for secondary buttons"
    },
    "action-primary": {
      value: "rgba(0, 128, 96, 1)",
      description: "Used as the background color for primary actions, and as the fill color for icons and the text color in navigation and tabs to communicate interaction states."
    },
    "action-primary-disabled": {
      value: "rgba(241, 241, 241, 1)",
      description: "Used as the background color for disabled primary actions, and as the fill color for icons and the text color in navigation and tabs to communicate interaction states."
    },
    "action-primary-hovered": {
      value: "rgba(0, 110, 82, 1)",
      description: "Used as the background color for hovered primary actions, and as the fill color for icons and the text color in navigation and tabs to communicate interaction states."
    },
    "action-primary-pressed": {
      value: "rgba(0, 94, 70, 1)",
      description: "Used as the background color for pressed primary actions, and as the fill color for icons and the text color in navigation and tabs to communicate interaction states."
    },
    "action-primary-depressed": {
      value: "rgba(0, 61, 44, 1)",
      description: "Used as the background color for pressed primary actions, and as the fill color for icons and the text color in navigation and tabs to communicate interaction states."
    },
    "icon-on-primary": {
      value: "rgba(255, 255, 255, 1)",
      description: "For use as a fill color for icons on primary actions. Not for use in icons on navigation and tabs."
    },
    "text-on-primary": {
      value: "rgba(255, 255, 255, 1)",
      description: "For use as a text color on primary actions. Not for use in text on navigation and tabs."
    },
    "text-primary": {
      value: "rgba(0, 123, 92, 1)",
      description: "For use as primary text color on background. For use in text in components such as Navigation."
    },
    "text-primary-hovered": {
      value: "rgba(0, 108, 80, 1)",
      description: "For use as primary hovered text color on background. For use in text in components such as Navigation."
    },
    "text-primary-pressed": {
      value: "rgba(0, 92, 68, 1)",
      description: "For use as primary pressed text color on background. For use in text in components such as Navigation."
    },
    "surface-primary-selected": {
      value: "rgba(241, 248, 245, 1)",
      description: "Used as a surface color to indicate selected interactive states in navigation and tabs."
    },
    "surface-primary-selected-hovered": {
      value: "rgba(179, 208, 195, 1)",
      description: "Used as a surface color to indicate selected interactive states that are hovered in navigation and tabs."
    },
    "surface-primary-selected-pressed": {
      value: "rgba(162, 188, 176, 1)",
      description: "Used as a surface color to indicate selected interactive states that are pressed in navigation and tabs."
    },
    "border-critical": {
      value: "rgba(253, 87, 73, 1)",
      description: "For use as a border on critical components such as an outline on interactive elements in an error state."
    },
    "border-critical-subdued": {
      value: "rgba(224, 179, 178, 1)",
      description: "For use as a border on critical components such as banners."
    },
    "border-critical-disabled": {
      value: "rgba(255, 167, 163, 1)",
      description: "For use as a disabled border on critical components such as banners, and as an outline on interactive elements in an error state."
    },
    "icon-critical": {
      value: "rgba(215, 44, 13, 1)",
      description: "For use as an icon fill color on top of critical elements."
    },
    "surface-critical": {
      value: "rgba(254, 211, 209, 1)",
      description: "For use as a surface color on critical elements including badges."
    },
    "surface-critical-subdued": {
      value: "rgba(255, 244, 244, 1)",
      description: "For use as a subdued surface color on critical elements including banners."
    },
    "surface-critical-subdued-hovered": {
      value: "rgba(255, 240, 240, 1)",
      description: "For use as a surface color on critical interactive elements including action list items in a hovered state."
    },
    "surface-critical-subdued-pressed": {
      value: "rgba(255, 233, 232, 1)",
      description: "For use as a surface color on critical interactive elements including action list items in a pressed state."
    },
    "surface-critical-subdued-depressed": {
      value: "rgba(254, 188, 185, 1)",
      description: "For use as a surface color on critical interactive elements including action list items in a depressed state."
    },
    "text-critical": {
      value: "rgba(215, 44, 13, 1)",
      description: "For use as a text color in inert critical elements such as exception list. Not for use as a text color on banners and badges."
    },
    "action-critical": {
      value: "rgba(216, 44, 13, 1)",
      description: "For use as the background color for destructive buttons, and as the background color for error toast messages."
    },
    "action-critical-disabled": {
      value: "rgba(241, 241, 241, 1)",
      description: "For use as the background color for disabled destructive buttons, and as the background color for error toast messages."
    },
    "action-critical-hovered": {
      value: "rgba(188, 34, 0, 1)",
      description: "For use as the background color for hovered destructive buttons, and as the background color for error toast messages."
    },
    "action-critical-pressed": {
      value: "rgba(162, 27, 0, 1)",
      description: "For use as the background color for pressed destructive buttons, and as the background color for error toast messages."
    },
    "action-critical-depressed": {
      value: "rgba(108, 15, 0, 1)",
      description: "For use as the background color for depressed destructive buttons, and as the background color for error toast messages."
    },
    "icon-on-critical": {
      value: "rgba(255, 255, 255, 1)",
      description: "For use as a fill color for icons on critical actions."
    },
    "text-on-critical": {
      value: "rgba(255, 255, 255, 1)",
      description: "For use as a text color on critical actions."
    },
    "interactive-critical": {
      value: "rgba(216, 44, 13, 1)",
      description: "For use as the text color for destructive interactive elements: links, plain buttons, error state of selected checkboxes and radio buttons, as well as a text color on destructive action list items. Not for use on critical banners and badges."
    },
    "interactive-critical-disabled": {
      value: "rgba(253, 147, 141, 1)",
      description: "For use as a text color in disabled destructive plain buttons, as well as a text color on destructive action list items. Not for use on critical banners and badges."
    },
    "interactive-critical-hovered": {
      value: "rgba(205, 41, 12, 1)",
      description: "For use as a text color in hovered destructive plain buttons, as well as a text color on destructive action list items. Not for use on critical banners and badges."
    },
    "interactive-critical-pressed": {
      value: "rgba(103, 15, 3, 1)",
      description: "For use as a text color in pressed destructive plain buttons, as well as a text color on destructive action list items. Not for use on critical banners and badges."
    },
    "border-warning": {
      value: "rgba(185, 137, 0, 1)",
      description: "For use as a border on warning components such as..."
    },
    "border-warning-subdued": {
      value: "rgba(225, 184, 120, 1)",
      description: "For use as a border on warning components such as banners."
    },
    "icon-warning": {
      value: "rgba(185, 137, 0, 1)",
      description: "For use as an icon fill color on top of warning elements."
    },
    "surface-warning": {
      value: "rgba(255, 215, 157, 1)",
      description: "For use as a surface color on warning elements including badges."
    },
    "surface-warning-subdued": {
      value: "rgba(255, 245, 234, 1)",
      description: "For use as a subdued surface color on warning elements including banners."
    },
    "surface-warning-subdued-hovered": {
      value: "rgba(255, 242, 226, 1)",
      description: "For use as a subdued surface color on warning elements including banners."
    },
    "surface-warning-subdued-pressed": {
      value: "rgba(255, 235, 211, 1)",
      description: "For use as a subdued surface color on warning elements including banners."
    },
    "text-warning": {
      value: "rgba(145, 106, 0, 1)",
      description: "For use as a text color in inert critical elements such as exception list. Not for use as a text color on banners and badges."
    },
    "border-highlight": {
      value: "rgba(68, 157, 167, 1)",
      description: "For use as a border on informational components such as..."
    },
    "border-highlight-subdued": {
      value: "rgba(152, 198, 205, 1)",
      description: "For use as a border on informational components such as banners."
    },
    "icon-highlight": {
      value: "rgba(0, 160, 172, 1)",
      description: "For use as an icon fill color on top of informational elements."
    },
    "surface-highlight": {
      value: "rgba(164, 232, 242, 1)",
      description: "For use as a surface color on information elements including badges."
    },
    "surface-highlight-subdued": {
      value: "rgba(235, 249, 252, 1)",
      description: "For use as a surface color on information elements including banners."
    },
    "surface-highlight-subdued-hovered": {
      value: "rgba(228, 247, 250, 1)",
      description: "For use as a surface color on information elements including banners."
    },
    "surface-highlight-subdued-pressed": {
      value: "rgba(213, 243, 248, 1)",
      description: "For use as a surface color on information elements including banners."
    },
    "text-highlight": {
      value: "rgba(52, 124, 132, 1)",
      description: "For use as a text color in inert informational elements. Not for use as a text color on banners and badges."
    },
    "border-success": {
      value: "rgba(0, 164, 124, 1)",
      description: "For use as a border on success components such as text inputs."
    },
    "border-success-subdued": {
      value: "rgba(149, 201, 180, 1)",
      description: "For use as a border on success components such as banners."
    },
    "icon-success": {
      value: "rgba(0, 127, 95, 1)",
      description: "For use as an icon fill color on top of success elements."
    },
    "surface-success": {
      value: "rgba(174, 233, 209, 1)",
      description: "For use as a surface color on success elements including badges."
    },
    "surface-success-subdued": {
      value: "rgba(241, 248, 245, 1)",
      description: "For use as a surface color on information elements including banners."
    },
    "surface-success-subdued-hovered": {
      value: "rgba(236, 246, 241, 1)",
      description: "For use as a surface color on information elements including banners."
    },
    "surface-success-subdued-pressed": {
      value: "rgba(226, 241, 234, 1)",
      description: "For use as a surface color on information elements including banners."
    },
    "text-success": {
      value: "rgba(0, 128, 96, 1)",
      description: "For use as a text color in inert success elements. Not for use as a text color on banners and badges."
    },
    "icon-attention": {
      value: "rgba(138, 97, 22)"
    },
    "surface-attention": {
      value: "rgba(255, 234, 138)"
    },
    "decorative-one-icon": {
      value: "rgba(126, 87, 0, 1)",
      description: "For use as a decorative icon color that is applied on a decorative surface."
    },
    "decorative-one-surface": {
      value: "rgba(255, 201, 107, 1)",
      description: "For use as a decorative surface color."
    },
    "decorative-one-text": {
      value: "rgba(61, 40, 0, 1)",
      description: "For use as a decorative text color that is applied on a decorative surface."
    },
    "decorative-two-icon": {
      value: "rgba(175, 41, 78, 1)",
      description: "For use as a decorative icon color that is applied on a decorative surface."
    },
    "decorative-two-surface": {
      value: "rgba(255, 196, 176, 1)",
      description: "For use as a decorative surface color."
    },
    "decorative-two-text": {
      value: "rgba(73, 11, 28, 1)",
      description: "For use as a decorative text color that is applied on a decorative surface."
    },
    "decorative-three-icon": {
      value: "rgba(0, 109, 65, 1)",
      description: "For use as a decorative icon color that is applied on a decorative surface."
    },
    "decorative-three-surface": {
      value: "rgba(146, 230, 181, 1)",
      description: "For use as a decorative surface color."
    },
    "decorative-three-text": {
      value: "rgba(0, 47, 25, 1)",
      description: "For use as a decorative text color that is applied on a decorative surface."
    },
    "decorative-four-icon": {
      value: "rgba(0, 106, 104, 1)",
      description: "For use as a decorative icon color that is applied on a decorative surface."
    },
    "decorative-four-surface": {
      value: "rgba(145, 224, 214, 1)",
      description: "For use as a decorative surface color."
    },
    "decorative-four-text": {
      value: "rgba(0, 45, 45, 1)",
      description: "For use as a decorative text color that is applied on a decorative surface."
    },
    "decorative-five-icon": {
      value: "rgba(174, 43, 76, 1)",
      description: "For use as a decorative icon color that is applied on a decorative surface."
    },
    "decorative-five-surface": {
      value: "rgba(253, 201, 208, 1)",
      description: "For use as a decorative surface color."
    },
    "decorative-five-text": {
      value: "rgba(79, 14, 31, 1)",
      description: "For use as a decorative text color that is applied on a decorative surface."
    }
  };

  // node_modules/@shopify/polaris-tokens/dist/esm/token-groups/motion.mjs
  var motion = {
    "duration-0": {
      value: "0ms"
    },
    "duration-50": {
      value: "50ms"
    },
    "duration-100": {
      value: "100ms"
    },
    "duration-150": {
      value: "150ms"
    },
    "duration-200": {
      value: "200ms"
    },
    "duration-250": {
      value: "250ms"
    },
    "duration-300": {
      value: "300ms"
    },
    "duration-350": {
      value: "350ms"
    },
    "duration-400": {
      value: "400ms"
    },
    "duration-450": {
      value: "450ms"
    },
    "duration-500": {
      value: "500ms"
    },
    "duration-5000": {
      value: "5000ms"
    },
    ease: {
      value: "cubic-bezier(0.25, 0.1, 0.25, 1)"
    },
    "ease-in": {
      value: "cubic-bezier(0.42, 0, 1, 1)"
    },
    "ease-out": {
      value: "cubic-bezier(0, 0, 0.58, 1)"
    },
    "ease-in-out": {
      value: "cubic-bezier(0.42, 0, 0.58, 1)"
    },
    linear: {
      value: "cubic-bezier(0, 0, 1, 1)"
    },
    "keyframes-bounce": {
      value: "{ from, 65%, 85% { transform: scale(1) } 75% { transform: scale(0.85) } 82.5% { transform: scale(1.05) } }"
    },
    "keyframes-fade-in": {
      value: "{ to { opacity: 1 } }"
    },
    "keyframes-pulse": {
      value: "{ from, 75% { transform: scale(0.85); opacity: 1; } to { transform: scale(2.5); opacity: 0; } }"
    },
    "keyframes-spin": {
      value: "{ to { transform: rotate(1turn) } }"
    }
  };

  // node_modules/@shopify/polaris-tokens/dist/esm/token-groups/shape.mjs
  var shape = {
    "border-radius-05": {
      value: "2px"
    },
    "border-radius-1": {
      value: "4px"
    },
    "border-radius-2": {
      value: "8px"
    },
    "border-radius-3": {
      value: "12px"
    },
    "border-radius-4": {
      value: "16px"
    },
    "border-radius-5": {
      value: "20px"
    },
    "border-radius-6": {
      value: "30px"
    },
    "border-radius-base": {
      value: "3px"
    },
    "border-radius-large": {
      value: "6px"
    },
    "border-radius-half": {
      value: "50%"
    },
    "border-width-1": {
      value: "1px"
    },
    "border-width-2": {
      value: "2px"
    },
    "border-width-3": {
      value: "3px"
    },
    "border-width-4": {
      value: "4px"
    },
    "border-width-5": {
      value: "5px"
    },
    "border-base": {
      value: "var(--p-border-width-1) solid var(--p-border-subdued)"
    },
    "border-dark": {
      value: "var(--p-border-width-1) solid var(--p-border)"
    },
    "border-transparent": {
      value: "var(--p-border-width-1) solid transparent"
    },
    "border-divider": {
      value: "var(--p-border-width-1) solid var(--p-divider)"
    },
    "border-divider-on-dark": {
      value: "var(--p-border-width-1) solid var(--p-divider-dark)"
    }
  };

  // node_modules/@shopify/polaris-tokens/dist/esm/token-groups/spacing.mjs
  var spacing = {
    "space-0": {
      value: "0"
    },
    "space-025": {
      value: "1px"
    },
    "space-05": {
      value: "2px"
    },
    "space-1": {
      value: "4px"
    },
    "space-2": {
      value: "8px"
    },
    "space-3": {
      value: "12px"
    },
    "space-4": {
      value: "16px"
    },
    "space-5": {
      value: "20px"
    },
    "space-6": {
      value: "24px"
    },
    "space-8": {
      value: "32px"
    },
    "space-10": {
      value: "40px"
    },
    "space-12": {
      value: "48px"
    },
    "space-16": {
      value: "64px"
    },
    "space-20": {
      value: "80px"
    },
    "space-24": {
      value: "96px"
    },
    "space-28": {
      value: "112px"
    },
    "space-32": {
      value: "128px"
    }
  };

  // node_modules/@shopify/polaris-tokens/dist/esm/token-groups/typography.mjs
  var typography = {
    "font-family-sans": {
      value: "-apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif"
    },
    "font-family-mono": {
      value: "ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace"
    },
    "font-size-1": {
      value: "12px"
    },
    "font-size-2": {
      value: "13px"
    },
    "font-size-3": {
      value: "14px"
    },
    "font-size-4": {
      value: "15px"
    },
    "font-size-5": {
      value: "16px"
    },
    "font-size-6": {
      value: "17px"
    },
    "font-size-7": {
      value: "20px"
    },
    "font-size-8": {
      value: "21px"
    },
    "font-size-9": {
      value: "24px"
    },
    "font-size-10": {
      value: "26px"
    },
    "font-size-11": {
      value: "27px"
    },
    "font-size-12": {
      value: "28px"
    },
    "font-size-13": {
      value: "42px"
    },
    "font-weight-regular": {
      value: "400"
    },
    "font-weight-medium": {
      value: "500"
    },
    "font-weight-semibold": {
      value: "600"
    },
    "font-weight-bold": {
      value: "700"
    },
    "line-height-1": {
      value: "16px"
    },
    "line-height-2": {
      value: "20px"
    },
    "line-height-3": {
      value: "24px"
    },
    "line-height-4": {
      value: "28px"
    },
    "line-height-5": {
      value: "32px"
    },
    "line-height-6": {
      value: "36px"
    },
    "line-height-7": {
      value: "44px"
    }
  };

  // node_modules/@shopify/polaris-tokens/dist/esm/token-groups/zIndex.mjs
  var zIndex = {
    "z-1": {
      value: "100"
    },
    "z-2": {
      value: "400"
    },
    "z-3": {
      value: "510"
    },
    "z-4": {
      value: "512"
    },
    "z-5": {
      value: "513"
    },
    "z-6": {
      value: "514"
    },
    "z-7": {
      value: "515"
    },
    "z-8": {
      value: "516"
    },
    "z-9": {
      value: "517"
    },
    "z-10": {
      value: "518"
    },
    "z-11": {
      value: "519"
    },
    "z-12": {
      value: "520"
    }
  };

  // node_modules/@shopify/polaris-tokens/dist/esm/_virtual/_rollupPluginBabelHelpers.mjs
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@shopify/polaris-tokens/dist/esm/utilities.mjs
  var _templateObject;
  var BASE_FONT_SIZE = 16;
  var UNIT_PX = "px";
  var UNIT_EM = "em";
  var UNIT_REM = "rem";
  var DIGIT_REGEX = new RegExp(String.raw(_templateObject || (_templateObject = _taggedTemplateLiteral(["-?d+(?:.d+|d*)"], ["-?\\d+(?:\\.\\d+|\\d*)"]))));
  var UNIT_REGEX = new RegExp("".concat(UNIT_PX, "|").concat(UNIT_EM, "|").concat(UNIT_REM));
  function getUnit() {
    var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var unit = value.match(new RegExp("".concat(DIGIT_REGEX.source, "(").concat(UNIT_REGEX.source, ")")));
    return unit && unit[1];
  }
  function toRem() {
    var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var unit = getUnit(value);
    if (!unit)
      return value;
    if (unit === UNIT_REM) {
      return value;
    }
    if (unit === UNIT_EM) {
      return "".concat(parseFloat(value)).concat(UNIT_REM);
    }
    if (unit === UNIT_PX) {
      return "".concat(parseFloat(value) / BASE_FONT_SIZE).concat(UNIT_REM);
    }
  }
  function rem(value) {
    return value.replace(new RegExp("".concat(DIGIT_REGEX.source, "(").concat(UNIT_PX, ")"), "g"), function(px) {
      var _toRem;
      return (_toRem = toRem(px)) !== null && _toRem !== void 0 ? _toRem : px;
    });
  }
  function tokensToRems(tokenGroup) {
    return Object.fromEntries(Object.entries(tokenGroup).map(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), token = _ref2[0], properties = _ref2[1];
      return [token, _objectSpread2(_objectSpread2({}, properties), {}, {
        value: rem(properties.value)
      })];
    }));
  }

  // node_modules/@shopify/polaris-tokens/dist/esm/tokens.mjs
  var colorSchemes = {
    light: colors2,
    dark: colors
  };
  var tokens = createTokens({
    breakpoints: tokensToRems(breakpoints),
    colorSchemes,
    depth,
    legacyTokens: tokensToRems(legacy),
    motion,
    shape: tokensToRems(shape),
    spacing: tokensToRems(spacing),
    typography: tokensToRems(typography),
    zIndex
  });
  function createTokens(tokens2) {
    return tokens2;
  }

  // node_modules/@shopify/polaris/build/esm/utilities/debounce.js
  function debounce(func, waitArg, options) {
    let lastArgs;
    let lastThis;
    let maxWait;
    let result2;
    let timerId;
    let lastCallTime;
    let lastInvokeTime = 0;
    let leading = false;
    let maxing = false;
    let trailing = true;
    const useRAF = !waitArg && waitArg !== 0;
    if (typeof func !== "function") {
      throw new TypeError("Expected a function");
    }
    const wait = waitArg || 0;
    if (typeof options === "object") {
      leading = Boolean(options.leading);
      maxing = "maxWait" in options;
      maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : void 0;
      trailing = "trailing" in options ? Boolean(options.trailing) : trailing;
    }
    function invokeFunc(time) {
      const args = lastArgs;
      const thisArg = lastThis;
      lastArgs = void 0;
      lastThis = void 0;
      lastInvokeTime = time;
      result2 = func.apply(thisArg, args);
      return result2;
    }
    function startTimer(pendingFunc, wait2) {
      if (useRAF) {
        cancelAnimationFrame(timerId);
        return requestAnimationFrame(pendingFunc);
      }
      return setTimeout(pendingFunc, wait2);
    }
    function cancelTimer(id) {
      if (useRAF) {
        return cancelAnimationFrame(id);
      }
      clearTimeout(id);
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = startTimer(timerExpired, wait);
      return leading ? invokeFunc(time) : result2;
    }
    function remainingWait(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      const timeWaiting = wait - timeSinceLastCall;
      return maxing && maxWait ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && maxWait && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      const time = Date.now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = startTimer(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result2;
    }
    function cancel2() {
      if (timerId !== void 0) {
        cancelTimer(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result2 : trailingEdge(Date.now());
    }
    function pending() {
      return timerId !== void 0;
    }
    function debounced(...args) {
      const time = Date.now();
      const isInvoking = shouldInvoke(time);
      lastArgs = args;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = startTimer(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = startTimer(timerExpired, wait);
      }
      return result2;
    }
    debounced.cancel = cancel2;
    debounced.flush = flush;
    debounced.pending = pending;
    return debounced;
  }

  // node_modules/@shopify/polaris/build/esm/utilities/breakpoints.js
  var Breakpoints = {
    navigationBarCollapsed: "768px",
    stackedContent: "1043px"
  };
  var noWindowMatches = {
    media: "",
    addListener: noop,
    removeListener: noop,
    matches: false,
    onchange: noop,
    addEventListener: noop,
    removeEventListener: noop,
    dispatchEvent: (_) => true
  };
  function noop() {
  }
  function navigationBarCollapsed() {
    return typeof window === "undefined" ? noWindowMatches : window.matchMedia(`(max-width: ${Breakpoints.navigationBarCollapsed})`);
  }
  function stackedContent() {
    return typeof window === "undefined" ? noWindowMatches : window.matchMedia(`(max-width: ${Breakpoints.stackedContent})`);
  }

  // node_modules/@shopify/polaris/build/esm/utilities/geometry.js
  var Rect = class {
    static get zero() {
      return new Rect();
    }
    constructor({
      top = 0,
      left = 0,
      width = 0,
      height = 0
    } = {}) {
      this.top = void 0;
      this.left = void 0;
      this.width = void 0;
      this.height = void 0;
      this.top = top;
      this.left = left;
      this.width = width;
      this.height = height;
    }
    get center() {
      return {
        x: this.left + this.width / 2,
        y: this.top + this.height / 2
      };
    }
  };
  function getRectForNode(node) {
    if (!(node instanceof Element)) {
      return new Rect({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }
    const rect = node.getBoundingClientRect();
    return new Rect({
      top: rect.top,
      left: rect.left,
      width: rect.width,
      height: rect.height
    });
  }

  // node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/sticky-manager.js
  var SIXTY_FPS = 1e3 / 60;
  var StickyManager = class {
    constructor(container) {
      this.stickyItems = [];
      this.stuckItems = [];
      this.container = null;
      this.topBarOffset = 0;
      this.handleResize = debounce(() => {
        this.manageStickyItems();
      }, SIXTY_FPS, {
        leading: true,
        trailing: true,
        maxWait: SIXTY_FPS
      });
      this.handleScroll = debounce(() => {
        this.manageStickyItems();
      }, SIXTY_FPS, {
        leading: true,
        trailing: true,
        maxWait: SIXTY_FPS
      });
      if (container) {
        this.setContainer(container);
      }
    }
    registerStickyItem(stickyItem) {
      this.stickyItems.push(stickyItem);
    }
    unregisterStickyItem(nodeToRemove) {
      const nodeIndex = this.stickyItems.findIndex(({
        stickyNode
      }) => nodeToRemove === stickyNode);
      this.stickyItems.splice(nodeIndex, 1);
    }
    setContainer(el) {
      this.container = el;
      if (isDocument(el)) {
        this.setTopBarOffset(el);
      }
      this.container.addEventListener("scroll", this.handleScroll);
      window.addEventListener("resize", this.handleResize);
      this.manageStickyItems();
    }
    removeScrollListener() {
      if (this.container) {
        this.container.removeEventListener("scroll", this.handleScroll);
        window.removeEventListener("resize", this.handleResize);
      }
    }
    manageStickyItems() {
      if (this.stickyItems.length <= 0) {
        return;
      }
      const scrollTop = this.container ? scrollTopFor(this.container) : 0;
      const containerTop = getRectForNode(this.container).top + this.topBarOffset;
      this.stickyItems.forEach((stickyItem) => {
        const {
          handlePositioning
        } = stickyItem;
        const {
          sticky,
          top,
          left,
          width
        } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);
        this.updateStuckItems(stickyItem, sticky);
        handlePositioning(sticky, top, left, width);
      });
    }
    evaluateStickyItem(stickyItem, scrollTop, containerTop) {
      const {
        stickyNode,
        placeHolderNode,
        boundingElement,
        offset,
        disableWhenStacked
      } = stickyItem;
      if (disableWhenStacked && stackedContent().matches) {
        return {
          sticky: false,
          top: 0,
          left: 0,
          width: "auto"
        };
      }
      const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(tokens.spacing["space-5"].value, 10) : this.getOffset(stickyNode);
      const scrollPosition2 = scrollTop + stickyOffset;
      const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;
      const top = containerTop + stickyOffset;
      const width = placeHolderNode.getBoundingClientRect().width;
      const left = placeHolderNode.getBoundingClientRect().left;
      let sticky;
      if (boundingElement == null) {
        sticky = scrollPosition2 >= placeHolderNodeCurrentTop;
      } else {
        var _stickyNode$firstElem;
        const stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) === null || _stickyNode$firstElem === void 0 ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;
        const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;
        sticky = scrollPosition2 >= placeHolderNodeCurrentTop && scrollPosition2 < stickyItemBottomPosition;
      }
      return {
        sticky,
        top,
        left,
        width
      };
    }
    updateStuckItems(item, sticky) {
      const {
        stickyNode
      } = item;
      if (sticky && !this.isNodeStuck(stickyNode)) {
        this.addStuckItem(item);
      } else if (!sticky && this.isNodeStuck(stickyNode)) {
        this.removeStuckItem(item);
      }
    }
    addStuckItem(stickyItem) {
      this.stuckItems.push(stickyItem);
    }
    removeStuckItem(stickyItem) {
      const {
        stickyNode: nodeToRemove
      } = stickyItem;
      const nodeIndex = this.stuckItems.findIndex(({
        stickyNode
      }) => nodeToRemove === stickyNode);
      this.stuckItems.splice(nodeIndex, 1);
    }
    getOffset(node) {
      if (this.stuckItems.length === 0) {
        return 0;
      }
      let offset = 0;
      let count = 0;
      const stuckNodesLength = this.stuckItems.length;
      const nodeRect = getRectForNode(node);
      while (count < stuckNodesLength) {
        const stuckNode = this.stuckItems[count].stickyNode;
        if (stuckNode !== node) {
          const stuckNodeRect = getRectForNode(stuckNode);
          if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {
            offset += getRectForNode(stuckNode).height;
          }
        } else {
          break;
        }
        count++;
      }
      return offset;
    }
    isNodeStuck(node) {
      const nodeFound = this.stuckItems.findIndex(({
        stickyNode
      }) => node === stickyNode);
      return nodeFound >= 0;
    }
    setTopBarOffset(container) {
      const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);
      this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;
    }
  };
  function isDocument(node) {
    return node === document;
  }
  function scrollTopFor(container) {
    return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;
  }
  function horizontallyOverlaps(rect1, rect2) {
    const rect1Left = rect1.left;
    const rect1Right = rect1.left + rect1.width;
    const rect2Left = rect2.left;
    const rect2Right = rect2.left + rect2.width;
    return rect2Right < rect1Left || rect1Right < rect2Left;
  }

  // node_modules/@shopify/polaris/build/esm/utilities/target.js
  var isServer = typeof window === "undefined" || typeof document === "undefined";

  // node_modules/@shopify/polaris/build/esm/utilities/scroll-lock-manager/scroll-lock-manager.js
  var SCROLL_LOCKING_ATTRIBUTE = "data-lock-scrolling";
  var SCROLL_LOCKING_WRAPPER_ATTRIBUTE = "data-lock-scrolling-wrapper";
  var scrollPosition = 0;
  var ScrollLockManager = class {
    constructor() {
      this.scrollLocks = 0;
      this.locked = false;
    }
    registerScrollLock() {
      this.scrollLocks += 1;
      this.handleScrollLocking();
    }
    unregisterScrollLock() {
      this.scrollLocks -= 1;
      this.handleScrollLocking();
    }
    handleScrollLocking() {
      if (isServer)
        return;
      const {
        scrollLocks
      } = this;
      const {
        body
      } = document;
      const wrapper = body.firstElementChild;
      if (scrollLocks === 0) {
        body.removeAttribute(SCROLL_LOCKING_ATTRIBUTE);
        if (wrapper) {
          wrapper.removeAttribute(SCROLL_LOCKING_WRAPPER_ATTRIBUTE);
        }
        window.scroll(0, scrollPosition);
        this.locked = false;
      } else if (scrollLocks > 0 && !this.locked) {
        scrollPosition = window.pageYOffset;
        body.setAttribute(SCROLL_LOCKING_ATTRIBUTE, "");
        if (wrapper) {
          wrapper.setAttribute(SCROLL_LOCKING_WRAPPER_ATTRIBUTE, "");
          wrapper.scrollTop = scrollPosition;
        }
        this.locked = true;
      }
    }
    resetScrollPosition() {
      scrollPosition = 0;
    }
  };

  // node_modules/@shopify/polaris/build/esm/utilities/unique-id/unique-id-factory.js
  var UniqueIdFactory = class {
    constructor(idGeneratorFactory) {
      this.idGeneratorFactory = void 0;
      this.idGenerators = {};
      this.idGeneratorFactory = idGeneratorFactory;
    }
    nextId(prefix2) {
      if (!this.idGenerators[prefix2]) {
        this.idGenerators[prefix2] = this.idGeneratorFactory(prefix2);
      }
      return this.idGenerators[prefix2]();
    }
  };
  function globalIdGeneratorFactory(prefix2 = "") {
    let index2 = 1;
    return () => `Polaris${prefix2}${index2++}`;
  }

  // node_modules/@shopify/polaris/build/esm/utilities/get.js
  var OBJECT_NOTATION_MATCHER = /\[(.*?)\]|(\w+)/g;
  function get(obj, keypath, defaultValue) {
    if (obj == null)
      return void 0;
    const keys = Array.isArray(keypath) ? keypath : getKeypath(keypath);
    let acc = obj;
    for (let i = 0; i < keys.length; i++) {
      const val = acc[keys[i]];
      if (val === void 0)
        return defaultValue;
      acc = val;
    }
    return acc;
  }
  function getKeypath(str) {
    const path = [];
    let result2;
    while (result2 = OBJECT_NOTATION_MATCHER.exec(str)) {
      const [, first, second] = result2;
      path.push(first || second);
    }
    return path;
  }

  // node_modules/@shopify/polaris/build/esm/utilities/merge.js
  function merge(...objs) {
    let final = {};
    for (const obj of objs) {
      final = mergeRecursively(final, obj);
    }
    return final;
  }
  function mergeRecursively(inputObjA, objB) {
    const objA = Array.isArray(inputObjA) ? [...inputObjA] : {
      ...inputObjA
    };
    for (const key in objB) {
      if (!Object.prototype.hasOwnProperty.call(objB, key)) {
        continue;
      } else if (isMergeableValue(objB[key]) && isMergeableValue(objA[key])) {
        objA[key] = mergeRecursively(objA[key], objB[key]);
      } else {
        objA[key] = objB[key];
      }
    }
    return objA;
  }
  function isMergeableValue(value) {
    return value !== null && typeof value === "object";
  }

  // node_modules/@shopify/polaris/build/esm/utilities/i18n/I18n.js
  var REPLACE_REGEX = /{([^}]*)}/g;
  var I18n = class {
    constructor(translation) {
      this.translation = {};
      this.translation = Array.isArray(translation) ? merge(...translation.slice().reverse()) : translation;
    }
    translate(id, replacements) {
      const text = get(this.translation, id, "");
      if (!text) {
        return "";
      }
      if (replacements) {
        return text.replace(REPLACE_REGEX, (match) => {
          const replacement = match.substring(1, match.length - 1);
          if (replacements[replacement] === void 0) {
            const replacementData = JSON.stringify(replacements);
            throw new Error(`Error in translation for key '${id}'. No replacement found for key '${replacement}'. The following replacements were passed: '${replacementData}'`);
          }
          return replacements[replacement];
        });
      }
      return text;
    }
    translationKeyExists(path) {
      return Boolean(get(this.translation, path));
    }
  };

  // node_modules/@shopify/polaris/build/esm/utilities/features/context.js
  var import_react3 = __toESM(require_react());
  var FeaturesContext = /* @__PURE__ */ (0, import_react3.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/utilities/i18n/context.js
  var import_react4 = __toESM(require_react());
  var I18nContext = /* @__PURE__ */ (0, import_react4.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/utilities/scroll-lock-manager/context.js
  var import_react5 = __toESM(require_react());
  var ScrollLockManagerContext = /* @__PURE__ */ (0, import_react5.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/context.js
  var import_react6 = __toESM(require_react());
  var StickyManagerContext = /* @__PURE__ */ (0, import_react6.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/utilities/unique-id/context.js
  var import_react7 = __toESM(require_react());
  var UniqueIdFactoryContext = /* @__PURE__ */ (0, import_react7.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/utilities/link/context.js
  var import_react8 = __toESM(require_react());
  var LinkContext = /* @__PURE__ */ (0, import_react8.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/components/MediaQueryProvider/MediaQueryProvider.js
  var import_react11 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/media-query/context.js
  var import_react9 = __toESM(require_react());
  var MediaQueryContext = /* @__PURE__ */ (0, import_react9.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/components/EventListener/EventListener.js
  var import_react10 = __toESM(require_react());
  var EventListener = class extends import_react10.PureComponent {
    componentDidMount() {
      this.attachListener();
    }
    componentDidUpdate({
      passive,
      ...detachProps
    }) {
      this.detachListener(detachProps);
      this.attachListener();
    }
    componentWillUnmount() {
      this.detachListener();
    }
    render() {
      return null;
    }
    attachListener() {
      const {
        event,
        handler,
        capture,
        passive
      } = this.props;
      window.addEventListener(event, handler, {
        capture,
        passive
      });
    }
    detachListener(prevProps) {
      const {
        event,
        handler,
        capture
      } = prevProps || this.props;
      window.removeEventListener(event, handler, capture);
    }
  };

  // node_modules/@shopify/polaris/build/esm/components/MediaQueryProvider/MediaQueryProvider.js
  var MediaQueryProvider = function MediaQueryProvider2({
    children: children2
  }) {
    const [isNavigationCollapsed, setIsNavigationCollapsed] = (0, import_react11.useState)(navigationBarCollapsed().matches);
    const handleResize = (0, import_react11.useCallback)(debounce(() => {
      if (isNavigationCollapsed !== navigationBarCollapsed().matches) {
        setIsNavigationCollapsed(!isNavigationCollapsed);
      }
    }, 40, {
      trailing: true,
      leading: true,
      maxWait: 40
    }), [isNavigationCollapsed]);
    (0, import_react11.useEffect)(() => {
      setIsNavigationCollapsed(navigationBarCollapsed().matches);
    }, []);
    const context2 = (0, import_react11.useMemo)(() => ({
      isNavigationCollapsed
    }), [isNavigationCollapsed]);
    return /* @__PURE__ */ import_react11.default.createElement(MediaQueryContext.Provider, {
      value: context2
    }, /* @__PURE__ */ import_react11.default.createElement(EventListener, {
      event: "resize",
      handler: handleResize
    }), children2);
  };

  // node_modules/@shopify/polaris/build/esm/components/PortalsManager/PortalsManager.js
  var import_react14 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/portals/context.js
  var import_react12 = __toESM(require_react());
  var PortalsManagerContext = /* @__PURE__ */ (0, import_react12.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/components/PortalsManager/components/PortalsContainer/PortalsContainer.js
  var import_react13 = __toESM(require_react());
  function PortalsContainerComponent(_props, ref) {
    return /* @__PURE__ */ import_react13.default.createElement("div", {
      id: "PolarisPortalsContainer",
      ref
    });
  }
  var PortalsContainer = /* @__PURE__ */ (0, import_react13.forwardRef)(PortalsContainerComponent);

  // node_modules/@shopify/polaris/build/esm/components/PortalsManager/PortalsManager.js
  function PortalsManager({
    children: children2,
    container
  }) {
    const [portalContainerElement, setPortalContainerElement] = (0, import_react14.useState)(null);
    const currentContainer = container !== null && container !== void 0 ? container : portalContainerElement;
    const contextValue = (0, import_react14.useMemo)(() => ({
      container: currentContainer
    }), [currentContainer]);
    return /* @__PURE__ */ import_react14.default.createElement(PortalsManagerContext.Provider, {
      value: contextValue
    }, children2, container ? null : /* @__PURE__ */ import_react14.default.createElement(PortalsContainer, {
      ref: setPortalContainerElement
    }));
  }

  // node_modules/@shopify/polaris/build/esm/components/FocusManager/FocusManager.js
  var import_react16 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/focus-manager/context.js
  var import_react15 = __toESM(require_react());
  var FocusManagerContext = /* @__PURE__ */ (0, import_react15.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/components/FocusManager/FocusManager.js
  function FocusManager({
    children: children2
  }) {
    const [trapFocusList, setTrapFocusList] = (0, import_react16.useState)([]);
    const add = (0, import_react16.useCallback)((id) => {
      setTrapFocusList((list) => [...list, id]);
    }, []);
    const remove2 = (0, import_react16.useCallback)((id) => {
      let removed = true;
      setTrapFocusList((list) => {
        const clone = [...list];
        const index2 = clone.indexOf(id);
        if (index2 === -1) {
          removed = false;
        } else {
          clone.splice(index2, 1);
        }
        return clone;
      });
      return removed;
    }, []);
    const value = (0, import_react16.useMemo)(() => ({
      trapFocusList,
      add,
      remove: remove2
    }), [add, trapFocusList, remove2]);
    return /* @__PURE__ */ import_react16.default.createElement(FocusManagerContext.Provider, {
      value
    }, children2);
  }

  // node_modules/@shopify/polaris/build/esm/components/AppProvider/AppProvider.js
  var AppProvider = class extends import_react17.Component {
    constructor(props) {
      super(props);
      this.stickyManager = void 0;
      this.scrollLockManager = void 0;
      this.uniqueIdFactory = void 0;
      this.setBodyStyles = () => {
        document.body.setAttribute("p-color-scheme", this.props.colorScheme || DEFAULT_COLOR_SCHEME);
        document.body.style.backgroundColor = "var(--p-background)";
        document.body.style.color = "var(--p-text)";
        if (this.props.colorScheme && true) {
          console.warn("Deprecation: The `colorScheme` prop on the `AppProvider` has been deprecated. See the v10 migration guide for replacing dark color scheme styles. https://github.com/Shopify/polaris/blob/main/documentation/guides/migrating-from-v9-to-v10.md");
        }
      };
      this.stickyManager = new StickyManager();
      this.scrollLockManager = new ScrollLockManager();
      this.uniqueIdFactory = new UniqueIdFactory(globalIdGeneratorFactory);
      const {
        i18n,
        linkComponent
      } = this.props;
      this.state = {
        link: linkComponent,
        intl: new I18n(i18n)
      };
    }
    componentDidMount() {
      if (document != null) {
        this.stickyManager.setContainer(document);
        this.setBodyStyles();
      }
    }
    componentDidUpdate({
      colorScheme: prevColorScheme,
      i18n: prevI18n,
      linkComponent: prevLinkComponent
    }) {
      const {
        colorScheme,
        i18n,
        linkComponent
      } = this.props;
      if (colorScheme !== prevColorScheme) {
        this.setBodyStyles();
      }
      if (i18n === prevI18n && linkComponent === prevLinkComponent) {
        return;
      }
      this.setState({
        link: linkComponent,
        intl: new I18n(i18n)
      });
    }
    render() {
      const {
        children: children2,
        features = {},
        colorScheme
      } = this.props;
      const {
        intl,
        link
      } = this.state;
      return /* @__PURE__ */ import_react17.default.createElement(FeaturesContext.Provider, {
        value: features
      }, /* @__PURE__ */ import_react17.default.createElement(I18nContext.Provider, {
        value: intl
      }, /* @__PURE__ */ import_react17.default.createElement(ScrollLockManagerContext.Provider, {
        value: this.scrollLockManager
      }, /* @__PURE__ */ import_react17.default.createElement(StickyManagerContext.Provider, {
        value: this.stickyManager
      }, /* @__PURE__ */ import_react17.default.createElement(UniqueIdFactoryContext.Provider, {
        value: this.uniqueIdFactory
      }, /* @__PURE__ */ import_react17.default.createElement(LinkContext.Provider, {
        value: link
      }, /* @__PURE__ */ import_react17.default.createElement(CustomProperties, {
        colorScheme
      }, /* @__PURE__ */ import_react17.default.createElement(MediaQueryProvider, null, /* @__PURE__ */ import_react17.default.createElement(PortalsManager, null, /* @__PURE__ */ import_react17.default.createElement(FocusManager, null, children2))))))))));
    }
  };

  // node_modules/@shopify/polaris/build/esm/utilities/css.js
  function classNames(...classes) {
    return classes.filter(Boolean).join(" ");
  }
  function variationName(name, value) {
    return `${name}${value.charAt(0).toUpperCase()}${value.slice(1)}`;
  }

  // node_modules/@shopify/polaris/build/esm/utilities/use-toggle.js
  var import_react18 = __toESM(require_react());
  function useToggle(initialState) {
    const [value, setState] = (0, import_react18.useState)(initialState);
    return {
      value,
      toggle: (0, import_react18.useCallback)(() => setState((state) => !state), []),
      setTrue: (0, import_react18.useCallback)(() => setState(true), []),
      setFalse: (0, import_react18.useCallback)(() => setState(false), [])
    };
  }

  // node_modules/@shopify/polaris/build/esm/components/Button/utils.js
  var import_react58 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Button/Button.js
  var import_react57 = __toESM(require_react());

  // node_modules/@shopify/polaris-icons/dist/icons/AlertMinor.svg.mjs
  var import_react19 = __toESM(require_react(), 1);
  var SvgAlertMinor = function SvgAlertMinor2(props) {
    return /* @__PURE__ */ import_react19.default.createElement("svg", Object.assign({
      viewBox: "0 0 20 20"
    }, props), /* @__PURE__ */ import_react19.default.createElement("path", {
      d: "M10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm-1-9a1 1 0 0 0 2 0v-2a1 1 0 1 0-2 0v2zm0 4a1 1 0 1 0 2 0 1 1 0 0 0-2 0z"
    }));
  };

  // node_modules/@shopify/polaris-icons/dist/icons/CaretDownMinor.svg.mjs
  var import_react20 = __toESM(require_react(), 1);
  var SvgCaretDownMinor = function SvgCaretDownMinor2(props) {
    return /* @__PURE__ */ import_react20.default.createElement("svg", Object.assign({
      viewBox: "0 0 20 20"
    }, props), /* @__PURE__ */ import_react20.default.createElement("path", {
      d: "M13.098 8h-6.196c-.751 0-1.172.754-.708 1.268l3.098 3.432c.36.399 1.055.399 1.416 0l3.098-3.433c.464-.513.043-1.267-.708-1.267Z"
    }));
  };

  // node_modules/@shopify/polaris-icons/dist/icons/CaretUpMinor.svg.mjs
  var import_react21 = __toESM(require_react(), 1);
  var SvgCaretUpMinor = function SvgCaretUpMinor2(props) {
    return /* @__PURE__ */ import_react21.default.createElement("svg", Object.assign({
      viewBox: "0 0 20 20"
    }, props), /* @__PURE__ */ import_react21.default.createElement("path", {
      d: "M6.902 12h6.196c.751 0 1.172-.754.708-1.268l-3.098-3.432c-.36-.399-1.055-.399-1.416 0l-3.098 3.433c-.464.513-.043 1.267.708 1.267Z"
    }));
  };

  // node_modules/@shopify/polaris-icons/dist/icons/CircleCancelMinor.svg.mjs
  var import_react22 = __toESM(require_react(), 1);
  var SvgCircleCancelMinor = function SvgCircleCancelMinor2(props) {
    return /* @__PURE__ */ import_react22.default.createElement("svg", Object.assign({
      viewBox: "0 0 20 20"
    }, props), /* @__PURE__ */ import_react22.default.createElement("path", {
      fillRule: "evenodd",
      d: "M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16zm-2.293 4.293a1 1 0 0 0-1.414 1.414l2.293 2.293-2.293 2.293a1 1 0 1 0 1.414 1.414l2.293-2.293 2.293 2.293a1 1 0 1 0 1.414-1.414l-2.293-2.293 2.293-2.293a1 1 0 0 0-1.414-1.414l-2.293 2.293-2.293-2.293z"
    }));
  };

  // node_modules/@shopify/polaris-icons/dist/icons/DeleteMajor.svg.mjs
  var import_react23 = __toESM(require_react(), 1);
  var SvgDeleteMajor = function SvgDeleteMajor2(props) {
    return /* @__PURE__ */ import_react23.default.createElement("svg", Object.assign({
      viewBox: "0 0 20 20"
    }, props), /* @__PURE__ */ import_react23.default.createElement("path", {
      fillRule: "evenodd",
      d: "M14 4h3a1 1 0 0 1 1 1v1h-16v-1a1 1 0 0 1 1-1h3v-2.5a1.5 1.5 0 0 1 1.5-1.5h5a1.5 1.5 0 0 1 1.5 1.5v2.5zm-6-2v2h4v-2h-4zm-5 6h14v10.5a1.5 1.5 0 0 1-1.5 1.5h-11a1.5 1.5 0 0 1-1.5-1.5v-10.5zm4 3h-2v6h2v-6zm4 0h-2v6h2v-6zm2 0h2v6h-2v-6z"
    }));
  };

  // node_modules/@shopify/polaris-icons/dist/icons/EditMajor.svg.mjs
  var import_react24 = __toESM(require_react(), 1);
  var SvgEditMajor = function SvgEditMajor2(props) {
    return /* @__PURE__ */ import_react24.default.createElement("svg", Object.assign({
      viewBox: "0 0 20 20"
    }, props), /* @__PURE__ */ import_react24.default.createElement("path", {
      d: "m14.846 1.403 3.752 3.753.625-.626a2.653 2.653 0 0 0-3.752-3.752l-.625.625zm2.029 5.472-3.752-3.753-11.905 11.906-1.218 4.97 4.97-1.217 11.905-11.906z"
    }));
  };

  // node_modules/@shopify/polaris-icons/dist/icons/MobileCancelMajor.svg.mjs
  var import_react25 = __toESM(require_react(), 1);
  var SvgMobileCancelMajor = function SvgMobileCancelMajor2(props) {
    return /* @__PURE__ */ import_react25.default.createElement("svg", Object.assign({
      viewBox: "0 0 20 20"
    }, props), /* @__PURE__ */ import_react25.default.createElement("path", {
      d: "m11.414 10 6.293-6.293a1 1 0 1 0-1.414-1.414l-6.293 6.293-6.293-6.293a1 1 0 0 0-1.414 1.414l6.293 6.293-6.293 6.293a1 1 0 1 0 1.414 1.414l6.293-6.293 6.293 6.293a.998.998 0 0 0 1.707-.707.999.999 0 0 0-.293-.707l-6.293-6.293z"
    }));
  };

  // node_modules/@shopify/polaris-icons/dist/icons/SelectMinor.svg.mjs
  var import_react26 = __toESM(require_react(), 1);
  var SvgSelectMinor = function SvgSelectMinor2(props) {
    return /* @__PURE__ */ import_react26.default.createElement("svg", Object.assign({
      viewBox: "0 0 20 20"
    }, props), /* @__PURE__ */ import_react26.default.createElement("path", {
      d: "M7.676 9h4.648c.563 0 .879-.603.53-1.014l-2.323-2.746a.708.708 0 0 0-1.062 0l-2.324 2.746c-.347.411-.032 1.014.531 1.014Zm4.648 2h-4.648c-.563 0-.878.603-.53 1.014l2.323 2.746c.27.32.792.32 1.062 0l2.323-2.746c.349-.411.033-1.014-.53-1.014Z"
    }));
  };

  // node_modules/@shopify/polaris-icons/dist/index.mjs
  var import_react27 = __toESM(require_react(), 1);

  // node_modules/@shopify/polaris/build/esm/utilities/is-element-in-viewport.js
  function isElementInViewport(element) {
    const {
      top,
      left,
      bottom,
      right
    } = element.getBoundingClientRect();
    return top >= 0 && right <= window.innerWidth && bottom <= window.innerHeight && left >= 0;
  }

  // node_modules/@shopify/polaris/build/esm/utilities/focus.js
  var FOCUSABLE_SELECTOR = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
  var KEYBOARD_FOCUSABLE_SELECTORS = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]:not([tabindex="-1"])';
  var MENUITEM_FOCUSABLE_SELECTORS = 'a[role="menuitem"],frame[role="menuitem"],iframe[role="menuitem"],input[role="menuitem"]:not([type=hidden]):not(:disabled),select[role="menuitem"]:not(:disabled),textarea[role="menuitem"]:not(:disabled),button[role="menuitem"]:not(:disabled),*[tabindex]:not([tabindex="-1"])';
  var handleMouseUpByBlurring = ({
    currentTarget
  }) => currentTarget.blur();
  function nextFocusableNode(node, filter) {
    const allFocusableElements = [...document.querySelectorAll(FOCUSABLE_SELECTOR)];
    const sliceLocation = allFocusableElements.indexOf(node) + 1;
    const focusableElementsAfterNode = allFocusableElements.slice(sliceLocation);
    for (const focusableElement of focusableElementsAfterNode) {
      if (isElementInViewport(focusableElement) && (!filter || filter && filter(focusableElement))) {
        return focusableElement;
      }
    }
    return null;
  }
  function findFirstFocusableNode(element, onlyDescendants = true) {
    if (!onlyDescendants && matches(element, FOCUSABLE_SELECTOR)) {
      return element;
    }
    return element.querySelector(FOCUSABLE_SELECTOR);
  }
  function findFirstFocusableNodeIncludingDisabled(element) {
    const focusableSelector = `a,button,frame,iframe,input:not([type=hidden]),select,textarea,*[tabindex]`;
    if (matches(element, focusableSelector)) {
      return element;
    }
    return element.querySelector(focusableSelector);
  }
  function focusFirstFocusableNode(element, onlyDescendants = true) {
    var _findFirstFocusableNo;
    (_findFirstFocusableNo = findFirstFocusableNode(element, onlyDescendants)) === null || _findFirstFocusableNo === void 0 ? void 0 : _findFirstFocusableNo.focus();
  }
  function focusNextFocusableNode(node, filter) {
    const nextFocusable = nextFocusableNode(node, filter);
    if (nextFocusable && nextFocusable instanceof HTMLElement) {
      nextFocusable.focus();
      return true;
    }
    return false;
  }
  function findFirstKeyboardFocusableNode(element, onlyDescendants = true) {
    if (!onlyDescendants && matches(element, KEYBOARD_FOCUSABLE_SELECTORS)) {
      return element;
    }
    return element.querySelector(KEYBOARD_FOCUSABLE_SELECTORS);
  }
  function focusFirstKeyboardFocusableNode(element, onlyDescendants = true) {
    const firstFocusable = findFirstKeyboardFocusableNode(element, onlyDescendants);
    if (firstFocusable) {
      firstFocusable.focus();
      return true;
    }
    return false;
  }
  function findLastKeyboardFocusableNode(element, onlyDescendants = true) {
    if (!onlyDescendants && matches(element, KEYBOARD_FOCUSABLE_SELECTORS)) {
      return element;
    }
    const allFocusable = element.querySelectorAll(KEYBOARD_FOCUSABLE_SELECTORS);
    return allFocusable[allFocusable.length - 1];
  }
  function focusLastKeyboardFocusableNode(element, onlyDescendants = true) {
    const lastFocusable = findLastKeyboardFocusableNode(element, onlyDescendants);
    if (lastFocusable) {
      lastFocusable.focus();
      return true;
    }
    return false;
  }
  function wrapFocusPreviousFocusableMenuItem(parentElement, currentFocusedElement) {
    const allFocusableChildren = getMenuFocusableDescendants(parentElement);
    const currentItemIdx = getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement);
    if (currentItemIdx === -1) {
      allFocusableChildren[0].focus();
    } else {
      allFocusableChildren[(currentItemIdx - 1 + allFocusableChildren.length) % allFocusableChildren.length].focus();
    }
  }
  function wrapFocusNextFocusableMenuItem(parentElement, currentFocusedElement) {
    const allFocusableChildren = getMenuFocusableDescendants(parentElement);
    const currentItemIdx = getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement);
    if (currentItemIdx === -1) {
      allFocusableChildren[0].focus();
    } else {
      allFocusableChildren[(currentItemIdx + 1) % allFocusableChildren.length].focus();
    }
  }
  function getMenuFocusableDescendants(element) {
    return element.querySelectorAll(MENUITEM_FOCUSABLE_SELECTORS);
  }
  function getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement) {
    let currentItemIdx = 0;
    for (const focusableChild of allFocusableChildren) {
      if (focusableChild === currentFocusedElement) {
        break;
      }
      currentItemIdx++;
    }
    return currentItemIdx === allFocusableChildren.length ? -1 : currentItemIdx;
  }
  function matches(node, selector) {
    if (node.matches) {
      return node.matches(selector);
    }
    const matches2 = (node.ownerDocument || document).querySelectorAll(selector);
    let i = matches2.length;
    while (--i >= 0 && matches2.item(i) !== node)
      return i > -1;
  }

  // node_modules/@shopify/polaris/build/esm/components/Button/Button.scss.js
  var styles = {
    "Button": "Polaris-Button",
    "pressed": "Polaris-Button--pressed",
    "disabled": "Polaris-Button--disabled",
    "connectedDisclosure": "Polaris-Button--connectedDisclosure",
    "Content": "Polaris-Button__Content",
    "plain": "Polaris-Button--plain",
    "textAlignLeft": "Polaris-Button--textAlignLeft",
    "textAlignStart": "Polaris-Button--textAlignStart",
    "textAlignCenter": "Polaris-Button--textAlignCenter",
    "textAlignRight": "Polaris-Button--textAlignRight",
    "textAlignEnd": "Polaris-Button--textAlignEnd",
    "Icon": "Polaris-Button__Icon",
    "fullWidth": "Polaris-Button--fullWidth",
    "hidden": "Polaris-Button--hidden",
    "Spinner": "Polaris-Button__Spinner",
    "primary": "Polaris-Button--primary",
    "destructive": "Polaris-Button--destructive",
    "outline": "Polaris-Button--outline",
    "loading": "Polaris-Button--loading",
    "removeUnderline": "Polaris-Button--removeUnderline",
    "iconOnly": "Polaris-Button--iconOnly",
    "sizeSlim": "Polaris-Button--sizeSlim",
    "sizeLarge": "Polaris-Button--sizeLarge",
    "monochrome": "Polaris-Button--monochrome",
    "Text": "Polaris-Button__Text",
    "ConnectedDisclosureWrapper": "Polaris-Button__ConnectedDisclosureWrapper",
    "ConnectedDisclosure": "Polaris-Button__ConnectedDisclosure"
  };

  // node_modules/@shopify/polaris/build/esm/components/Spinner/Spinner.js
  var import_react30 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/use-is-after-initial-mount.js
  var import_react28 = __toESM(require_react());
  function useIsAfterInitialMount() {
    const [isAfterInitialMount, setIsAfterInitialMount] = (0, import_react28.useState)(false);
    (0, import_react28.useEffect)(() => {
      setIsAfterInitialMount(true);
    }, []);
    return isAfterInitialMount;
  }

  // node_modules/@shopify/polaris/build/esm/components/Spinner/Spinner.scss.js
  var styles2 = {
    "Spinner": "Polaris-Spinner",
    "sizeSmall": "Polaris-Spinner--sizeSmall",
    "sizeLarge": "Polaris-Spinner--sizeLarge"
  };

  // node_modules/@shopify/polaris/build/esm/components/VisuallyHidden/VisuallyHidden.js
  var import_react29 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/VisuallyHidden/VisuallyHidden.scss.js
  var styles3 = {
    "VisuallyHidden": "Polaris-VisuallyHidden"
  };

  // node_modules/@shopify/polaris/build/esm/components/VisuallyHidden/VisuallyHidden.js
  function VisuallyHidden({
    children: children2
  }) {
    return /* @__PURE__ */ import_react29.default.createElement("span", {
      className: styles3.VisuallyHidden
    }, children2);
  }

  // node_modules/@shopify/polaris/build/esm/components/Spinner/Spinner.js
  function Spinner({
    size: size2 = "large",
    accessibilityLabel,
    hasFocusableParent
  }) {
    const isAfterInitialMount = useIsAfterInitialMount();
    const className = classNames(styles2.Spinner, size2 && styles2[variationName("size", size2)]);
    const spinnerSVGMarkup = size2 === "large" ? /* @__PURE__ */ import_react30.default.createElement("svg", {
      viewBox: "0 0 44 44",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ import_react30.default.createElement("path", {
      d: "M15.542 1.487A21.507 21.507 0 00.5 22c0 11.874 9.626 21.5 21.5 21.5 9.847 0 18.364-6.675 20.809-16.072a1.5 1.5 0 00-2.904-.756C37.803 34.755 30.473 40.5 22 40.5 11.783 40.5 3.5 32.217 3.5 22c0-8.137 5.3-15.247 12.942-17.65a1.5 1.5 0 10-.9-2.863z"
    })) : /* @__PURE__ */ import_react30.default.createElement("svg", {
      viewBox: "0 0 20 20",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ import_react30.default.createElement("path", {
      d: "M7.229 1.173a9.25 9.25 0 1011.655 11.412 1.25 1.25 0 10-2.4-.698 6.75 6.75 0 11-8.506-8.329 1.25 1.25 0 10-.75-2.385z"
    }));
    const spanAttributes = {
      ...!hasFocusableParent && {
        role: "status"
      }
    };
    const accessibilityLabelMarkup = (isAfterInitialMount || !hasFocusableParent) && /* @__PURE__ */ import_react30.default.createElement(VisuallyHidden, null, accessibilityLabel);
    return /* @__PURE__ */ import_react30.default.createElement(import_react30.default.Fragment, null, /* @__PURE__ */ import_react30.default.createElement("span", {
      className
    }, spinnerSVGMarkup), /* @__PURE__ */ import_react30.default.createElement("span", spanAttributes, accessibilityLabelMarkup));
  }

  // node_modules/@shopify/polaris/build/esm/components/Popover/Popover.js
  var import_react44 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Popover/set-activator-attributes.js
  function setActivatorAttributes(activator, {
    id,
    active = false,
    ariaHaspopup,
    activatorDisabled = false
  }) {
    if (!activatorDisabled) {
      activator.tabIndex = activator.tabIndex || 0;
    }
    activator.setAttribute("aria-controls", id);
    activator.setAttribute("aria-owns", id);
    activator.setAttribute("aria-expanded", String(active));
    if (ariaHaspopup != null) {
      activator.setAttribute("aria-haspopup", String(ariaHaspopup));
    }
  }

  // node_modules/@shopify/polaris/build/esm/components/Portal/Portal.js
  var import_react33 = __toESM(require_react());
  var import_react_dom = __toESM(require_react_dom());

  // node_modules/@shopify/polaris/build/esm/utilities/portals/hooks.js
  var import_react31 = __toESM(require_react());
  function usePortalsManager() {
    const portalsManager = (0, import_react31.useContext)(PortalsManagerContext);
    if (!portalsManager) {
      throw new Error("No portals manager was provided. Your application must be wrapped in an <AppProvider> component. See https://polaris.shopify.com/components/structure/app-provider for implementation instructions.");
    }
    return portalsManager;
  }

  // node_modules/@shopify/polaris/build/esm/utilities/unique-id/hooks.js
  var import_react32 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/errors.js
  var MissingAppProviderError = class extends Error {
    constructor(message = "") {
      super(`${message ? `${message} ` : message}Your application must be wrapped in an <AppProvider> component. See https://polaris.shopify.com/components/structure/app-provider for implementation instructions.`);
      this.name = "MissingAppProviderError";
    }
  };

  // node_modules/@shopify/polaris/build/esm/utilities/unique-id/hooks.js
  function useUniqueId(prefix2 = "", overrideId = "") {
    const idFactory = (0, import_react32.useContext)(UniqueIdFactoryContext);
    const uniqueIdRef = (0, import_react32.useRef)(null);
    if (!idFactory) {
      throw new MissingAppProviderError("No UniqueIdFactory was provided.");
    }
    if (overrideId) {
      return overrideId;
    }
    if (!uniqueIdRef.current) {
      uniqueIdRef.current = idFactory.nextId(prefix2);
    }
    return uniqueIdRef.current;
  }

  // node_modules/@shopify/polaris/build/esm/components/Portal/Portal.js
  function Portal({
    children: children2,
    idPrefix = "",
    onPortalCreated = noop2
  }) {
    const {
      container
    } = usePortalsManager();
    const uniqueId = useUniqueId("portal");
    const portalId = idPrefix !== "" ? `${idPrefix}-${uniqueId}` : uniqueId;
    (0, import_react33.useEffect)(() => {
      onPortalCreated();
    }, [onPortalCreated]);
    return container ? /* @__PURE__ */ (0, import_react_dom.createPortal)(/* @__PURE__ */ import_react33.default.createElement("div", {
      "data-portal-id": portalId
    }, children2), container) : null;
  }
  function noop2() {
  }

  // node_modules/@shopify/polaris/build/esm/components/Popover/components/PopoverOverlay/PopoverOverlay.js
  var import_react43 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/components.js
  var import_react34 = __toESM(require_react());
  function wrapWithComponent(element, Component6, props) {
    if (element == null) {
      return null;
    }
    return isElementOfType(element, Component6) ? element : /* @__PURE__ */ import_react34.default.createElement(Component6, props, element);
  }
  var isComponent = true ? hotReloadComponentCheck : (AComponent, AnotherComponent) => AComponent === AnotherComponent;
  function isElementOfType(element, Component6) {
    var _element$props;
    if (element == null || !/* @__PURE__ */ (0, import_react34.isValidElement)(element) || typeof element.type === "string") {
      return false;
    }
    const {
      type: defaultType
    } = element;
    const overrideType = (_element$props = element.props) === null || _element$props === void 0 ? void 0 : _element$props.__type__;
    const type = overrideType || defaultType;
    const Components = Array.isArray(Component6) ? Component6 : [Component6];
    return Components.some((AComponent) => typeof type !== "string" && isComponent(AComponent, type));
  }
  function elementChildren(children2, predicate = () => true) {
    return import_react34.Children.toArray(children2).filter((child) => /* @__PURE__ */ (0, import_react34.isValidElement)(child) && predicate(child));
  }
  function hotReloadComponentCheck(AComponent, AnotherComponent) {
    const componentName = AComponent.name;
    const anotherComponentName = AnotherComponent.displayName;
    return AComponent === AnotherComponent || Boolean(componentName) && componentName === anotherComponentName;
  }

  // node_modules/@shopify/polaris/build/esm/components/Popover/Popover.scss.js
  var styles4 = {
    "Popover": "Polaris-Popover",
    "PopoverOverlay": "Polaris-Popover__PopoverOverlay",
    "PopoverOverlay-entering": "Polaris-Popover__PopoverOverlay--entering",
    "PopoverOverlay-open": "Polaris-Popover__PopoverOverlay--open",
    "PopoverOverlay-exiting": "Polaris-Popover__PopoverOverlay--exiting",
    "measuring": "Polaris-Popover--measuring",
    "fullWidth": "Polaris-Popover--fullWidth",
    "Content": "Polaris-Popover__Content",
    "positionedAbove": "Polaris-Popover--positionedAbove",
    "Wrapper": "Polaris-Popover__Wrapper",
    "Content-fullHeight": "Polaris-Popover__Content--fullHeight",
    "Content-fluidContent": "Polaris-Popover__Content--fluidContent",
    "Pane": "Polaris-Popover__Pane",
    "Pane-fixed": "Polaris-Popover__Pane--fixed",
    "Section": "Polaris-Popover__Section",
    "FocusTracker": "Polaris-Popover__FocusTracker",
    "PopoverOverlay-hideOnPrint": "Polaris-Popover__PopoverOverlay--hideOnPrint"
  };

  // node_modules/@shopify/polaris/build/esm/components/KeypressListener/KeypressListener.js
  var import_react36 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/use-isomorphic-layout-effect.js
  var import_react35 = __toESM(require_react());
  var useIsomorphicLayoutEffect = isServer ? import_react35.useEffect : import_react35.useLayoutEffect;

  // node_modules/@shopify/polaris/build/esm/components/KeypressListener/KeypressListener.js
  function KeypressListener({
    keyCode,
    handler,
    keyEvent = "keyup",
    options,
    useCapture
  }) {
    const tracked = (0, import_react36.useRef)({
      handler,
      keyCode
    });
    useIsomorphicLayoutEffect(() => {
      tracked.current = {
        handler,
        keyCode
      };
    }, [handler, keyCode]);
    const handleKeyEvent = (0, import_react36.useCallback)((event) => {
      const {
        handler: handler2,
        keyCode: keyCode2
      } = tracked.current;
      if (event.keyCode === keyCode2) {
        handler2(event);
      }
    }, []);
    (0, import_react36.useEffect)(() => {
      document.addEventListener(keyEvent, handleKeyEvent, useCapture || options);
      return () => {
        document.removeEventListener(keyEvent, handleKeyEvent, useCapture || options);
      };
    }, [keyEvent, handleKeyEvent, useCapture, options]);
    return null;
  }

  // node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/PositionedOverlay.js
  var import_react40 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/utilities/math.js
  function calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset = 0) {
    const activatorTop = activatorRect.top;
    const activatorBottom = activatorTop + activatorRect.height;
    const spaceAbove = activatorRect.top - topBarOffset;
    const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;
    const desiredHeight = overlayRect.height;
    const verticalMargins = overlayMargins.activator + overlayMargins.container;
    const minimumSpaceToScroll = overlayMargins.container;
    const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);
    const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);
    const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;
    const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;
    const heightIfBelow = Math.min(spaceBelow, desiredHeight);
    const heightIfAbove = Math.min(spaceAbove, desiredHeight);
    const containerRectTop = fixed ? 0 : containerRect.top;
    const positionIfAbove = {
      height: heightIfAbove - verticalMargins,
      top: activatorTop + containerRectTop - heightIfAbove,
      positioning: "above"
    };
    const positionIfBelow = {
      height: heightIfBelow - verticalMargins,
      top: activatorBottom + containerRectTop,
      positioning: "below"
    };
    if (preferredPosition === "above") {
      return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;
    }
    if (preferredPosition === "below") {
      return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;
    }
    if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {
      return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;
    }
    return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;
  }
  function calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {
    const maximum = containerRect.width - overlayRect.width;
    if (preferredAlignment === "left") {
      return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));
    } else if (preferredAlignment === "right") {
      const activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);
      return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));
    }
    return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));
  }
  function rectIsOutsideOfRect(inner, outer) {
    const {
      center
    } = inner;
    return center.y < outer.top || center.y > outer.top + outer.height;
  }
  function intersectionWithViewport(rect, viewport = windowRect()) {
    const top = Math.max(rect.top, 0);
    const left = Math.max(rect.left, 0);
    const bottom = Math.min(rect.top + rect.height, viewport.height);
    const right = Math.min(rect.left + rect.width, viewport.width);
    return new Rect({
      top,
      left,
      height: bottom - top,
      width: right - left
    });
  }
  function windowRect() {
    return new Rect({
      top: window.scrollY,
      left: window.scrollX,
      height: window.innerHeight,
      width: document.body.clientWidth
    });
  }

  // node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/PositionedOverlay.scss.js
  var styles5 = {
    "PositionedOverlay": "Polaris-PositionedOverlay",
    "fixed": "Polaris-PositionedOverlay--fixed",
    "calculating": "Polaris-PositionedOverlay--calculating",
    "preventInteraction": "Polaris-PositionedOverlay--preventInteraction"
  };

  // node_modules/@shopify/polaris/build/esm/components/Scrollable/Scrollable.js
  var import_react39 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Scrollable/context.js
  var import_react37 = __toESM(require_react());
  var ScrollableContext = /* @__PURE__ */ (0, import_react37.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/components/Scrollable/Scrollable.scss.js
  var styles6 = {
    "Scrollable": "Polaris-Scrollable",
    "horizontal": "Polaris-Scrollable--horizontal",
    "vertical": "Polaris-Scrollable--vertical",
    "verticalHasScrolling": "Polaris-Scrollable--verticalHasScrolling",
    "hasTopShadow": "Polaris-Scrollable--hasTopShadow",
    "hasBottomShadow": "Polaris-Scrollable--hasBottomShadow"
  };

  // node_modules/@shopify/polaris/build/esm/components/Scrollable/components/ScrollTo/ScrollTo.js
  var import_react38 = __toESM(require_react());
  function ScrollTo() {
    const anchorNode = (0, import_react38.useRef)(null);
    const scrollToPosition = (0, import_react38.useContext)(ScrollableContext);
    (0, import_react38.useEffect)(() => {
      if (!scrollToPosition || !anchorNode.current) {
        return;
      }
      scrollToPosition(anchorNode.current.offsetTop);
    }, [scrollToPosition]);
    const id = useUniqueId(`ScrollTo`);
    return /* @__PURE__ */ import_react38.default.createElement("a", {
      id,
      ref: anchorNode
    });
  }

  // node_modules/@shopify/polaris/build/esm/components/Scrollable/Scrollable.js
  var MAX_SCROLL_DISTANCE = 100;
  var DELTA_THRESHOLD = 0.2;
  var DELTA_PERCENTAGE = 0.2;
  var EVENTS_TO_LOCK = ["scroll", "touchmove", "wheel"];
  var PREFERS_REDUCED_MOTION = prefersReducedMotion();
  var LOW_RES_BUFFER = 2;
  var Scrollable = class extends import_react39.Component {
    constructor(...args) {
      super(...args);
      this.state = {
        topShadow: false,
        bottomShadow: false,
        scrollPosition: 0,
        canScroll: false
      };
      this.stickyManager = new StickyManager();
      this.scrollArea = null;
      this.handleResize = debounce(() => {
        this.handleScroll();
      }, 50, {
        trailing: true
      });
      this.setScrollArea = (scrollArea) => {
        this.scrollArea = scrollArea;
      };
      this.handleScroll = () => {
        const {
          scrollArea
        } = this;
        const {
          scrollPosition: scrollPosition2
        } = this.state;
        const {
          shadow,
          onScrolledToBottom
        } = this.props;
        if (scrollArea == null) {
          return;
        }
        const {
          scrollTop,
          clientHeight,
          scrollHeight
        } = scrollArea;
        const shouldBottomShadow = Boolean(shadow && !(scrollTop + clientHeight >= scrollHeight));
        const shouldTopShadow = Boolean(shadow && scrollTop > 0 && scrollPosition2 > 0);
        const canScroll = scrollHeight > clientHeight;
        const hasScrolledToBottom = scrollHeight - scrollTop <= clientHeight + LOW_RES_BUFFER;
        if (canScroll && hasScrolledToBottom && onScrolledToBottom) {
          onScrolledToBottom();
        }
        this.setState({
          topShadow: shouldTopShadow,
          bottomShadow: shouldBottomShadow,
          scrollPosition: scrollTop,
          canScroll
        });
      };
      this.scrollHint = () => {
        const {
          scrollArea
        } = this;
        if (scrollArea == null) {
          return;
        }
        const {
          clientHeight,
          scrollHeight
        } = scrollArea;
        if (PREFERS_REDUCED_MOTION || this.state.scrollPosition > 0 || scrollHeight <= clientHeight) {
          return;
        }
        const scrollDistance = scrollHeight - clientHeight;
        this.toggleLock();
        this.setState({
          scrollPosition: scrollDistance > MAX_SCROLL_DISTANCE ? MAX_SCROLL_DISTANCE : scrollDistance
        }, () => {
          window.requestAnimationFrame(this.scrollStep);
        });
      };
      this.scrollStep = () => {
        this.setState(({
          scrollPosition: scrollPosition2
        }) => {
          const delta = scrollPosition2 * DELTA_PERCENTAGE;
          return {
            scrollPosition: delta < DELTA_THRESHOLD ? 0 : scrollPosition2 - delta
          };
        }, () => {
          if (this.state.scrollPosition > 0) {
            window.requestAnimationFrame(this.scrollStep);
          } else {
            this.toggleLock(false);
          }
        });
      };
      this.scrollToPosition = (scrollY) => {
        this.setState({
          scrollPosition: scrollY
        });
      };
    }
    static forNode(node) {
      const closestElement = node.closest(scrollable.selector);
      return closestElement instanceof HTMLElement ? closestElement : document;
    }
    componentDidMount() {
      if (this.scrollArea == null) {
        return;
      }
      this.stickyManager.setContainer(this.scrollArea);
      this.scrollArea.addEventListener("scroll", () => {
        window.requestAnimationFrame(this.handleScroll);
      });
      window.addEventListener("resize", this.handleResize);
      window.requestAnimationFrame(() => {
        this.handleScroll();
        if (this.props.hint) {
          this.scrollHint();
        }
      });
    }
    componentWillUnmount() {
      if (this.scrollArea == null) {
        return;
      }
      this.scrollArea.removeEventListener("scroll", this.handleScroll);
      window.removeEventListener("resize", this.handleResize);
      this.stickyManager.removeScrollListener();
    }
    componentDidUpdate() {
      const {
        scrollPosition: scrollPosition2
      } = this.state;
      if (scrollPosition2 && this.scrollArea && scrollPosition2 > 0) {
        this.scrollArea.scrollTop = scrollPosition2;
      }
    }
    render() {
      const {
        topShadow,
        bottomShadow,
        canScroll
      } = this.state;
      const {
        children: children2,
        className,
        horizontal,
        vertical = true,
        shadow,
        hint,
        focusable,
        onScrolledToBottom,
        ...rest
      } = this.props;
      const finalClassName = classNames(className, styles6.Scrollable, vertical && styles6.vertical, horizontal && styles6.horizontal, topShadow && styles6.hasTopShadow, bottomShadow && styles6.hasBottomShadow, vertical && canScroll && styles6.verticalHasScrolling);
      return /* @__PURE__ */ import_react39.default.createElement(ScrollableContext.Provider, {
        value: this.scrollToPosition
      }, /* @__PURE__ */ import_react39.default.createElement(StickyManagerContext.Provider, {
        value: this.stickyManager
      }, /* @__PURE__ */ import_react39.default.createElement("div", Object.assign({
        className: finalClassName
      }, scrollable.props, rest, {
        ref: this.setScrollArea,
        tabIndex: focusable ? 0 : void 0
      }), children2)));
    }
    toggleLock(shouldLock = true) {
      const {
        scrollArea
      } = this;
      if (scrollArea == null) {
        return;
      }
      EVENTS_TO_LOCK.forEach((eventName) => {
        if (shouldLock) {
          scrollArea.addEventListener(eventName, prevent);
        } else {
          scrollArea.removeEventListener(eventName, prevent);
        }
      });
    }
  };
  Scrollable.ScrollTo = ScrollTo;
  function prevent(evt) {
    evt.preventDefault();
  }
  function prefersReducedMotion() {
    try {
      return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    } catch (err) {
      return false;
    }
  }

  // node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/PositionedOverlay.js
  var OBSERVER_CONFIG = {
    childList: true,
    subtree: true,
    characterData: true
  };
  var PositionedOverlay = class extends import_react40.PureComponent {
    constructor(props) {
      super(props);
      this.state = {
        measuring: true,
        activatorRect: getRectForNode(this.props.activator),
        right: void 0,
        left: void 0,
        top: 0,
        height: 0,
        width: null,
        positioning: "below",
        zIndex: null,
        outsideScrollableContainer: false,
        lockPosition: false
      };
      this.overlay = null;
      this.scrollableContainer = null;
      this.observer = void 0;
      this.overlayDetails = () => {
        const {
          measuring,
          left,
          right,
          positioning,
          height,
          activatorRect
        } = this.state;
        return {
          measuring,
          left,
          right,
          desiredHeight: height,
          positioning,
          activatorRect
        };
      };
      this.setOverlay = (node) => {
        this.overlay = node;
      };
      this.handleMeasurement = () => {
        const {
          lockPosition,
          top
        } = this.state;
        this.observer.disconnect();
        this.setState(({
          left,
          top: top2,
          right
        }) => ({
          left,
          right,
          top: top2,
          height: 0,
          positioning: "below",
          measuring: true
        }), () => {
          if (this.overlay == null || this.scrollableContainer == null) {
            return;
          }
          const {
            activator,
            preferredPosition = "below",
            preferredAlignment = "center",
            onScrollOut,
            fullWidth,
            fixed,
            preferInputActivator = true
          } = this.props;
          const preferredActivator = preferInputActivator ? activator.querySelector("input") || activator : activator;
          const activatorRect = getRectForNode(preferredActivator);
          const currentOverlayRect = getRectForNode(this.overlay);
          const scrollableElement = isDocument2(this.scrollableContainer) ? document.body : this.scrollableContainer;
          const scrollableContainerRect = getRectForNode(scrollableElement);
          const overlayRect = fullWidth ? new Rect({
            ...currentOverlayRect,
            width: activatorRect.width
          }) : currentOverlayRect;
          if (scrollableElement === document.body) {
            scrollableContainerRect.height = document.body.scrollHeight;
          }
          let topBarOffset = 0;
          const topBarElement = scrollableElement.querySelector(`${dataPolarisTopBar.selector}`);
          if (topBarElement) {
            topBarOffset = topBarElement.clientHeight;
          }
          const overlayMargins = this.overlay.firstElementChild && this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(this.overlay.firstElementChild) : {
            activator: 0,
            container: 0,
            horizontal: 0
          };
          const containerRect = windowRect();
          const zIndexForLayer = getZIndexForLayerFromNode(activator);
          const zIndex2 = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;
          const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset);
          const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);
          this.setState({
            measuring: false,
            activatorRect: getRectForNode(activator),
            left: preferredAlignment !== "right" ? horizontalPosition : void 0,
            right: preferredAlignment === "right" ? horizontalPosition : void 0,
            top: lockPosition ? top : verticalPosition.top,
            lockPosition: Boolean(fixed),
            height: verticalPosition.height || 0,
            width: fullWidth ? overlayRect.width : null,
            positioning: verticalPosition.positioning,
            outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),
            zIndex: zIndex2
          }, () => {
            if (!this.overlay)
              return;
            this.observer.observe(this.overlay, OBSERVER_CONFIG);
            this.observer.observe(activator, OBSERVER_CONFIG);
          });
        });
      };
      this.observer = new MutationObserver(this.handleMeasurement);
    }
    componentDidMount() {
      this.scrollableContainer = Scrollable.forNode(this.props.activator);
      if (this.scrollableContainer && !this.props.fixed) {
        this.scrollableContainer.addEventListener("scroll", this.handleMeasurement);
      }
      this.handleMeasurement();
    }
    componentWillUnmount() {
      this.observer.disconnect();
      if (this.scrollableContainer && !this.props.fixed) {
        this.scrollableContainer.removeEventListener("scroll", this.handleMeasurement);
      }
    }
    componentDidUpdate() {
      const {
        outsideScrollableContainer,
        top
      } = this.state;
      const {
        onScrollOut,
        active
      } = this.props;
      if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {
        onScrollOut();
      }
    }
    render() {
      const {
        left,
        right,
        top,
        zIndex: zIndex2,
        width
      } = this.state;
      const {
        render,
        fixed,
        preventInteraction,
        classNames: propClassNames,
        zIndexOverride
      } = this.props;
      const style4 = {
        top: top == null || isNaN(top) ? void 0 : top,
        left: left == null || isNaN(left) ? void 0 : left,
        right: right == null || isNaN(right) ? void 0 : right,
        width: width == null || isNaN(width) ? void 0 : width,
        zIndex: zIndexOverride || zIndex2 || void 0
      };
      const className = classNames(styles5.PositionedOverlay, fixed && styles5.fixed, preventInteraction && styles5.preventInteraction, propClassNames);
      return /* @__PURE__ */ import_react40.default.createElement("div", {
        className,
        style: style4,
        ref: this.setOverlay
      }, /* @__PURE__ */ import_react40.default.createElement(EventListener, {
        event: "resize",
        handler: this.handleMeasurement
      }), render(this.overlayDetails()));
    }
    forceUpdatePosition() {
      requestAnimationFrame(this.handleMeasurement);
    }
  };
  function getMarginsForNode(node) {
    const nodeStyles = window.getComputedStyle(node);
    return {
      activator: parseFloat(nodeStyles.marginTop || "0"),
      container: parseFloat(nodeStyles.marginBottom || "0"),
      horizontal: parseFloat(nodeStyles.marginLeft || "0")
    };
  }
  function getZIndexForLayerFromNode(node) {
    const layerNode = node.closest(layer.selector) || document.body;
    const zIndex2 = layerNode === document.body ? "auto" : parseInt(window.getComputedStyle(layerNode).zIndex || "0", 10);
    return zIndex2 === "auto" || isNaN(zIndex2) ? null : zIndex2;
  }
  function isDocument2(node) {
    return node === document;
  }

  // node_modules/@shopify/polaris/build/esm/components/Popover/components/Pane/Pane.js
  var import_react42 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Popover/components/Section/Section.js
  var import_react41 = __toESM(require_react());
  function Section({
    children: children2
  }) {
    return /* @__PURE__ */ import_react41.default.createElement("div", {
      className: styles4.Section
    }, children2);
  }

  // node_modules/@shopify/polaris/build/esm/components/Popover/components/Pane/Pane.js
  function Pane({
    fixed,
    sectioned,
    children: children2,
    height,
    onScrolledToBottom
  }) {
    const className = classNames(styles4.Pane, fixed && styles4["Pane-fixed"]);
    const content = sectioned ? wrapWithComponent(children2, Section, {}) : children2;
    const style4 = height ? {
      height,
      maxHeight: height,
      minHeight: height
    } : void 0;
    return fixed ? /* @__PURE__ */ import_react42.default.createElement("div", {
      style: style4,
      className
    }, content) : /* @__PURE__ */ import_react42.default.createElement(Scrollable, {
      shadow: true,
      className,
      style: style4,
      onScrolledToBottom
    }, content);
  }

  // node_modules/@shopify/polaris/build/esm/components/Popover/components/PopoverOverlay/PopoverOverlay.js
  var PopoverCloseSource;
  (function(PopoverCloseSource2) {
    PopoverCloseSource2[PopoverCloseSource2["Click"] = 0] = "Click";
    PopoverCloseSource2[PopoverCloseSource2["EscapeKeypress"] = 1] = "EscapeKeypress";
    PopoverCloseSource2[PopoverCloseSource2["FocusOut"] = 2] = "FocusOut";
    PopoverCloseSource2[PopoverCloseSource2["ScrollOut"] = 3] = "ScrollOut";
  })(PopoverCloseSource || (PopoverCloseSource = {}));
  var TransitionStatus;
  (function(TransitionStatus3) {
    TransitionStatus3["Entering"] = "entering";
    TransitionStatus3["Entered"] = "entered";
    TransitionStatus3["Exiting"] = "exiting";
    TransitionStatus3["Exited"] = "exited";
  })(TransitionStatus || (TransitionStatus = {}));
  var PopoverOverlay = class extends import_react43.PureComponent {
    constructor(props) {
      super(props);
      this.state = {
        transitionStatus: this.props.active ? TransitionStatus.Entering : TransitionStatus.Exited
      };
      this.contentNode = /* @__PURE__ */ (0, import_react43.createRef)();
      this.enteringTimer = void 0;
      this.exitingTimer = void 0;
      this.overlayRef = void 0;
      this.renderPopover = (overlayDetails) => {
        const {
          measuring,
          desiredHeight,
          positioning
        } = overlayDetails;
        const {
          id,
          children: children2,
          sectioned,
          fullWidth,
          fullHeight,
          fluidContent,
          hideOnPrint,
          colorScheme,
          autofocusTarget
        } = this.props;
        const className = classNames(styles4.Popover, positioning === "above" && styles4.positionedAbove, fullWidth && styles4.fullWidth, measuring && styles4.measuring, hideOnPrint && styles4["PopoverOverlay-hideOnPrint"]);
        const contentStyles = measuring ? void 0 : {
          height: desiredHeight
        };
        const contentClassNames = classNames(styles4.Content, fullHeight && styles4["Content-fullHeight"], fluidContent && styles4["Content-fluidContent"]);
        const content = /* @__PURE__ */ import_react43.default.createElement("div", {
          id,
          tabIndex: autofocusTarget === "none" ? void 0 : -1,
          className: contentClassNames,
          style: contentStyles,
          ref: this.contentNode
        }, renderPopoverContent(children2, {
          sectioned
        }));
        return /* @__PURE__ */ import_react43.default.createElement("div", Object.assign({
          className
        }, overlay.props), /* @__PURE__ */ import_react43.default.createElement(EventListener, {
          event: "click",
          handler: this.handleClick
        }), /* @__PURE__ */ import_react43.default.createElement(EventListener, {
          event: "touchstart",
          handler: this.handleClick
        }), /* @__PURE__ */ import_react43.default.createElement(KeypressListener, {
          keyCode: Key.Escape,
          handler: this.handleEscape
        }), /* @__PURE__ */ import_react43.default.createElement("div", {
          className: styles4.FocusTracker,
          tabIndex: 0,
          onFocus: this.handleFocusFirstItem
        }), /* @__PURE__ */ import_react43.default.createElement(CustomProperties, {
          colorScheme
        }, /* @__PURE__ */ import_react43.default.createElement("div", {
          className: styles4.Wrapper
        }, content)), /* @__PURE__ */ import_react43.default.createElement("div", {
          className: styles4.FocusTracker,
          tabIndex: 0,
          onFocus: this.handleFocusLastItem
        }));
      };
      this.handleClick = (event) => {
        const target = event.target;
        const {
          contentNode,
          props: {
            activator,
            onClose
          }
        } = this;
        const isDescendant = contentNode.current != null && nodeContainsDescendant(contentNode.current, target);
        const isActivatorDescendant = nodeContainsDescendant(activator, target);
        if (isDescendant || isActivatorDescendant || this.state.transitionStatus !== TransitionStatus.Entered) {
          return;
        }
        onClose(PopoverCloseSource.Click);
      };
      this.handleScrollOut = () => {
        this.props.onClose(PopoverCloseSource.ScrollOut);
      };
      this.handleEscape = () => {
        this.props.onClose(PopoverCloseSource.EscapeKeypress);
      };
      this.handleFocusFirstItem = () => {
        this.props.onClose(PopoverCloseSource.FocusOut);
      };
      this.handleFocusLastItem = () => {
        this.props.onClose(PopoverCloseSource.FocusOut);
      };
      this.overlayRef = /* @__PURE__ */ (0, import_react43.createRef)();
    }
    forceUpdatePosition() {
      var _this$overlayRef$curr;
      (_this$overlayRef$curr = this.overlayRef.current) === null || _this$overlayRef$curr === void 0 ? void 0 : _this$overlayRef$curr.forceUpdatePosition();
    }
    changeTransitionStatus(transitionStatus, cb) {
      this.setState({
        transitionStatus
      }, cb);
      this.contentNode.current && this.contentNode.current.getBoundingClientRect();
    }
    componentDidMount() {
      if (this.props.active) {
        this.focusContent();
        this.changeTransitionStatus(TransitionStatus.Entered);
      }
    }
    componentDidUpdate(oldProps) {
      if (this.props.active && !oldProps.active) {
        this.focusContent();
        this.changeTransitionStatus(TransitionStatus.Entering, () => {
          this.clearTransitionTimeout();
          this.enteringTimer = window.setTimeout(() => {
            this.setState({
              transitionStatus: TransitionStatus.Entered
            });
          }, parseInt(tokens.motion["duration-100"].value, 10));
        });
      }
      if (!this.props.active && oldProps.active) {
        this.changeTransitionStatus(TransitionStatus.Exiting, () => {
          this.clearTransitionTimeout();
          this.exitingTimer = window.setTimeout(() => {
            this.setState({
              transitionStatus: TransitionStatus.Exited
            });
          }, parseInt(tokens.motion["duration-100"].value, 10));
        });
      }
    }
    componentWillUnmount() {
      this.clearTransitionTimeout();
    }
    render() {
      const {
        active,
        activator,
        fullWidth,
        preferredPosition = "below",
        preferredAlignment = "center",
        preferInputActivator = true,
        fixed,
        zIndexOverride
      } = this.props;
      const {
        transitionStatus
      } = this.state;
      if (transitionStatus === TransitionStatus.Exited && !active)
        return null;
      const className = classNames(styles4.PopoverOverlay, transitionStatus === TransitionStatus.Entering && styles4["PopoverOverlay-entering"], transitionStatus === TransitionStatus.Entered && styles4["PopoverOverlay-open"], transitionStatus === TransitionStatus.Exiting && styles4["PopoverOverlay-exiting"]);
      return /* @__PURE__ */ import_react43.default.createElement(PositionedOverlay, {
        ref: this.overlayRef,
        fullWidth,
        active,
        activator,
        preferInputActivator,
        preferredPosition,
        preferredAlignment,
        render: this.renderPopover.bind(this),
        fixed,
        onScrollOut: this.handleScrollOut,
        classNames: className,
        zIndexOverride
      });
    }
    clearTransitionTimeout() {
      if (this.enteringTimer) {
        window.clearTimeout(this.enteringTimer);
      }
      if (this.exitingTimer) {
        window.clearTimeout(this.exitingTimer);
      }
    }
    focusContent() {
      const {
        autofocusTarget = "container"
      } = this.props;
      if (autofocusTarget === "none" || this.contentNode == null) {
        return;
      }
      requestAnimationFrame(() => {
        if (this.contentNode.current == null) {
          return;
        }
        const focusableChild = findFirstFocusableNode(this.contentNode.current);
        if (focusableChild && autofocusTarget === "first-node") {
          focusableChild.focus({
            preventScroll: true
          });
        } else {
          this.contentNode.current.focus({
            preventScroll: true
          });
        }
      });
    }
  };
  function renderPopoverContent(children2, props) {
    const childrenArray = import_react43.Children.toArray(children2);
    if (isElementOfType(childrenArray[0], Pane)) {
      return childrenArray;
    }
    return wrapWithComponent(childrenArray, Pane, props);
  }
  function nodeContainsDescendant(rootNode, descendant) {
    if (rootNode === descendant) {
      return true;
    }
    let parent = descendant.parentNode;
    while (parent != null) {
      if (parent === rootNode) {
        return true;
      }
      parent = parent.parentNode;
    }
    return false;
  }

  // node_modules/@shopify/polaris/build/esm/components/Popover/Popover.js
  var PopoverComponent = /* @__PURE__ */ (0, import_react44.forwardRef)(function Popover({
    activatorWrapper = "div",
    children: children2,
    onClose,
    activator,
    preventFocusOnClose,
    active,
    fixed,
    ariaHaspopup,
    preferInputActivator = true,
    colorScheme,
    zIndexOverride,
    ...rest
  }, ref) {
    const [activatorNode, setActivatorNode] = (0, import_react44.useState)();
    const overlayRef = (0, import_react44.useRef)(null);
    const activatorContainer = (0, import_react44.useRef)(null);
    const WrapperComponent = activatorWrapper;
    const id = useUniqueId("popover");
    function forceUpdatePosition() {
      var _overlayRef$current;
      (_overlayRef$current = overlayRef.current) === null || _overlayRef$current === void 0 ? void 0 : _overlayRef$current.forceUpdatePosition();
    }
    (0, import_react44.useImperativeHandle)(ref, () => {
      return {
        forceUpdatePosition
      };
    });
    const setAccessibilityAttributes = (0, import_react44.useCallback)(() => {
      if (activatorContainer.current == null) {
        return;
      }
      const firstFocusable = findFirstFocusableNodeIncludingDisabled(activatorContainer.current);
      const focusableActivator = firstFocusable || activatorContainer.current;
      const activatorDisabled = "disabled" in focusableActivator && Boolean(focusableActivator.disabled);
      setActivatorAttributes(focusableActivator, {
        id,
        active,
        ariaHaspopup,
        activatorDisabled
      });
    }, [id, active, ariaHaspopup]);
    const handleClose = (source) => {
      onClose(source);
      if (activatorContainer.current == null || preventFocusOnClose) {
        return;
      }
      if ((source === PopoverCloseSource.FocusOut || source === PopoverCloseSource.EscapeKeypress) && activatorNode) {
        const focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;
        if (!focusNextFocusableNode(focusableActivator, isInPortal)) {
          focusableActivator.focus();
        }
      }
    };
    (0, import_react44.useEffect)(() => {
      if (!activatorNode && activatorContainer.current) {
        setActivatorNode(activatorContainer.current.firstElementChild);
      } else if (activatorNode && activatorContainer.current && !activatorContainer.current.contains(activatorNode)) {
        setActivatorNode(activatorContainer.current.firstElementChild);
      }
      setAccessibilityAttributes();
    }, [activatorNode, setAccessibilityAttributes]);
    (0, import_react44.useEffect)(() => {
      if (activatorNode && activatorContainer.current) {
        setActivatorNode(activatorContainer.current.firstElementChild);
      }
      setAccessibilityAttributes();
    }, [activatorNode, setAccessibilityAttributes]);
    if (colorScheme && true) {
      console.warn("Deprecation: The `colorScheme` prop on the `Popover` component has been deprecated. See the v10 migration guide for replacing dark color scheme styles. https://github.com/Shopify/polaris/blob/main/documentation/guides/migrating-from-v9-to-v10.md");
    }
    const portal2 = activatorNode ? /* @__PURE__ */ import_react44.default.createElement(Portal, {
      idPrefix: "popover"
    }, /* @__PURE__ */ import_react44.default.createElement(PopoverOverlay, Object.assign({
      ref: overlayRef,
      id,
      activator: activatorNode,
      preferInputActivator,
      onClose: handleClose,
      active,
      fixed,
      colorScheme,
      zIndexOverride
    }, rest), children2)) : null;
    return /* @__PURE__ */ import_react44.default.createElement(WrapperComponent, {
      ref: activatorContainer
    }, import_react44.Children.only(activator), portal2);
  });
  function isInPortal(element) {
    let parentElement = element.parentElement;
    while (parentElement) {
      if (parentElement.matches(portal.selector))
        return false;
      parentElement = parentElement.parentElement;
    }
    return true;
  }
  var Popover2 = Object.assign(PopoverComponent, {
    Pane,
    Section
  });

  // node_modules/@shopify/polaris/build/esm/components/ActionList/ActionList.js
  var import_react55 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/ActionList/ActionList.scss.js
  var styles7 = {
    "ActionList": "Polaris-ActionList",
    "Section-withoutTitle": "Polaris-ActionList__Section--withoutTitle",
    "Actions": "Polaris-ActionList__Actions",
    "Section": "Polaris-ActionList__Section",
    "Title": "Polaris-ActionList__Title",
    "Item": "Polaris-ActionList__Item",
    "active": "Polaris-ActionList--active",
    "destructive": "Polaris-ActionList--destructive",
    "disabled": "Polaris-ActionList--disabled",
    "Prefix": "Polaris-ActionList__Prefix",
    "Suffix": "Polaris-ActionList__Suffix",
    "Content": "Polaris-ActionList__Content",
    "ContentBlock": "Polaris-ActionList__ContentBlock",
    "ContentBlockInner": "Polaris-ActionList__ContentBlockInner",
    "Text": "Polaris-ActionList__Text"
  };

  // node_modules/@shopify/polaris/build/esm/components/ActionList/components/Section/Section.js
  var import_react54 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/ActionList/components/Item/Item.js
  var import_react53 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/TextStyle/TextStyle.js
  var import_react45 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/TextStyle/TextStyle.scss.js
  var styles8 = {
    "variationPositive": "Polaris-TextStyle--variationPositive",
    "variationNegative": "Polaris-TextStyle--variationNegative",
    "variationWarning": "Polaris-TextStyle--variationWarning",
    "variationCode": "Polaris-TextStyle--variationCode",
    "variationStrong": "Polaris-TextStyle--variationStrong",
    "variationSubdued": "Polaris-TextStyle--variationSubdued"
  };

  // node_modules/@shopify/polaris/build/esm/components/TextStyle/TextStyle.js
  var VariationValue;
  (function(VariationValue2) {
    VariationValue2["Positive"] = "positive";
    VariationValue2["Negative"] = "negative";
    VariationValue2["Warning"] = "warning";
    VariationValue2["Strong"] = "strong";
    VariationValue2["Subdued"] = "subdued";
    VariationValue2["Code"] = "code";
  })(VariationValue || (VariationValue = {}));
  function TextStyle({
    variation,
    children: children2
  }) {
    const className = classNames(variation && styles8[variationName("variation", variation)], variation === VariationValue.Code && styles8.code);
    const Element2 = variationElement(variation);
    return /* @__PURE__ */ import_react45.default.createElement(Element2, {
      className
    }, children2);
  }
  function variationElement(variation) {
    return variation === VariationValue.Code ? "code" : "span";
  }

  // node_modules/@shopify/polaris/build/esm/components/Badge/Badge.js
  var import_react50 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/within-filter-context.js
  var import_react46 = __toESM(require_react());
  var WithinFilterContext = /* @__PURE__ */ (0, import_react46.createContext)(false);

  // node_modules/@shopify/polaris/build/esm/components/Badge/Badge.scss.js
  var styles9 = {
    "Badge": "Polaris-Badge",
    "sizeSmall": "Polaris-Badge--sizeSmall",
    "statusSuccess": "Polaris-Badge--statusSuccess",
    "statusInfo": "Polaris-Badge--statusInfo",
    "statusAttention": "Polaris-Badge--statusAttention",
    "statusWarning": "Polaris-Badge--statusWarning",
    "statusCritical": "Polaris-Badge--statusCritical",
    "statusNew": "Polaris-Badge--statusNew",
    "withinFilter": "Polaris-Badge--withinFilter",
    "Icon": "Polaris-Badge__Icon",
    "PipContainer": "Polaris-Badge__PipContainer"
  };

  // node_modules/@shopify/polaris/build/esm/components/Badge/types.js
  var StatusValue;
  (function(StatusValue2) {
    StatusValue2["Info"] = "info";
    StatusValue2["Success"] = "success";
    StatusValue2["Warning"] = "warning";
    StatusValue2["Critical"] = "critical";
    StatusValue2["Attention"] = "attention";
    StatusValue2["New"] = "new";
  })(StatusValue || (StatusValue = {}));
  var ProgressValue;
  (function(ProgressValue2) {
    ProgressValue2["Incomplete"] = "incomplete";
    ProgressValue2["PartiallyComplete"] = "partiallyComplete";
    ProgressValue2["Complete"] = "complete";
  })(ProgressValue || (ProgressValue = {}));

  // node_modules/@shopify/polaris/build/esm/components/Badge/utils.js
  function getDefaultAccessibilityLabel(i18n, progress, status) {
    let progressLabel = "";
    let statusLabel = "";
    if (!progress && !status) {
      return "";
    }
    switch (progress) {
      case ProgressValue.Incomplete:
        progressLabel = i18n.translate("Polaris.Badge.PROGRESS_LABELS.incomplete");
        break;
      case ProgressValue.PartiallyComplete:
        progressLabel = i18n.translate("Polaris.Badge.PROGRESS_LABELS.partiallyComplete");
        break;
      case ProgressValue.Complete:
        progressLabel = i18n.translate("Polaris.Badge.PROGRESS_LABELS.complete");
        break;
    }
    switch (status) {
      case StatusValue.Info:
        statusLabel = i18n.translate("Polaris.Badge.STATUS_LABELS.info");
        break;
      case StatusValue.Success:
        statusLabel = i18n.translate("Polaris.Badge.STATUS_LABELS.success");
        break;
      case StatusValue.Warning:
        statusLabel = i18n.translate("Polaris.Badge.STATUS_LABELS.warning");
        break;
      case StatusValue.Critical:
        statusLabel = i18n.translate("Polaris.Badge.STATUS_LABELS.critical");
        break;
      case StatusValue.Attention:
        statusLabel = i18n.translate("Polaris.Badge.STATUS_LABELS.attention");
        break;
      case StatusValue.New:
        statusLabel = i18n.translate("Polaris.Badge.STATUS_LABELS.new");
        break;
    }
    if (!status && progress) {
      return progressLabel;
    } else if (status && !progress) {
      return statusLabel;
    } else {
      return i18n.translate("Polaris.Badge.progressAndStatus", {
        progressLabel,
        statusLabel
      });
    }
  }

  // node_modules/@shopify/polaris/build/esm/components/Badge/components/Pip/Pip.js
  var import_react48 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Badge/components/Pip/Pip.scss.js
  var styles10 = {
    "Pip": "Polaris-Badge-Pip",
    "statusInfo": "Polaris-Badge-Pip--statusInfo",
    "statusSuccess": "Polaris-Badge-Pip--statusSuccess",
    "statusNew": "Polaris-Badge-Pip--statusNew",
    "statusAttention": "Polaris-Badge-Pip--statusAttention",
    "statusWarning": "Polaris-Badge-Pip--statusWarning",
    "statusCritical": "Polaris-Badge-Pip--statusCritical",
    "progressIncomplete": "Polaris-Badge-Pip--progressIncomplete",
    "progressPartiallyComplete": "Polaris-Badge-Pip--progressPartiallyComplete",
    "progressComplete": "Polaris-Badge-Pip--progressComplete"
  };

  // node_modules/@shopify/polaris/build/esm/utilities/i18n/hooks.js
  var import_react47 = __toESM(require_react());
  function useI18n() {
    const i18n = (0, import_react47.useContext)(I18nContext);
    if (!i18n) {
      throw new MissingAppProviderError("No i18n was provided.");
    }
    return i18n;
  }

  // node_modules/@shopify/polaris/build/esm/components/Badge/components/Pip/Pip.js
  function Pip({
    status,
    progress = "complete",
    accessibilityLabelOverride
  }) {
    const i18n = useI18n();
    const className = classNames(styles10.Pip, status && styles10[variationName("status", status)], progress && styles10[variationName("progress", progress)]);
    const accessibilityLabel = accessibilityLabelOverride ? accessibilityLabelOverride : getDefaultAccessibilityLabel(i18n, progress, status);
    return /* @__PURE__ */ import_react48.default.createElement("span", {
      className
    }, /* @__PURE__ */ import_react48.default.createElement(VisuallyHidden, null, accessibilityLabel));
  }

  // node_modules/@shopify/polaris/build/esm/components/Icon/Icon.js
  var import_react49 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Icon/Icon.scss.js
  var styles11 = {
    "Icon": "Polaris-Icon",
    "applyColor": "Polaris-Icon--applyColor",
    "hasBackdrop": "Polaris-Icon--hasBackdrop",
    "colorBase": "Polaris-Icon--colorBase",
    "colorSubdued": "Polaris-Icon--colorSubdued",
    "colorCritical": "Polaris-Icon--colorCritical",
    "colorInteractive": "Polaris-Icon--colorInteractive",
    "colorWarning": "Polaris-Icon--colorWarning",
    "colorHighlight": "Polaris-Icon--colorHighlight",
    "colorSuccess": "Polaris-Icon--colorSuccess",
    "colorPrimary": "Polaris-Icon--colorPrimary",
    "Svg": "Polaris-Icon__Svg",
    "Img": "Polaris-Icon__Img",
    "Placeholder": "Polaris-Icon__Placeholder"
  };

  // node_modules/@shopify/polaris/build/esm/components/Icon/Icon.js
  var COLORS_WITH_BACKDROPS = ["base", "critical", "highlight", "success", "warning"];
  function Icon({
    source,
    color,
    backdrop,
    accessibilityLabel
  }) {
    let sourceType;
    if (typeof source === "function") {
      sourceType = "function";
    } else if (source === "placeholder") {
      sourceType = "placeholder";
    } else {
      sourceType = "external";
    }
    if (color && sourceType === "external" && true) {
      console.warn("Recoloring external SVGs is not supported. Set the intended color on your SVG instead.");
    }
    if (backdrop && color && !COLORS_WITH_BACKDROPS.includes(color) && true) {
      console.warn(`The ${color} variant does not have a supported backdrop color`);
    }
    const className = classNames(styles11.Icon, color && styles11[variationName("color", color)], color && styles11.applyColor, backdrop && styles11.hasBackdrop);
    const SourceComponent = source;
    const contentMarkup = {
      function: /* @__PURE__ */ import_react49.default.createElement(SourceComponent, {
        className: styles11.Svg,
        focusable: "false",
        "aria-hidden": "true"
      }),
      placeholder: /* @__PURE__ */ import_react49.default.createElement("div", {
        className: styles11.Placeholder
      }),
      external: /* @__PURE__ */ import_react49.default.createElement("img", {
        className: styles11.Img,
        src: `data:image/svg+xml;utf8,${source}`,
        alt: "",
        "aria-hidden": "true"
      })
    };
    return /* @__PURE__ */ import_react49.default.createElement("span", {
      className
    }, /* @__PURE__ */ import_react49.default.createElement(VisuallyHidden, null, accessibilityLabel), contentMarkup[sourceType]);
  }

  // node_modules/@shopify/polaris/build/esm/components/Badge/Badge.js
  var DEFAULT_SIZE = "medium";
  function Badge({
    children: children2,
    status,
    progress,
    icon,
    size: size2 = DEFAULT_SIZE,
    statusAndProgressLabelOverride
  }) {
    const i18n = useI18n();
    const withinFilter = (0, import_react50.useContext)(WithinFilterContext);
    const className = classNames(styles9.Badge, status && styles9[variationName("status", status)], icon && styles9.icon, size2 && size2 !== DEFAULT_SIZE && styles9[variationName("size", size2)], withinFilter && styles9.withinFilter);
    const accessibilityLabel = statusAndProgressLabelOverride ? statusAndProgressLabelOverride : getDefaultAccessibilityLabel(i18n, progress, status);
    let accessibilityMarkup = Boolean(accessibilityLabel) && /* @__PURE__ */ import_react50.default.createElement(VisuallyHidden, null, accessibilityLabel);
    if (progress && !icon) {
      accessibilityMarkup = /* @__PURE__ */ import_react50.default.createElement("span", {
        className: styles9.PipContainer
      }, /* @__PURE__ */ import_react50.default.createElement(Pip, {
        progress,
        status,
        accessibilityLabelOverride: accessibilityLabel
      }));
    }
    return /* @__PURE__ */ import_react50.default.createElement("span", {
      className
    }, accessibilityMarkup, icon && /* @__PURE__ */ import_react50.default.createElement("span", {
      className: styles9.Icon
    }, /* @__PURE__ */ import_react50.default.createElement(Icon, {
      source: icon
    })), children2 && /* @__PURE__ */ import_react50.default.createElement("span", null, children2));
  }
  Badge.Pip = Pip;

  // node_modules/@shopify/polaris/build/esm/components/UnstyledLink/UnstyledLink.js
  var import_react52 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/link/hooks.js
  var import_react51 = __toESM(require_react());
  function useLink() {
    return (0, import_react51.useContext)(LinkContext);
  }

  // node_modules/@shopify/polaris/build/esm/components/UnstyledLink/UnstyledLink.js
  var UnstyledLink = /* @__PURE__ */ (0, import_react52.memo)(/* @__PURE__ */ (0, import_react52.forwardRef)(function UnstyledLink2(props, _ref) {
    const LinkComponent = useLink();
    if (LinkComponent) {
      return /* @__PURE__ */ import_react52.default.createElement(LinkComponent, Object.assign({}, unstyled.props, props));
    }
    const {
      external,
      url,
      ...rest
    } = props;
    const target = external ? "_blank" : void 0;
    const rel = external ? "noopener noreferrer" : void 0;
    return /* @__PURE__ */ import_react52.default.createElement("a", Object.assign({
      target
    }, rest, {
      href: url,
      rel
    }, unstyled.props));
  }));

  // node_modules/@shopify/polaris/build/esm/components/ActionList/components/Item/Item.js
  function Item({
    id,
    badge,
    content,
    accessibilityLabel,
    helpText,
    url,
    onAction,
    icon,
    image,
    prefix: prefix2,
    suffix,
    disabled,
    external,
    destructive,
    ellipsis,
    active,
    role
  }) {
    const className = classNames(styles7.Item, disabled && styles7.disabled, destructive && styles7.destructive, active && styles7.active);
    let prefixMarkup = null;
    if (prefix2) {
      prefixMarkup = /* @__PURE__ */ import_react53.default.createElement("span", {
        className: styles7.Prefix
      }, prefix2);
    } else if (icon) {
      prefixMarkup = /* @__PURE__ */ import_react53.default.createElement("span", {
        className: styles7.Prefix
      }, /* @__PURE__ */ import_react53.default.createElement(Icon, {
        source: icon
      }));
    } else if (image) {
      prefixMarkup = /* @__PURE__ */ import_react53.default.createElement("span", {
        role: "presentation",
        className: styles7.Prefix,
        style: {
          backgroundImage: `url(${image}`
        }
      });
    }
    const contentText = ellipsis && content ? `${content}\u2026` : content;
    const contentMarkup = helpText ? /* @__PURE__ */ import_react53.default.createElement("span", {
      className: styles7.ContentBlock
    }, /* @__PURE__ */ import_react53.default.createElement("span", {
      className: styles7.ContentBlockInner
    }, contentText), /* @__PURE__ */ import_react53.default.createElement(TextStyle, {
      variation: "subdued"
    }, helpText)) : contentText;
    const badgeMarkup = badge && /* @__PURE__ */ import_react53.default.createElement("span", {
      className: styles7.Suffix
    }, /* @__PURE__ */ import_react53.default.createElement(Badge, {
      status: badge.status
    }, badge.content));
    const suffixMarkup = suffix && /* @__PURE__ */ import_react53.default.createElement("span", {
      className: styles7.Suffix
    }, suffix);
    const textMarkup = /* @__PURE__ */ import_react53.default.createElement("span", {
      className: styles7.Text
    }, contentMarkup);
    const contentElement = /* @__PURE__ */ import_react53.default.createElement("span", {
      className: styles7.Content
    }, prefixMarkup, textMarkup, badgeMarkup, suffixMarkup);
    const scrollMarkup = active ? /* @__PURE__ */ import_react53.default.createElement(Scrollable.ScrollTo, null) : null;
    const control = url ? /* @__PURE__ */ import_react53.default.createElement(UnstyledLink, {
      id,
      url: disabled ? null : url,
      className,
      external,
      "aria-label": accessibilityLabel,
      onClick: disabled ? null : onAction,
      role
    }, contentElement) : /* @__PURE__ */ import_react53.default.createElement("button", {
      id,
      type: "button",
      className,
      disabled,
      "aria-label": accessibilityLabel,
      onClick: onAction,
      onMouseUp: handleMouseUpByBlurring,
      role
    }, contentElement);
    return /* @__PURE__ */ import_react53.default.createElement(import_react53.default.Fragment, null, scrollMarkup, control);
  }

  // node_modules/@shopify/polaris/build/esm/components/ActionList/components/Section/Section.js
  function Section2({
    section,
    hasMultipleSections,
    actionRole,
    onActionAnyItem
  }) {
    const handleAction = (itemOnAction) => {
      return () => {
        if (itemOnAction) {
          itemOnAction();
        }
        if (onActionAnyItem) {
          onActionAnyItem();
        }
      };
    };
    const actionMarkup = section.items.map(({
      content,
      helpText,
      onAction,
      ...item
    }, index2) => {
      return /* @__PURE__ */ import_react54.default.createElement("li", {
        key: `${content}-${index2}`,
        role: actionRole === "menuitem" ? "presentation" : void 0
      }, /* @__PURE__ */ import_react54.default.createElement(Item, Object.assign({
        content,
        helpText,
        role: actionRole,
        onAction: handleAction(onAction)
      }, item)));
    });
    const className = section.title ? void 0 : styles7["Section-withoutTitle"];
    const titleMarkup = section.title ? /* @__PURE__ */ import_react54.default.createElement("p", {
      className: styles7.Title
    }, section.title) : null;
    let sectionRole;
    switch (actionRole) {
      case "option":
        sectionRole = "presentation";
        break;
      case "menuitem":
        sectionRole = !hasMultipleSections ? "menu" : "presentation";
        break;
      default:
        sectionRole = void 0;
        break;
    }
    const sectionMarkup = /* @__PURE__ */ import_react54.default.createElement("div", {
      className
    }, titleMarkup, /* @__PURE__ */ import_react54.default.createElement("ul", {
      className: styles7.Actions,
      role: sectionRole,
      tabIndex: !hasMultipleSections ? -1 : void 0
    }, actionMarkup));
    return hasMultipleSections ? /* @__PURE__ */ import_react54.default.createElement("li", {
      className: styles7.Section,
      role: "presentation"
    }, sectionMarkup) : sectionMarkup;
  }

  // node_modules/@shopify/polaris/build/esm/components/ActionList/ActionList.js
  function ActionList({
    items,
    sections = [],
    actionRole,
    onActionAnyItem
  }) {
    let finalSections = [];
    const actionListRef = (0, import_react55.useRef)(null);
    if (items) {
      finalSections = [{
        items
      }, ...sections];
    } else if (sections) {
      finalSections = sections;
    }
    const className = classNames(styles7.ActionList);
    const hasMultipleSections = finalSections.length > 1;
    const Element2 = hasMultipleSections ? "ul" : "div";
    const elementRole = hasMultipleSections && actionRole === "menuitem" ? "menu" : void 0;
    const elementTabIndex = hasMultipleSections && actionRole === "menuitem" ? -1 : void 0;
    const sectionMarkup = finalSections.map((section, index2) => {
      return section.items.length > 0 ? /* @__PURE__ */ import_react55.default.createElement(Section2, {
        key: section.title || index2,
        section,
        hasMultipleSections,
        actionRole,
        onActionAnyItem
      }) : null;
    });
    const handleFocusPreviousItem = (evt) => {
      evt.preventDefault();
      if (actionListRef.current && evt.target) {
        if (actionListRef.current.contains(evt.target)) {
          wrapFocusPreviousFocusableMenuItem(actionListRef.current, evt.target);
        }
      }
    };
    const handleFocusNextItem = (evt) => {
      evt.preventDefault();
      if (actionListRef.current && evt.target) {
        if (actionListRef.current.contains(evt.target)) {
          wrapFocusNextFocusableMenuItem(actionListRef.current, evt.target);
        }
      }
    };
    const listeners = actionRole === "menuitem" ? /* @__PURE__ */ import_react55.default.createElement(import_react55.default.Fragment, null, /* @__PURE__ */ import_react55.default.createElement(KeypressListener, {
      keyEvent: "keydown",
      keyCode: Key.DownArrow,
      handler: handleFocusNextItem
    }), /* @__PURE__ */ import_react55.default.createElement(KeypressListener, {
      keyEvent: "keydown",
      keyCode: Key.UpArrow,
      handler: handleFocusPreviousItem
    })) : null;
    return /* @__PURE__ */ import_react55.default.createElement(Element2, {
      ref: actionListRef,
      className,
      role: elementRole,
      tabIndex: elementTabIndex
    }, listeners, sectionMarkup);
  }
  ActionList.Item = Item;

  // node_modules/@shopify/polaris/build/esm/components/UnstyledButton/UnstyledButton.js
  var import_react56 = __toESM(require_react());
  function UnstyledButton({
    id,
    children: children2,
    className,
    url,
    external,
    download,
    submit,
    disabled,
    loading,
    pressed,
    accessibilityLabel,
    role,
    ariaControls,
    ariaExpanded,
    ariaDescribedBy,
    ariaChecked,
    onClick,
    onFocus,
    onBlur,
    onKeyDown,
    onKeyPress,
    onKeyUp,
    onMouseEnter,
    onTouchStart,
    ...rest
  }) {
    let buttonMarkup;
    const commonProps = {
      id,
      className,
      "aria-label": accessibilityLabel
    };
    const interactiveProps = {
      ...commonProps,
      role,
      onClick,
      onFocus,
      onBlur,
      onMouseUp: handleMouseUpByBlurring,
      onMouseEnter,
      onTouchStart
    };
    if (url) {
      buttonMarkup = disabled ? /* @__PURE__ */ import_react56.default.createElement("a", commonProps, children2) : /* @__PURE__ */ import_react56.default.createElement(UnstyledLink, Object.assign({}, interactiveProps, {
        url,
        external,
        download
      }, rest), children2);
    } else {
      buttonMarkup = /* @__PURE__ */ import_react56.default.createElement("button", Object.assign({}, interactiveProps, {
        type: submit ? "submit" : "button",
        disabled,
        "aria-busy": loading ? true : void 0,
        "aria-controls": ariaControls,
        "aria-expanded": ariaExpanded,
        "aria-describedby": ariaDescribedBy,
        "aria-checked": ariaChecked,
        "aria-pressed": pressed,
        onKeyDown,
        onKeyUp,
        onKeyPress
      }, rest), children2);
    }
    return buttonMarkup;
  }

  // node_modules/@shopify/polaris/build/esm/components/Button/Button.js
  var DEFAULT_SIZE2 = "medium";
  function Button({
    id,
    children: children2,
    url,
    disabled,
    external,
    download,
    submit,
    loading,
    pressed,
    accessibilityLabel,
    role,
    ariaControls,
    ariaExpanded,
    ariaDescribedBy,
    ariaChecked,
    onClick,
    onFocus,
    onBlur,
    onKeyDown,
    onKeyPress,
    onKeyUp,
    onMouseEnter,
    onTouchStart,
    onPointerDown,
    icon,
    primary,
    outline,
    destructive,
    disclosure,
    plain,
    monochrome,
    removeUnderline,
    size: size2 = DEFAULT_SIZE2,
    textAlign,
    fullWidth,
    connectedDisclosure
  }) {
    const i18n = useI18n();
    const isDisabled = disabled || loading;
    const className = classNames(styles.Button, primary && styles.primary, outline && styles.outline, destructive && styles.destructive, isDisabled && styles.disabled, loading && styles.loading, plain && styles.plain, pressed && !disabled && !url && styles.pressed, monochrome && styles.monochrome, size2 && size2 !== DEFAULT_SIZE2 && styles[variationName("size", size2)], textAlign && styles[variationName("textAlign", textAlign)], fullWidth && styles.fullWidth, icon && children2 == null && styles.iconOnly, connectedDisclosure && styles.connectedDisclosure, removeUnderline && styles.removeUnderline);
    const disclosureMarkup = disclosure ? /* @__PURE__ */ import_react57.default.createElement("span", {
      className: styles.Icon
    }, /* @__PURE__ */ import_react57.default.createElement("div", {
      className: classNames(styles.DisclosureIcon, loading && styles.hidden)
    }, /* @__PURE__ */ import_react57.default.createElement(Icon, {
      source: loading ? "placeholder" : getDisclosureIconSource(disclosure)
    }))) : null;
    const iconSource = isIconSource(icon) ? /* @__PURE__ */ import_react57.default.createElement(Icon, {
      source: loading ? "placeholder" : icon
    }) : icon;
    const iconMarkup = iconSource ? /* @__PURE__ */ import_react57.default.createElement("span", {
      className: classNames(styles.Icon, loading && styles.hidden)
    }, iconSource) : null;
    const childMarkup = children2 ? /* @__PURE__ */ import_react57.default.createElement("span", {
      className: classNames(styles.Text, removeUnderline && styles.removeUnderline),
      key: disabled ? "text-disabled" : "text"
    }, children2) : null;
    const spinnerSVGMarkup = loading ? /* @__PURE__ */ import_react57.default.createElement("span", {
      className: styles.Spinner
    }, /* @__PURE__ */ import_react57.default.createElement(Spinner, {
      size: "small",
      accessibilityLabel: i18n.translate("Polaris.Button.spinnerAccessibilityLabel")
    })) : null;
    const [disclosureActive, setDisclosureActive] = (0, import_react57.useState)(false);
    const toggleDisclosureActive = (0, import_react57.useCallback)(() => {
      setDisclosureActive((disclosureActive2) => !disclosureActive2);
    }, []);
    let connectedDisclosureMarkup;
    if (connectedDisclosure) {
      const connectedDisclosureClassName = classNames(styles.Button, primary && styles.primary, outline && styles.outline, size2 && size2 !== DEFAULT_SIZE2 && styles[variationName("size", size2)], textAlign && styles[variationName("textAlign", textAlign)], destructive && styles.destructive, connectedDisclosure.disabled && styles.disabled, styles.iconOnly, styles.ConnectedDisclosure, monochrome && styles.monochrome);
      const defaultLabel = i18n.translate("Polaris.Button.connectedDisclosureAccessibilityLabel");
      const {
        disabled: disabled2,
        accessibilityLabel: disclosureLabel = defaultLabel
      } = connectedDisclosure;
      const connectedDisclosureActivator = /* @__PURE__ */ import_react57.default.createElement("button", {
        type: "button",
        className: connectedDisclosureClassName,
        disabled: disabled2,
        "aria-label": disclosureLabel,
        "aria-describedby": ariaDescribedBy,
        "aria-checked": ariaChecked,
        onClick: toggleDisclosureActive,
        onMouseUp: handleMouseUpByBlurring
      }, /* @__PURE__ */ import_react57.default.createElement("span", {
        className: styles.Icon
      }, /* @__PURE__ */ import_react57.default.createElement(Icon, {
        source: SvgCaretDownMinor
      })));
      connectedDisclosureMarkup = /* @__PURE__ */ import_react57.default.createElement(Popover2, {
        active: disclosureActive,
        onClose: toggleDisclosureActive,
        activator: connectedDisclosureActivator,
        preferredAlignment: "right"
      }, /* @__PURE__ */ import_react57.default.createElement(ActionList, {
        items: connectedDisclosure.actions,
        onActionAnyItem: toggleDisclosureActive
      }));
    }
    const commonProps = {
      id,
      className,
      accessibilityLabel,
      ariaDescribedBy,
      role,
      onClick,
      onFocus,
      onBlur,
      onMouseUp: handleMouseUpByBlurring,
      onMouseEnter,
      onTouchStart
    };
    const linkProps = {
      url,
      external,
      download
    };
    const actionProps = {
      submit,
      disabled: isDisabled,
      loading,
      ariaControls,
      ariaExpanded,
      ariaChecked,
      pressed,
      onKeyDown,
      onKeyUp,
      onKeyPress,
      onPointerDown
    };
    const buttonMarkup = /* @__PURE__ */ import_react57.default.createElement(UnstyledButton, Object.assign({}, commonProps, linkProps, actionProps), /* @__PURE__ */ import_react57.default.createElement("span", {
      className: styles.Content
    }, spinnerSVGMarkup, iconMarkup, childMarkup, disclosureMarkup));
    return connectedDisclosureMarkup ? /* @__PURE__ */ import_react57.default.createElement("div", {
      className: styles.ConnectedDisclosureWrapper
    }, buttonMarkup, connectedDisclosureMarkup) : buttonMarkup;
  }
  function isIconSource(x) {
    return typeof x === "string" || typeof x === "object" && x.body || typeof x === "function";
  }
  function getDisclosureIconSource(disclosure) {
    if (disclosure === "select") {
      return SvgSelectMinor;
    }
    return disclosure === "up" ? SvgCaretUpMinor : SvgCaretDownMinor;
  }

  // node_modules/@shopify/polaris/build/esm/components/Button/utils.js
  function buttonsFrom(actions, overrides = {}) {
    if (Array.isArray(actions)) {
      return actions.map((action, index2) => buttonFrom(action, overrides, index2));
    } else {
      const action = actions;
      return buttonFrom(action, overrides);
    }
  }
  function buttonFrom({
    content,
    onAction,
    ...action
  }, overrides, key) {
    return /* @__PURE__ */ import_react58.default.createElement(Button, Object.assign({
      key,
      onClick: onAction
    }, action, overrides), content);
  }

  // node_modules/@shopify/polaris/build/esm/components/ButtonGroup/ButtonGroup.js
  var import_react60 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/ButtonGroup/ButtonGroup.scss.js
  var styles12 = {
    "ButtonGroup": "Polaris-ButtonGroup",
    "Item": "Polaris-ButtonGroup__Item",
    "Item-plain": "Polaris-ButtonGroup__Item--plain",
    "segmented": "Polaris-ButtonGroup--segmented",
    "Item-focused": "Polaris-ButtonGroup__Item--focused",
    "fullWidth": "Polaris-ButtonGroup--fullWidth",
    "extraTight": "Polaris-ButtonGroup--extraTight",
    "tight": "Polaris-ButtonGroup--tight",
    "loose": "Polaris-ButtonGroup--loose"
  };

  // node_modules/@shopify/polaris/build/esm/components/ButtonGroup/components/Item/Item.js
  var import_react59 = __toESM(require_react());
  function Item2({
    button
  }) {
    const {
      value: focused,
      setTrue: forceTrueFocused,
      setFalse: forceFalseFocused
    } = useToggle(false);
    const className = classNames(styles12.Item, focused && styles12["Item-focused"], button.props.plain && styles12["Item-plain"]);
    return /* @__PURE__ */ import_react59.default.createElement("div", {
      className,
      onFocus: forceTrueFocused,
      onBlur: forceFalseFocused
    }, button);
  }

  // node_modules/@shopify/polaris/build/esm/components/ButtonGroup/ButtonGroup.js
  function ButtonGroup({
    children: children2,
    spacing: spacing2,
    segmented,
    fullWidth,
    connectedTop
  }) {
    const className = classNames(styles12.ButtonGroup, spacing2 && styles12[spacing2], segmented && styles12.segmented, fullWidth && styles12.fullWidth);
    const contents = elementChildren(children2).map((child, index2) => /* @__PURE__ */ import_react60.default.createElement(Item2, {
      button: child,
      key: index2
    }));
    return /* @__PURE__ */ import_react60.default.createElement("div", {
      className,
      "data-buttongroup-segmented": segmented,
      "data-buttongroup-connected-top": connectedTop,
      "data-buttongroup-full-width": fullWidth
    }, contents);
  }

  // node_modules/@shopify/polaris/build/esm/components/Stack/Stack.js
  var import_react62 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Stack/Stack.scss.js
  var styles13 = {
    "Stack": "Polaris-Stack",
    "Item": "Polaris-Stack__Item",
    "noWrap": "Polaris-Stack--noWrap",
    "spacingNone": "Polaris-Stack--spacingNone",
    "spacingExtraTight": "Polaris-Stack--spacingExtraTight",
    "spacingTight": "Polaris-Stack--spacingTight",
    "spacingBaseTight": "Polaris-Stack--spacingBaseTight",
    "spacingLoose": "Polaris-Stack--spacingLoose",
    "spacingExtraLoose": "Polaris-Stack--spacingExtraLoose",
    "distributionLeading": "Polaris-Stack--distributionLeading",
    "distributionTrailing": "Polaris-Stack--distributionTrailing",
    "distributionCenter": "Polaris-Stack--distributionCenter",
    "distributionEqualSpacing": "Polaris-Stack--distributionEqualSpacing",
    "distributionFill": "Polaris-Stack--distributionFill",
    "distributionFillEvenly": "Polaris-Stack--distributionFillEvenly",
    "alignmentLeading": "Polaris-Stack--alignmentLeading",
    "alignmentTrailing": "Polaris-Stack--alignmentTrailing",
    "alignmentCenter": "Polaris-Stack--alignmentCenter",
    "alignmentFill": "Polaris-Stack--alignmentFill",
    "alignmentBaseline": "Polaris-Stack--alignmentBaseline",
    "vertical": "Polaris-Stack--vertical",
    "Item-fill": "Polaris-Stack__Item--fill"
  };

  // node_modules/@shopify/polaris/build/esm/components/Stack/components/Item/Item.js
  var import_react61 = __toESM(require_react());
  function Item3({
    children: children2,
    fill
  }) {
    const className = classNames(styles13.Item, fill && styles13["Item-fill"]);
    return /* @__PURE__ */ import_react61.default.createElement("div", {
      className
    }, children2);
  }

  // node_modules/@shopify/polaris/build/esm/components/Stack/Stack.js
  var Stack = /* @__PURE__ */ (0, import_react62.memo)(function Stack2({
    children: children2,
    vertical,
    spacing: spacing2,
    distribution,
    alignment,
    wrap: wrap2
  }) {
    const className = classNames(styles13.Stack, vertical && styles13.vertical, spacing2 && styles13[variationName("spacing", spacing2)], distribution && styles13[variationName("distribution", distribution)], alignment && styles13[variationName("alignment", alignment)], wrap2 === false && styles13.noWrap);
    const itemMarkup = elementChildren(children2).map((child, index2) => {
      const props = {
        key: index2
      };
      return wrapWithComponent(child, Item3, props);
    });
    return /* @__PURE__ */ import_react62.default.createElement("div", {
      className
    }, itemMarkup);
  });
  Stack.Item = Item3;

  // node_modules/@shopify/polaris/build/esm/components/Image/Image.js
  var import_react63 = __toESM(require_react());
  function Image({
    alt,
    sourceSet,
    source,
    crossOrigin,
    onLoad,
    className,
    ...rest
  }) {
    const finalSourceSet = sourceSet ? sourceSet.map(({
      source: subSource,
      descriptor
    }) => `${subSource} ${descriptor}`).join(",") : null;
    const handleLoad = (0, import_react63.useCallback)(() => {
      if (onLoad)
        onLoad();
    }, [onLoad]);
    return /* @__PURE__ */ import_react63.default.createElement("img", Object.assign({
      alt,
      src: source,
      crossOrigin,
      className,
      onLoad: handleLoad
    }, finalSourceSet ? {
      srcSet: finalSourceSet
    } : {}, rest));
  }

  // node_modules/@shopify/polaris/build/esm/components/InlineError/InlineError.js
  var import_react64 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/InlineError/InlineError.scss.js
  var styles14 = {
    "InlineError": "Polaris-InlineError",
    "Icon": "Polaris-InlineError__Icon"
  };

  // node_modules/@shopify/polaris/build/esm/components/InlineError/InlineError.js
  function InlineError({
    message,
    fieldID
  }) {
    if (!message) {
      return null;
    }
    return /* @__PURE__ */ import_react64.default.createElement("div", {
      id: errorTextID(fieldID),
      className: styles14.InlineError
    }, /* @__PURE__ */ import_react64.default.createElement("div", {
      className: styles14.Icon
    }, /* @__PURE__ */ import_react64.default.createElement(Icon, {
      source: SvgAlertMinor
    })), message);
  }
  function errorTextID(id) {
    return `${id}Error`;
  }

  // node_modules/@shopify/polaris/build/esm/components/TextField/TextField.js
  var import_react71 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/TextField/TextField.scss.js
  var styles15 = {
    "TextField": "Polaris-TextField",
    "multiline": "Polaris-TextField--multiline",
    "Input": "Polaris-TextField__Input",
    "hasValue": "Polaris-TextField--hasValue",
    "focus": "Polaris-TextField--focus",
    "VerticalContent": "Polaris-TextField__VerticalContent",
    "Backdrop": "Polaris-TextField__Backdrop",
    "error": "Polaris-TextField--error",
    "readOnly": "Polaris-TextField--readOnly",
    "disabled": "Polaris-TextField--disabled",
    "Prefix": "Polaris-TextField__Prefix",
    "suggestion": "Polaris-TextField--suggestion",
    "Input-hasClearButton": "Polaris-TextField__Input--hasClearButton",
    "Input-suffixed": "Polaris-TextField__Input--suffixed",
    "Input-alignRight": "Polaris-TextField__Input--alignRight",
    "Input-alignLeft": "Polaris-TextField__Input--alignLeft",
    "Input-alignCenter": "Polaris-TextField__Input--alignCenter",
    "Suffix": "Polaris-TextField__Suffix",
    "CharacterCount": "Polaris-TextField__CharacterCount",
    "AlignFieldBottom": "Polaris-TextField__AlignFieldBottom",
    "ClearButton": "Polaris-TextField__ClearButton",
    "Spinner": "Polaris-TextField__Spinner",
    "SpinnerIcon": "Polaris-TextField__SpinnerIcon",
    "Resizer": "Polaris-TextField__Resizer",
    "DummyInput": "Polaris-TextField__DummyInput",
    "Segment": "Polaris-TextField__Segment",
    "monospaced": "Polaris-TextField--monospaced"
  };

  // node_modules/@shopify/polaris/build/esm/components/Labelled/Labelled.js
  var import_react66 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Labelled/Labelled.scss.js
  var styles16 = {
    "hidden": "Polaris-Labelled--hidden",
    "LabelWrapper": "Polaris-Labelled__LabelWrapper",
    "HelpText": "Polaris-Labelled__HelpText",
    "Error": "Polaris-Labelled__Error",
    "Action": "Polaris-Labelled__Action"
  };

  // node_modules/@shopify/polaris/build/esm/components/Label/Label.js
  var import_react65 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Label/Label.scss.js
  var styles17 = {
    "Label": "Polaris-Label",
    "hidden": "Polaris-Label--hidden",
    "Text": "Polaris-Label__Text",
    "RequiredIndicator": "Polaris-Label__RequiredIndicator"
  };

  // node_modules/@shopify/polaris/build/esm/components/Label/Label.js
  function labelID(id) {
    return `${id}Label`;
  }
  function Label({
    children: children2,
    id,
    hidden,
    requiredIndicator
  }) {
    const className = classNames(styles17.Label, hidden && styles17.hidden);
    return /* @__PURE__ */ import_react65.default.createElement("div", {
      className
    }, /* @__PURE__ */ import_react65.default.createElement("label", {
      id: labelID(id),
      htmlFor: id,
      className: classNames(styles17.Text, requiredIndicator && styles17.RequiredIndicator)
    }, children2));
  }

  // node_modules/@shopify/polaris/build/esm/components/Labelled/Labelled.js
  function Labelled({
    id,
    label,
    error,
    action,
    helpText,
    children: children2,
    labelHidden,
    requiredIndicator,
    ...rest
  }) {
    const className = classNames(labelHidden && styles16.hidden);
    const actionMarkup = action ? /* @__PURE__ */ import_react66.default.createElement("div", {
      className: styles16.Action
    }, buttonFrom(action, {
      plain: true
    })) : null;
    const helpTextMarkup = helpText ? /* @__PURE__ */ import_react66.default.createElement("div", {
      className: styles16.HelpText,
      id: helpTextID(id)
    }, helpText) : null;
    const errorMarkup = error && typeof error !== "boolean" && /* @__PURE__ */ import_react66.default.createElement("div", {
      className: styles16.Error
    }, /* @__PURE__ */ import_react66.default.createElement(InlineError, {
      message: error,
      fieldID: id
    }));
    const labelMarkup = label ? /* @__PURE__ */ import_react66.default.createElement("div", {
      className: styles16.LabelWrapper
    }, /* @__PURE__ */ import_react66.default.createElement(Label, Object.assign({
      id,
      requiredIndicator
    }, rest, {
      hidden: false
    }), label), actionMarkup) : null;
    return /* @__PURE__ */ import_react66.default.createElement("div", {
      className
    }, labelMarkup, children2, errorMarkup, helpTextMarkup);
  }
  function helpTextID(id) {
    return `${id}HelpText`;
  }

  // node_modules/@shopify/polaris/build/esm/components/Connected/Connected.js
  var import_react68 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Connected/Connected.scss.js
  var styles18 = {
    "Connected": "Polaris-Connected",
    "Item": "Polaris-Connected__Item",
    "Item-primary": "Polaris-Connected__Item--primary",
    "Item-focused": "Polaris-Connected__Item--focused"
  };

  // node_modules/@shopify/polaris/build/esm/components/Connected/components/Item/Item.js
  var import_react67 = __toESM(require_react());
  function Item4({
    children: children2,
    position
  }) {
    const {
      value: focused,
      setTrue: forceTrueFocused,
      setFalse: forceFalseFocused
    } = useToggle(false);
    const className = classNames(styles18.Item, focused && styles18["Item-focused"], position === "primary" ? styles18["Item-primary"] : styles18["Item-connection"]);
    return /* @__PURE__ */ import_react67.default.createElement("div", {
      onBlur: forceFalseFocused,
      onFocus: forceTrueFocused,
      className
    }, children2);
  }

  // node_modules/@shopify/polaris/build/esm/components/Connected/Connected.js
  function Connected({
    children: children2,
    left,
    right
  }) {
    const leftConnectionMarkup = left ? /* @__PURE__ */ import_react68.default.createElement(Item4, {
      position: "left"
    }, left) : null;
    const rightConnectionMarkup = right ? /* @__PURE__ */ import_react68.default.createElement(Item4, {
      position: "right"
    }, right) : null;
    return /* @__PURE__ */ import_react68.default.createElement("div", {
      className: styles18.Connected
    }, leftConnectionMarkup, /* @__PURE__ */ import_react68.default.createElement(Item4, {
      position: "primary"
    }, children2), rightConnectionMarkup);
  }

  // node_modules/@shopify/polaris/build/esm/components/TextField/components/Spinner/Spinner.js
  var import_react69 = __toESM(require_react());
  function Spinner2({
    onChange,
    onClick,
    onMouseDown,
    onMouseUp
  }) {
    function handleStep(step) {
      return () => onChange(step);
    }
    function handleMouseDown(onChange2) {
      return (event) => {
        if (event.button !== 0)
          return;
        onMouseDown(onChange2);
      };
    }
    return /* @__PURE__ */ import_react69.default.createElement("div", {
      className: styles15.Spinner,
      onClick,
      "aria-hidden": true
    }, /* @__PURE__ */ import_react69.default.createElement("div", {
      role: "button",
      className: styles15.Segment,
      tabIndex: -1,
      onClick: handleStep(1),
      onMouseDown: handleMouseDown(handleStep(1)),
      onMouseUp
    }, /* @__PURE__ */ import_react69.default.createElement("div", {
      className: styles15.SpinnerIcon
    }, /* @__PURE__ */ import_react69.default.createElement(Icon, {
      source: SvgCaretUpMinor
    }))), /* @__PURE__ */ import_react69.default.createElement("div", {
      role: "button",
      className: styles15.Segment,
      tabIndex: -1,
      onClick: handleStep(-1),
      onMouseDown: handleMouseDown(handleStep(-1)),
      onMouseUp
    }, /* @__PURE__ */ import_react69.default.createElement("div", {
      className: styles15.SpinnerIcon
    }, /* @__PURE__ */ import_react69.default.createElement(Icon, {
      source: SvgCaretDownMinor
    }))));
  }

  // node_modules/@shopify/polaris/build/esm/components/TextField/components/Resizer/Resizer.js
  var import_react70 = __toESM(require_react());
  function Resizer({
    contents,
    currentHeight: currentHeightProp = null,
    minimumLines,
    onHeightChange
  }) {
    const contentNode = (0, import_react70.useRef)(null);
    const minimumLinesNode = (0, import_react70.useRef)(null);
    const animationFrame = (0, import_react70.useRef)();
    const currentHeight = (0, import_react70.useRef)(currentHeightProp);
    if (currentHeightProp !== currentHeight.current) {
      currentHeight.current = currentHeightProp;
    }
    (0, import_react70.useEffect)(() => {
      return () => {
        if (animationFrame.current) {
          cancelAnimationFrame(animationFrame.current);
        }
      };
    }, []);
    const minimumLinesMarkup = minimumLines ? /* @__PURE__ */ import_react70.default.createElement("div", {
      ref: minimumLinesNode,
      className: styles15.DummyInput,
      dangerouslySetInnerHTML: {
        __html: getContentsForMinimumLines(minimumLines)
      }
    }) : null;
    const handleHeightCheck = (0, import_react70.useCallback)(() => {
      if (animationFrame.current) {
        cancelAnimationFrame(animationFrame.current);
      }
      animationFrame.current = requestAnimationFrame(() => {
        if (!contentNode.current || !minimumLinesNode.current) {
          return;
        }
        const newHeight = Math.max(contentNode.current.offsetHeight, minimumLinesNode.current.offsetHeight);
        if (newHeight !== currentHeight.current) {
          onHeightChange(newHeight);
        }
      });
    }, [onHeightChange]);
    (0, import_react70.useLayoutEffect)(() => {
      handleHeightCheck();
    });
    return /* @__PURE__ */ import_react70.default.createElement("div", {
      "aria-hidden": true,
      className: styles15.Resizer
    }, /* @__PURE__ */ import_react70.default.createElement(EventListener, {
      event: "resize",
      handler: handleHeightCheck
    }), /* @__PURE__ */ import_react70.default.createElement("div", {
      ref: contentNode,
      className: styles15.DummyInput,
      dangerouslySetInnerHTML: {
        __html: getFinalContents(contents)
      }
    }), minimumLinesMarkup);
  }
  var ENTITIES_TO_REPLACE = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "\n": "<br>",
    "\r": ""
  };
  var REPLACE_REGEX2 = new RegExp(`[${Object.keys(ENTITIES_TO_REPLACE).join()}]`, "g");
  function replaceEntity(entity) {
    return ENTITIES_TO_REPLACE[entity];
  }
  function getContentsForMinimumLines(minimumLines) {
    let content = "";
    for (let line = 0; line < minimumLines; line++) {
      content += "<br>";
    }
    return content;
  }
  function getFinalContents(contents) {
    return contents ? `${contents.replace(REPLACE_REGEX2, replaceEntity)}<br>` : "<br>";
  }

  // node_modules/@shopify/polaris/build/esm/components/TextField/TextField.js
  function TextField({
    prefix: prefix2,
    suffix,
    verticalContent,
    placeholder,
    value = "",
    helpText,
    label,
    labelAction,
    labelHidden,
    disabled,
    clearButton,
    readOnly,
    autoFocus,
    focused,
    multiline,
    error,
    connectedRight,
    connectedLeft,
    type = "text",
    name,
    id: idProp,
    role,
    step,
    autoComplete,
    max,
    maxLength,
    maxHeight,
    min,
    minLength,
    pattern,
    inputMode,
    spellCheck,
    ariaOwns,
    ariaControls,
    ariaExpanded,
    ariaActiveDescendant,
    ariaAutocomplete,
    showCharacterCount,
    align,
    requiredIndicator,
    monospaced,
    selectTextOnFocus,
    suggestion,
    onClearButtonClick,
    onChange,
    onFocus,
    onBlur
  }) {
    const i18n = useI18n();
    const [height, setHeight] = (0, import_react71.useState)(null);
    const [focus, setFocus] = (0, import_react71.useState)(Boolean(focused));
    const isAfterInitial = useIsAfterInitialMount();
    const id = useUniqueId("TextField", idProp);
    const inputRef = (0, import_react71.useRef)(null);
    const textAreaRef = (0, import_react71.useRef)(null);
    const prefixRef = (0, import_react71.useRef)(null);
    const suffixRef = (0, import_react71.useRef)(null);
    const verticalContentRef = (0, import_react71.useRef)(null);
    const buttonPressTimer = (0, import_react71.useRef)();
    (0, import_react71.useEffect)(() => {
      const input2 = inputRef.current;
      if (!input2 || focused === void 0)
        return;
      focused ? input2.focus() : input2.blur();
    }, [focused, verticalContent]);
    (0, import_react71.useEffect)(() => {
      const input2 = inputRef.current;
      const isSupportedInputType = type === "text" || type === "tel" || type === "search" || type === "url" || type === "password";
      if (!input2 || !isSupportedInputType || !suggestion) {
        return;
      }
      input2.setSelectionRange(value.length, suggestion.length);
    }, [focus, value, type, suggestion]);
    const normalizedValue = suggestion ? suggestion : value;
    const normalizedStep = step != null ? step : 1;
    const normalizedMax = max != null ? max : Infinity;
    const normalizedMin = min != null ? min : -Infinity;
    const className = classNames(styles15.TextField, Boolean(normalizedValue) && styles15.hasValue, disabled && styles15.disabled, readOnly && styles15.readOnly, error && styles15.error, multiline && styles15.multiline, focus && styles15.focus);
    const inputType = type === "currency" ? "text" : type;
    const prefixMarkup = prefix2 ? /* @__PURE__ */ import_react71.default.createElement("div", {
      className: styles15.Prefix,
      id: `${id}-Prefix`,
      ref: prefixRef
    }, prefix2) : null;
    const suffixMarkup = suffix ? /* @__PURE__ */ import_react71.default.createElement("div", {
      className: styles15.Suffix,
      id: `${id}-Suffix`,
      ref: suffixRef
    }, suffix) : null;
    let characterCountMarkup = null;
    if (showCharacterCount) {
      const characterCount = normalizedValue.length;
      const characterCountLabel = maxLength ? i18n.translate("Polaris.TextField.characterCountWithMaxLength", {
        count: characterCount,
        limit: maxLength
      }) : i18n.translate("Polaris.TextField.characterCount", {
        count: characterCount
      });
      const characterCountClassName = classNames(styles15.CharacterCount, multiline && styles15.AlignFieldBottom);
      const characterCountText = !maxLength ? characterCount : `${characterCount}/${maxLength}`;
      characterCountMarkup = /* @__PURE__ */ import_react71.default.createElement("div", {
        id: `${id}-CharacterCounter`,
        className: characterCountClassName,
        "aria-label": characterCountLabel,
        "aria-live": focus ? "polite" : "off",
        "aria-atomic": "true",
        onClick: handleClickChild
      }, characterCountText);
    }
    const clearButtonVisible = normalizedValue !== "";
    const clearButtonMarkup = clearButton && clearButtonVisible ? /* @__PURE__ */ import_react71.default.createElement("button", {
      type: "button",
      className: styles15.ClearButton,
      onClick: handleClearButtonPress,
      disabled
    }, /* @__PURE__ */ import_react71.default.createElement(VisuallyHidden, null, i18n.translate("Polaris.Common.clear")), /* @__PURE__ */ import_react71.default.createElement(Icon, {
      source: SvgCircleCancelMinor,
      color: "base"
    })) : null;
    const handleNumberChange = (0, import_react71.useCallback)((steps) => {
      if (onChange == null) {
        return;
      }
      const dpl = (num) => (num.toString().split(".")[1] || []).length;
      const numericValue = value ? parseFloat(value) : 0;
      if (isNaN(numericValue)) {
        return;
      }
      const decimalPlaces = Math.max(dpl(numericValue), dpl(normalizedStep));
      const newValue = Math.min(Number(normalizedMax), Math.max(numericValue + steps * normalizedStep, Number(normalizedMin)));
      onChange(String(newValue.toFixed(decimalPlaces)), id);
    }, [id, normalizedMax, normalizedMin, onChange, normalizedStep, value]);
    const handleButtonRelease = (0, import_react71.useCallback)(() => {
      clearTimeout(buttonPressTimer.current);
    }, []);
    const handleButtonPress = (0, import_react71.useCallback)((onChange2) => {
      const minInterval = 50;
      const decrementBy = 10;
      let interval = 200;
      const onChangeInterval = () => {
        if (interval > minInterval)
          interval -= decrementBy;
        onChange2(0);
        buttonPressTimer.current = window.setTimeout(onChangeInterval, interval);
      };
      buttonPressTimer.current = window.setTimeout(onChangeInterval, interval);
      document.addEventListener("mouseup", handleButtonRelease, {
        once: true
      });
    }, [handleButtonRelease]);
    const spinnerMarkup = type === "number" && step !== 0 && !disabled && !readOnly ? /* @__PURE__ */ import_react71.default.createElement(Spinner2, {
      onClick: handleClickChild,
      onChange: handleNumberChange,
      onMouseDown: handleButtonPress,
      onMouseUp: handleButtonRelease
    }) : null;
    const style4 = multiline && height ? {
      height,
      maxHeight
    } : null;
    const handleExpandingResize = (0, import_react71.useCallback)((height2) => {
      setHeight(height2);
    }, []);
    const resizer = multiline && isAfterInitial ? /* @__PURE__ */ import_react71.default.createElement(Resizer, {
      contents: normalizedValue || placeholder,
      currentHeight: height,
      minimumLines: typeof multiline === "number" ? multiline : 1,
      onHeightChange: handleExpandingResize
    }) : null;
    const describedBy = [];
    if (error) {
      describedBy.push(`${id}Error`);
    }
    if (helpText) {
      describedBy.push(helpTextID(id));
    }
    if (showCharacterCount) {
      describedBy.push(`${id}-CharacterCounter`);
    }
    const labelledBy = [];
    if (prefix2) {
      labelledBy.push(`${id}-Prefix`);
    }
    if (suffix) {
      labelledBy.push(`${id}-Suffix`);
    }
    if (verticalContent) {
      labelledBy.push(`${id}-VerticalContent`);
    }
    labelledBy.unshift(labelID(id));
    const inputClassName = classNames(styles15.Input, align && styles15[variationName("Input-align", align)], suffix && styles15["Input-suffixed"], clearButton && styles15["Input-hasClearButton"], monospaced && styles15.monospaced, suggestion && styles15.suggestion);
    const handleOnFocus = (event) => {
      setFocus(true);
      if (selectTextOnFocus && !suggestion) {
        const input2 = multiline ? textAreaRef.current : inputRef.current;
        input2 === null || input2 === void 0 ? void 0 : input2.select();
      }
      if (onFocus) {
        onFocus(event);
      }
    };
    const handleOnBlur = (event) => {
      setFocus(false);
      if (onBlur) {
        onBlur(event);
      }
    };
    const input = /* @__PURE__ */ (0, import_react71.createElement)(multiline ? "textarea" : "input", {
      name,
      id,
      disabled,
      readOnly,
      role,
      autoFocus,
      value: normalizedValue,
      placeholder,
      style: style4,
      autoComplete,
      className: inputClassName,
      ref: multiline ? textAreaRef : inputRef,
      min,
      max,
      step,
      minLength,
      maxLength,
      spellCheck,
      pattern,
      inputMode,
      type: inputType,
      rows: getRows(multiline),
      "aria-describedby": describedBy.length ? describedBy.join(" ") : void 0,
      "aria-labelledby": labelledBy.join(" "),
      "aria-invalid": Boolean(error),
      "aria-owns": ariaOwns,
      "aria-activedescendant": ariaActiveDescendant,
      "aria-autocomplete": ariaAutocomplete,
      "aria-controls": ariaControls,
      "aria-expanded": ariaExpanded,
      "aria-required": requiredIndicator,
      ...normalizeAriaMultiline(multiline),
      onFocus: handleOnFocus,
      onBlur: handleOnBlur,
      onClick: handleClickChild,
      onKeyPress: handleKeyPress,
      onChange: !suggestion ? handleChange : void 0,
      onInput: suggestion ? handleChange : void 0
    });
    const inputWithVerticalContentMarkup = verticalContent ? /* @__PURE__ */ import_react71.default.createElement("div", {
      className: styles15.VerticalContent,
      id: `${id}-VerticalContent`,
      ref: verticalContentRef,
      onClick: handleClickChild
    }, verticalContent, input) : null;
    const inputMarkup = verticalContent ? inputWithVerticalContentMarkup : input;
    const backdropMarkup = /* @__PURE__ */ import_react71.default.createElement("div", {
      className: classNames(styles15.Backdrop, connectedLeft && styles15["Backdrop-connectedLeft"], connectedRight && styles15["Backdrop-connectedRight"])
    });
    return /* @__PURE__ */ import_react71.default.createElement(Labelled, {
      label,
      id,
      error,
      action: labelAction,
      labelHidden,
      helpText,
      requiredIndicator
    }, /* @__PURE__ */ import_react71.default.createElement(Connected, {
      left: connectedLeft,
      right: connectedRight
    }, /* @__PURE__ */ import_react71.default.createElement("div", {
      className,
      onClick: handleClick
    }, prefixMarkup, inputMarkup, suffixMarkup, characterCountMarkup, clearButtonMarkup, spinnerMarkup, backdropMarkup, resizer)));
    function handleClearButtonPress() {
      onClearButtonClick && onClearButtonClick(id);
    }
    function handleKeyPress(event) {
      const {
        key,
        which
      } = event;
      const numbersSpec = /[\d.eE+-]$/;
      if (type !== "number" || which === Key.Enter || numbersSpec.test(key)) {
        return;
      }
      event.preventDefault();
    }
    function isPrefixOrSuffix(target) {
      return target instanceof Element && (prefixRef.current && prefixRef.current.contains(target) || suffixRef.current && suffixRef.current.contains(target));
    }
    function isVerticalContent(target) {
      return target instanceof Element && verticalContentRef.current && (verticalContentRef.current.contains(target) || verticalContentRef.current.contains(document.activeElement));
    }
    function isInput(target) {
      return target instanceof HTMLElement && inputRef.current && (inputRef.current.contains(target) || inputRef.current.contains(document.activeElement));
    }
    function handleChange(event) {
      onChange && onChange(event.currentTarget.value, id);
    }
    function handleClick({
      target
    }) {
      var _inputRef$current;
      if (isPrefixOrSuffix(target) || isVerticalContent(target) || isInput(target) || focus) {
        return;
      }
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
    }
    function handleClickChild(event) {
      if (inputRef.current !== event.target) {
        event.stopPropagation();
      }
      if (isPrefixOrSuffix(event.target) || isVerticalContent(event.target) || isInput(event.target) || focus) {
        return;
      }
      setFocus(true);
    }
  }
  function normalizeAriaMultiline(multiline) {
    if (!multiline)
      return void 0;
    return Boolean(multiline) || multiline > 0 ? {
      "aria-multiline": true
    } : void 0;
  }
  function getRows(multiline) {
    if (!multiline)
      return void 0;
    return typeof multiline === "number" ? multiline : 1;
  }

  // node_modules/@shopify/polaris/build/esm/components/Backdrop/Backdrop.js
  var import_react74 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Backdrop/Backdrop.scss.js
  var styles19 = {
    "Backdrop": "Polaris-Backdrop",
    "transparent": "Polaris-Backdrop--transparent",
    "belowNavigation": "Polaris-Backdrop--belowNavigation"
  };

  // node_modules/@shopify/polaris/build/esm/components/ScrollLock/ScrollLock.js
  var import_react73 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/scroll-lock-manager/hooks.js
  var import_react72 = __toESM(require_react());
  function useScrollLockManager() {
    const scrollLockManager = (0, import_react72.useContext)(ScrollLockManagerContext);
    if (!scrollLockManager) {
      throw new MissingAppProviderError("No ScrollLockManager was provided.");
    }
    return scrollLockManager;
  }

  // node_modules/@shopify/polaris/build/esm/components/ScrollLock/ScrollLock.js
  function ScrollLock(_) {
    const scrollLockManager = useScrollLockManager();
    (0, import_react73.useEffect)(() => {
      scrollLockManager.registerScrollLock();
      return () => {
        scrollLockManager.unregisterScrollLock();
      };
    }, [scrollLockManager]);
    return null;
  }

  // node_modules/@shopify/polaris/build/esm/components/Backdrop/Backdrop.js
  function Backdrop(props) {
    const {
      onClick,
      onTouchStart,
      belowNavigation,
      transparent
    } = props;
    const className = classNames(styles19.Backdrop, belowNavigation && styles19.belowNavigation, transparent && styles19.transparent);
    return /* @__PURE__ */ import_react74.default.createElement(import_react74.default.Fragment, null, /* @__PURE__ */ import_react74.default.createElement(ScrollLock, null), /* @__PURE__ */ import_react74.default.createElement("div", {
      className,
      onClick,
      onTouchStart
    }));
  }

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  // node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }

  // node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  // node_modules/react-transition-group/esm/CSSTransition.js
  var import_prop_types3 = __toESM(require_prop_types());

  // node_modules/dom-helpers/esm/hasClass.js
  function hasClass(element, className) {
    if (element.classList)
      return !!className && element.classList.contains(className);
    return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
  }

  // node_modules/dom-helpers/esm/addClass.js
  function addClass(element, className) {
    if (element.classList)
      element.classList.add(className);
    else if (!hasClass(element, className))
      if (typeof element.className === "string")
        element.className = element.className + " " + className;
      else
        element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
  }

  // node_modules/dom-helpers/esm/removeClass.js
  function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
  }
  function removeClass(element, className) {
    if (element.classList) {
      element.classList.remove(className);
    } else if (typeof element.className === "string") {
      element.className = replaceClassName(element.className, className);
    } else {
      element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
    }
  }

  // node_modules/react-transition-group/esm/CSSTransition.js
  var import_react77 = __toESM(require_react());

  // node_modules/react-transition-group/esm/Transition.js
  var import_prop_types2 = __toESM(require_prop_types());
  var import_react76 = __toESM(require_react());
  var import_react_dom2 = __toESM(require_react_dom());

  // node_modules/react-transition-group/esm/config.js
  var config_default = {
    disabled: false
  };

  // node_modules/react-transition-group/esm/utils/PropTypes.js
  var import_prop_types = __toESM(require_prop_types());
  var timeoutsShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
    enter: import_prop_types.default.number,
    exit: import_prop_types.default.number,
    appear: import_prop_types.default.number
  }).isRequired]) : null;
  var classNamesShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.shape({
    enter: import_prop_types.default.string,
    exit: import_prop_types.default.string,
    active: import_prop_types.default.string
  }), import_prop_types.default.shape({
    enter: import_prop_types.default.string,
    enterDone: import_prop_types.default.string,
    enterActive: import_prop_types.default.string,
    exit: import_prop_types.default.string,
    exitDone: import_prop_types.default.string,
    exitActive: import_prop_types.default.string
  })]) : null;

  // node_modules/react-transition-group/esm/TransitionGroupContext.js
  var import_react75 = __toESM(require_react());
  var TransitionGroupContext_default = import_react75.default.createContext(null);

  // node_modules/react-transition-group/esm/Transition.js
  var UNMOUNTED = "unmounted";
  var EXITED = "exited";
  var ENTERING = "entering";
  var ENTERED = "entered";
  var EXITING = "exiting";
  var Transition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(Transition2, _React$Component);
    function Transition2(props, context2) {
      var _this;
      _this = _React$Component.call(this, props, context2) || this;
      var parentGroup = context2;
      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    };
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout2 = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout2;
      if (timeout2 != null && typeof timeout2 !== "number") {
        exit = timeout2.exit;
        enter = timeout2.enter;
        appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
      }
      return {
        exit,
        enter,
        appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom2.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
      if (!mounting && !enter || config_default.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function() {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function() {
          _this2.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? void 0 : import_react_dom2.default.findDOMNode(this);
      if (!exit || config_default.disabled) {
        this.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function() {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts.exit, function() {
          _this3.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;
      var active = true;
      this.nextCallback = function(event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };
      this.nextCallback.cancel = function() {
        active = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
      this.setNextCallback(handler);
      var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom2.default.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout2 != null) {
        setTimeout(this.nextCallback, timeout2);
      }
    };
    _proto.render = function render() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props, children2 = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return /* @__PURE__ */ import_react76.default.createElement(TransitionGroupContext_default.Provider, {
        value: null
      }, typeof children2 === "function" ? children2(status, childProps) : import_react76.default.cloneElement(import_react76.default.Children.only(children2), childProps));
    };
    return Transition2;
  }(import_react76.default.Component);
  Transition.contextType = TransitionGroupContext_default;
  Transition.propTypes = true ? {
    nodeRef: import_prop_types2.default.shape({
      current: typeof Element === "undefined" ? import_prop_types2.default.any : function(propValue, key, componentName, location, propFullName, secret) {
        var value = propValue[key];
        return import_prop_types2.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
      }
    }),
    children: import_prop_types2.default.oneOfType([import_prop_types2.default.func.isRequired, import_prop_types2.default.element.isRequired]).isRequired,
    in: import_prop_types2.default.bool,
    mountOnEnter: import_prop_types2.default.bool,
    unmountOnExit: import_prop_types2.default.bool,
    appear: import_prop_types2.default.bool,
    enter: import_prop_types2.default.bool,
    exit: import_prop_types2.default.bool,
    timeout: function timeout(props) {
      var pt = timeoutsShape;
      if (!props.addEndListener)
        pt = pt.isRequired;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return pt.apply(void 0, [props].concat(args));
    },
    addEndListener: import_prop_types2.default.func,
    onEnter: import_prop_types2.default.func,
    onEntering: import_prop_types2.default.func,
    onEntered: import_prop_types2.default.func,
    onExit: import_prop_types2.default.func,
    onExiting: import_prop_types2.default.func,
    onExited: import_prop_types2.default.func
  } : {};
  function noop3() {
  }
  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop3,
    onEntering: noop3,
    onEntered: noop3,
    onExit: noop3,
    onExiting: noop3,
    onExited: noop3
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  var Transition_default = Transition;

  // node_modules/react-transition-group/esm/CSSTransition.js
  var _addClass = function addClass2(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c) {
      return addClass(node, c);
    });
  };
  var removeClass2 = function removeClass3(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c) {
      return removeClass(node, c);
    });
  };
  var CSSTransition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(CSSTransition2, _React$Component);
    function CSSTransition2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.appliedClasses = {
        appear: {},
        enter: {},
        exit: {}
      };
      _this.onEnter = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
        _this.removeClasses(node, "exit");
        _this.addClass(node, appearing ? "appear" : "enter", "base");
        if (_this.props.onEnter) {
          _this.props.onEnter(maybeNode, maybeAppearing);
        }
      };
      _this.onEntering = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
        var type = appearing ? "appear" : "enter";
        _this.addClass(node, type, "active");
        if (_this.props.onEntering) {
          _this.props.onEntering(maybeNode, maybeAppearing);
        }
      };
      _this.onEntered = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
        var type = appearing ? "appear" : "enter";
        _this.removeClasses(node, type);
        _this.addClass(node, type, "done");
        if (_this.props.onEntered) {
          _this.props.onEntered(maybeNode, maybeAppearing);
        }
      };
      _this.onExit = function(maybeNode) {
        var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
        _this.removeClasses(node, "appear");
        _this.removeClasses(node, "enter");
        _this.addClass(node, "exit", "base");
        if (_this.props.onExit) {
          _this.props.onExit(maybeNode);
        }
      };
      _this.onExiting = function(maybeNode) {
        var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
        _this.addClass(node, "exit", "active");
        if (_this.props.onExiting) {
          _this.props.onExiting(maybeNode);
        }
      };
      _this.onExited = function(maybeNode) {
        var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
        _this.removeClasses(node, "exit");
        _this.addClass(node, "exit", "done");
        if (_this.props.onExited) {
          _this.props.onExited(maybeNode);
        }
      };
      _this.resolveArguments = function(maybeNode, maybeAppearing) {
        return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
      };
      _this.getClassNames = function(type) {
        var classNames2 = _this.props.classNames;
        var isStringClassNames = typeof classNames2 === "string";
        var prefix2 = isStringClassNames && classNames2 ? classNames2 + "-" : "";
        var baseClassName = isStringClassNames ? "" + prefix2 + type : classNames2[type];
        var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type + "Active"];
        var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type + "Done"];
        return {
          baseClassName,
          activeClassName,
          doneClassName
        };
      };
      return _this;
    }
    var _proto = CSSTransition2.prototype;
    _proto.addClass = function addClass3(node, type, phase) {
      var className = this.getClassNames(type)[phase + "ClassName"];
      var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
      if (type === "appear" && phase === "done" && doneClassName) {
        className += " " + doneClassName;
      }
      if (phase === "active") {
        node && node.scrollTop;
      }
      if (className) {
        this.appliedClasses[type][phase] = className;
        _addClass(node, className);
      }
    };
    _proto.removeClasses = function removeClasses(node, type) {
      var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
      this.appliedClasses[type] = {};
      if (baseClassName) {
        removeClass2(node, baseClassName);
      }
      if (activeClassName) {
        removeClass2(node, activeClassName);
      }
      if (doneClassName) {
        removeClass2(node, doneClassName);
      }
    };
    _proto.render = function render() {
      var _this$props = this.props, _ = _this$props.classNames, props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
      return /* @__PURE__ */ import_react77.default.createElement(Transition_default, _extends({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };
    return CSSTransition2;
  }(import_react77.default.Component);
  CSSTransition.defaultProps = {
    classNames: ""
  };
  CSSTransition.propTypes = true ? _extends({}, Transition_default.propTypes, {
    classNames: classNamesShape,
    onEnter: import_prop_types3.default.func,
    onEntering: import_prop_types3.default.func,
    onEntered: import_prop_types3.default.func,
    onExit: import_prop_types3.default.func,
    onExiting: import_prop_types3.default.func,
    onExited: import_prop_types3.default.func
  }) : {};
  var CSSTransition_default = CSSTransition;

  // node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }

  // node_modules/react-transition-group/esm/TransitionGroup.js
  var import_prop_types4 = __toESM(require_prop_types());
  var import_react79 = __toESM(require_react());

  // node_modules/react-transition-group/esm/utils/ChildMapping.js
  var import_react78 = __toESM(require_react());
  function getChildMapping(children2, mapFn) {
    var mapper = function mapper2(child) {
      return mapFn && (0, import_react78.isValidElement)(child) ? mapFn(child) : child;
    };
    var result2 = /* @__PURE__ */ Object.create(null);
    if (children2)
      import_react78.Children.map(children2, function(c) {
        return c;
      }).forEach(function(child) {
        result2[child.key] = mapper(child);
      });
    return result2;
  }
  function mergeChildMappings(prev, next) {
    prev = prev || {};
    next = next || {};
    function getValueForKey(key) {
      return key in next ? next[key] : prev[key];
    }
    var nextKeysPending = /* @__PURE__ */ Object.create(null);
    var pendingKeys = [];
    for (var prevKey in prev) {
      if (prevKey in next) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }
    var i;
    var childMapping = {};
    for (var nextKey in next) {
      if (nextKeysPending[nextKey]) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }
    return childMapping;
  }
  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }
  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function(child) {
      return (0, import_react78.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, "appear", props),
        enter: getProp(child, "enter", props),
        exit: getProp(child, "exit", props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children2 = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children2).forEach(function(key) {
      var child = children2[key];
      if (!(0, import_react78.isValidElement)(child))
        return;
      var hasPrev = key in prevChildMapping;
      var hasNext = key in nextChildMapping;
      var prevChild = prevChildMapping[key];
      var isLeaving = (0, import_react78.isValidElement)(prevChild) && !prevChild.props.in;
      if (hasNext && (!hasPrev || isLeaving)) {
        children2[key] = (0, import_react78.cloneElement)(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        children2[key] = (0, import_react78.cloneElement)(child, {
          in: false
        });
      } else if (hasNext && hasPrev && (0, import_react78.isValidElement)(prevChild)) {
        children2[key] = (0, import_react78.cloneElement)(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      }
    });
    return children2;
  }

  // node_modules/react-transition-group/esm/TransitionGroup.js
  var values = Object.values || function(obj) {
    return Object.keys(obj).map(function(k) {
      return obj[k];
    });
  };
  var defaultProps = {
    component: "div",
    childFactory: function childFactory(child) {
      return child;
    }
  };
  var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(TransitionGroup2, _React$Component);
    function TransitionGroup2(props, context2) {
      var _this;
      _this = _React$Component.call(this, props, context2) || this;
      var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited,
        firstRender: true
      };
      return _this;
    }
    var _proto = TransitionGroup2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };
    TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    };
    _proto.handleExited = function handleExited(child, node) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping)
        return;
      if (child.props.onExited) {
        child.props.onExited(node);
      }
      if (this.mounted) {
        this.setState(function(state) {
          var children2 = _extends({}, state.children);
          delete children2[child.key];
          return {
            children: children2
          };
        });
      }
    };
    _proto.render = function render() {
      var _this$props = this.props, Component6 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
      var contextValue = this.state.contextValue;
      var children2 = values(this.state.children).map(childFactory2);
      delete props.appear;
      delete props.enter;
      delete props.exit;
      if (Component6 === null) {
        return /* @__PURE__ */ import_react79.default.createElement(TransitionGroupContext_default.Provider, {
          value: contextValue
        }, children2);
      }
      return /* @__PURE__ */ import_react79.default.createElement(TransitionGroupContext_default.Provider, {
        value: contextValue
      }, /* @__PURE__ */ import_react79.default.createElement(Component6, props, children2));
    };
    return TransitionGroup2;
  }(import_react79.default.Component);
  TransitionGroup.propTypes = true ? {
    component: import_prop_types4.default.any,
    children: import_prop_types4.default.node,
    appear: import_prop_types4.default.bool,
    enter: import_prop_types4.default.bool,
    exit: import_prop_types4.default.bool,
    childFactory: import_prop_types4.default.func
  } : {};
  TransitionGroup.defaultProps = defaultProps;
  var TransitionGroup_default = TransitionGroup;

  // node_modules/@shopify/polaris/build/esm/utilities/frame/hooks.js
  var import_react81 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/frame/context.js
  var import_react80 = __toESM(require_react());
  var FrameContext = /* @__PURE__ */ (0, import_react80.createContext)(void 0);

  // node_modules/@shopify/polaris/build/esm/utilities/frame/hooks.js
  function useFrame() {
    const frame = (0, import_react81.useContext)(FrameContext);
    if (!frame) {
      throw new Error("No Frame context was provided. Your component must be wrapped in a <Frame> component. See https://polaris.shopify.com/components/structure/frame for implementation instructions.");
    }
    return frame;
  }

  // node_modules/@shopify/polaris/build/esm/components/DisplayText/DisplayText.js
  var import_react82 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/DisplayText/DisplayText.scss.js
  var styles20 = {
    "DisplayText": "Polaris-DisplayText",
    "sizeSmall": "Polaris-DisplayText--sizeSmall",
    "sizeMedium": "Polaris-DisplayText--sizeMedium",
    "sizeLarge": "Polaris-DisplayText--sizeLarge",
    "sizeExtraLarge": "Polaris-DisplayText--sizeExtraLarge"
  };

  // node_modules/@shopify/polaris/build/esm/components/DisplayText/DisplayText.js
  function DisplayText({
    element: Element2 = "p",
    children: children2,
    size: size2 = "medium"
  }) {
    const className = classNames(styles20.DisplayText, size2 && styles20[variationName("size", size2)]);
    return /* @__PURE__ */ import_react82.default.createElement(Element2, {
      className
    }, children2);
  }

  // node_modules/@shopify/polaris/build/esm/utilities/media-query/hooks.js
  var import_react83 = __toESM(require_react());
  function useMediaQuery() {
    const mediaQuery = (0, import_react83.useContext)(MediaQueryContext);
    if (!mediaQuery) {
      throw new Error("No mediaQuery was provided. Your application must be wrapped in an <AppProvider> component. See https://polaris.shopify.com/components/structure/app-provider for implementation instructions.");
    }
    return mediaQuery;
  }

  // node_modules/@shopify/polaris/build/esm/components/TrapFocus/TrapFocus.js
  var import_react86 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/focus-manager/hooks.js
  var import_react84 = __toESM(require_react());
  function useFocusManager({
    trapping
  }) {
    const focusManager = (0, import_react84.useContext)(FocusManagerContext);
    const id = useUniqueId();
    if (!focusManager) {
      throw new MissingAppProviderError("No FocusManager was provided.");
    }
    const {
      trapFocusList,
      add: addFocusItem,
      remove: removeFocusItem
    } = focusManager;
    const canSafelyFocus = trapFocusList[0] === id;
    const value = (0, import_react84.useMemo)(() => ({
      canSafelyFocus
    }), [canSafelyFocus]);
    (0, import_react84.useEffect)(() => {
      if (!trapping)
        return;
      addFocusItem(id);
      return () => {
        removeFocusItem(id);
      };
    }, [addFocusItem, id, removeFocusItem, trapping]);
    return value;
  }

  // node_modules/@shopify/polaris/build/esm/components/Focus/Focus.js
  var import_react85 = __toESM(require_react());
  var Focus = /* @__PURE__ */ (0, import_react85.memo)(function Focus2({
    children: children2,
    disabled,
    root: root2
  }) {
    (0, import_react85.useEffect)(() => {
      if (disabled || !root2) {
        return;
      }
      const node = isRef(root2) ? root2.current : root2;
      if (!node || node.querySelector("[autofocus]")) {
        return;
      }
      focusFirstFocusableNode(node, false);
    }, [disabled, root2]);
    return /* @__PURE__ */ import_react85.default.createElement(import_react85.default.Fragment, null, children2);
  });
  function isRef(ref) {
    return ref.current !== void 0;
  }

  // node_modules/@shopify/polaris/build/esm/components/TrapFocus/TrapFocus.js
  function TrapFocus({
    trapping = true,
    children: children2
  }) {
    const {
      canSafelyFocus
    } = useFocusManager({
      trapping
    });
    const focusTrapWrapper = (0, import_react86.useRef)(null);
    const [disableFocus, setDisableFocus] = (0, import_react86.useState)(true);
    (0, import_react86.useEffect)(() => {
      const disable = canSafelyFocus && !(focusTrapWrapper.current && focusTrapWrapper.current.contains(document.activeElement)) ? !trapping : true;
      setDisableFocus(disable);
    }, [canSafelyFocus, trapping]);
    const handleFocusIn = (event) => {
      const containerContentsHaveFocus = focusTrapWrapper.current && focusTrapWrapper.current.contains(document.activeElement);
      if (trapping === false || !focusTrapWrapper.current || containerContentsHaveFocus || event.target instanceof Element && event.target.matches(`${portal.selector} *`)) {
        return;
      }
      if (canSafelyFocus && event.target instanceof HTMLElement && focusTrapWrapper.current !== event.target && !focusTrapWrapper.current.contains(event.target)) {
        focusFirstFocusableNode(focusTrapWrapper.current);
      }
    };
    const handleTab = (event) => {
      if (trapping === false || !focusTrapWrapper.current) {
        return;
      }
      const firstFocusableNode = findFirstKeyboardFocusableNode(focusTrapWrapper.current);
      const lastFocusableNode = findLastKeyboardFocusableNode(focusTrapWrapper.current);
      if (event.target === lastFocusableNode && !event.shiftKey) {
        event.preventDefault();
        focusFirstKeyboardFocusableNode(focusTrapWrapper.current);
      }
      if (event.target === firstFocusableNode && event.shiftKey) {
        event.preventDefault();
        focusLastKeyboardFocusableNode(focusTrapWrapper.current);
      }
    };
    return /* @__PURE__ */ import_react86.default.createElement(Focus, {
      disabled: disableFocus,
      root: focusTrapWrapper.current
    }, /* @__PURE__ */ import_react86.default.createElement("div", {
      ref: focusTrapWrapper
    }, /* @__PURE__ */ import_react86.default.createElement(EventListener, {
      event: "focusin",
      handler: handleFocusIn
    }), /* @__PURE__ */ import_react86.default.createElement(KeypressListener, {
      keyCode: Key.Tab,
      keyEvent: "keydown",
      handler: handleTab
    }), children2));
  }

  // node_modules/@shopify/polaris/build/esm/components/Form/Form.js
  var import_react87 = __toESM(require_react());
  function Form({
    acceptCharset,
    action,
    autoComplete,
    children: children2,
    encType,
    implicitSubmit = true,
    method = "post",
    name,
    noValidate,
    preventDefault = true,
    target,
    onSubmit
  }) {
    const i18n = useI18n();
    const handleSubmit = (0, import_react87.useCallback)((event) => {
      if (!preventDefault) {
        return;
      }
      event.preventDefault();
      onSubmit(event);
    }, [onSubmit, preventDefault]);
    const autoCompleteInputs = normalizeAutoComplete(autoComplete);
    const submitMarkup = implicitSubmit ? /* @__PURE__ */ import_react87.default.createElement(VisuallyHidden, null, /* @__PURE__ */ import_react87.default.createElement("button", {
      type: "submit",
      "aria-hidden": "true",
      tabIndex: -1
    }, i18n.translate("Polaris.Common.submit"))) : null;
    return /* @__PURE__ */ import_react87.default.createElement("form", {
      acceptCharset,
      action,
      autoComplete: autoCompleteInputs,
      encType,
      method,
      name,
      noValidate,
      target,
      onSubmit: handleSubmit
    }, submitMarkup, children2);
  }
  function normalizeAutoComplete(autoComplete) {
    if (autoComplete == null) {
      return autoComplete;
    }
    return autoComplete ? "on" : "off";
  }

  // node_modules/@shopify/polaris/build/esm/components/FormLayout/FormLayout.js
  var import_react90 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/FormLayout/FormLayout.scss.js
  var styles21 = {
    "FormLayout": "Polaris-FormLayout",
    "Title": "Polaris-FormLayout__Title",
    "Items": "Polaris-FormLayout__Items",
    "HelpText": "Polaris-FormLayout__HelpText",
    "Item": "Polaris-FormLayout__Item",
    "grouped": "Polaris-FormLayout--grouped",
    "condensed": "Polaris-FormLayout--condensed"
  };

  // node_modules/@shopify/polaris/build/esm/components/FormLayout/components/Group/Group.js
  var import_react89 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/FormLayout/components/Item/Item.js
  var import_react88 = __toESM(require_react());
  function Item5(props) {
    return /* @__PURE__ */ import_react88.default.createElement("div", {
      className: styles21.Item
    }, props.children);
  }

  // node_modules/@shopify/polaris/build/esm/components/FormLayout/components/Group/Group.js
  function Group({
    children: children2,
    condensed,
    title,
    helpText
  }) {
    const className = classNames(condensed ? styles21.condensed : styles21.grouped);
    const id = useUniqueId("FormLayoutGroup");
    let helpTextElement = null;
    let helpTextID2;
    let titleElement = null;
    let titleID;
    if (helpText) {
      helpTextID2 = `${id}HelpText`;
      helpTextElement = /* @__PURE__ */ import_react89.default.createElement("div", {
        id: helpTextID2,
        className: styles21.HelpText
      }, helpText);
    }
    if (title) {
      titleID = `${id}Title`;
      titleElement = /* @__PURE__ */ import_react89.default.createElement("div", {
        id: titleID,
        className: styles21.Title
      }, title);
    }
    const itemsMarkup = import_react89.Children.map(children2, (child) => wrapWithComponent(child, Item5, {}));
    return /* @__PURE__ */ import_react89.default.createElement("div", {
      role: "group",
      className,
      "aria-labelledby": titleID,
      "aria-describedby": helpTextID2
    }, titleElement, /* @__PURE__ */ import_react89.default.createElement("div", {
      className: styles21.Items
    }, itemsMarkup), helpTextElement);
  }

  // node_modules/@shopify/polaris/build/esm/components/FormLayout/FormLayout.js
  var FormLayout = /* @__PURE__ */ (0, import_react90.memo)(function FormLayout2({
    children: children2
  }) {
    return /* @__PURE__ */ import_react90.default.createElement("div", {
      className: styles21.FormLayout
    }, import_react90.Children.map(children2, wrapChildren));
  });
  FormLayout.Group = Group;
  function wrapChildren(child, index2) {
    if (isElementOfType(child, Group)) {
      return child;
    }
    const props = {
      key: index2
    };
    return wrapWithComponent(child, Item5, props);
  }

  // node_modules/@shopify/polaris/build/esm/components/Frame/Frame.js
  var import_react107 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/set-root-property.js
  function setRootProperty(name, value, node) {
    if (!document)
      return;
    const element = node || document.documentElement;
    element.style.setProperty(name, value);
  }

  // node_modules/@shopify/polaris/build/esm/components/Frame/Frame.scss.js
  var styles22 = {
    "Frame": "Polaris-Frame",
    "Navigation": "Polaris-Frame__Navigation",
    "hasTopBar": "Polaris-Frame--hasTopBar",
    "Navigation-enter": "Polaris-Frame__Navigation--enter",
    "Navigation-enterActive": "Polaris-Frame__Navigation--enterActive",
    "Navigation-exit": "Polaris-Frame__Navigation--exit",
    "Navigation-exitActive": "Polaris-Frame__Navigation--exitActive",
    "NavigationDismiss": "Polaris-Frame__NavigationDismiss",
    "Navigation-visible": "Polaris-Frame__Navigation--visible",
    "TopBar": "Polaris-Frame__TopBar",
    "ContextualSaveBar": "Polaris-Frame__ContextualSaveBar",
    "Main": "Polaris-Frame__Main",
    "hasNav": "Polaris-Frame--hasNav",
    "Content": "Polaris-Frame__Content",
    "GlobalRibbonContainer": "Polaris-Frame__GlobalRibbonContainer",
    "LoadingBar": "Polaris-Frame__LoadingBar",
    "Skip": "Polaris-Frame__Skip",
    "focused": "Polaris-Frame--focused",
    "pressed": "Polaris-Frame--pressed"
  };

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/Loading/Loading.js
  var import_react92 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/use-is-mounted-ref.js
  var import_react91 = __toESM(require_react());
  function useIsMountedRef() {
    const isMounted = (0, import_react91.useRef)(false);
    (0, import_react91.useEffect)(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  }

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/Loading/Loading.scss.js
  var styles23 = {
    "Loading": "Polaris-Frame-Loading",
    "Level": "Polaris-Frame-Loading__Level"
  };

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/Loading/Loading.js
  var STUCK_THRESHOLD = 99;
  function Loading() {
    const i18n = useI18n();
    const isMountedRef = useIsMountedRef();
    const [progress, setProgress] = (0, import_react92.useState)(0);
    const [animating, setAnimating] = (0, import_react92.useState)(false);
    (0, import_react92.useEffect)(() => {
      if (progress >= STUCK_THRESHOLD || animating) {
        return;
      }
      requestAnimationFrame(() => {
        if (!isMountedRef.current)
          return;
        const step = Math.max((STUCK_THRESHOLD - progress) / 10, 1);
        setAnimating(true);
        setProgress(progress + step);
      });
    }, [progress, animating, isMountedRef]);
    const customStyles = {
      transform: `scaleX(${Math.floor(progress) / 100})`
    };
    return /* @__PURE__ */ import_react92.default.createElement("div", {
      className: styles23.Loading,
      "aria-valuenow": progress,
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      role: "progressbar",
      "aria-label": i18n.translate("Polaris.Loading.label")
    }, /* @__PURE__ */ import_react92.default.createElement("div", {
      className: styles23.Level,
      style: customStyles,
      onTransitionEnd: () => setAnimating(false)
    }));
  }

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/CSSAnimation/CSSAnimation.js
  var import_react93 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/CSSAnimation/CSSAnimation.scss.js
  var styles24 = {
    "startFade": "Polaris-Frame-CSSAnimation--startFade",
    "endFade": "Polaris-Frame-CSSAnimation--endFade"
  };

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/CSSAnimation/CSSAnimation.js
  var TransitionStatus2;
  (function(TransitionStatus3) {
    TransitionStatus3["Entering"] = "entering";
    TransitionStatus3["Entered"] = "entered";
    TransitionStatus3["Exiting"] = "exiting";
    TransitionStatus3["Exited"] = "exited";
  })(TransitionStatus2 || (TransitionStatus2 = {}));
  function CSSAnimation({
    in: inProp,
    className,
    type,
    children: children2
  }) {
    const [transitionStatus, setTransitionStatus] = (0, import_react93.useState)(inProp ? TransitionStatus2.Entering : TransitionStatus2.Exited);
    const isMounted = (0, import_react93.useRef)(false);
    const node = (0, import_react93.useRef)(null);
    (0, import_react93.useEffect)(() => {
      if (!isMounted.current)
        return;
      transitionStatus === TransitionStatus2.Entering && changeTransitionStatus(TransitionStatus2.Entered);
    }, [transitionStatus]);
    (0, import_react93.useEffect)(() => {
      if (!isMounted.current)
        return;
      inProp && changeTransitionStatus(TransitionStatus2.Entering);
      !inProp && changeTransitionStatus(TransitionStatus2.Exiting);
    }, [inProp]);
    (0, import_react93.useEffect)(() => {
      isMounted.current = true;
    }, []);
    const wrapperClassName = classNames(className, styles24[variationName("start", type)], inProp && styles24[variationName("end", type)]);
    const content = transitionStatus === TransitionStatus2.Exited && !inProp ? null : children2;
    return /* @__PURE__ */ import_react93.default.createElement("div", {
      className: wrapperClassName,
      ref: node,
      onTransitionEnd: handleTransitionEnd
    }, content);
    function handleTransitionEnd() {
      transitionStatus === TransitionStatus2.Exiting && changeTransitionStatus(TransitionStatus2.Exited);
    }
    function changeTransitionStatus(transitionStatus2) {
      setTransitionStatus(transitionStatus2);
      if (transitionStatus2 === TransitionStatus2.Entering)
        node.current && node.current.getBoundingClientRect();
    }
  }

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/ContextualSaveBar/ContextualSaveBar.js
  var import_react101 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/is-object.js
  function isObject(value) {
    const type = typeof value;
    return value != null && (type === "object" || type === "function");
  }

  // node_modules/@shopify/polaris/build/esm/utilities/pluck-deep.js
  function pluckDeep(obj, key) {
    if (!obj) {
      return null;
    }
    const keys = Object.keys(obj);
    for (const currKey of keys) {
      if (currKey === key) {
        return obj[key];
      }
      if (isObject(obj[currKey])) {
        const plucked = pluckDeep(obj[currKey], key);
        if (plucked) {
          return plucked;
        }
      }
    }
    return null;
  }

  // node_modules/@shopify/polaris/build/esm/utilities/get-width.js
  function getWidth(value = {}, defaultWidth = 0, key = "width") {
    const width = typeof value === "number" ? value : pluckDeep(value, key);
    return width ? `${width}px` : `${defaultWidth}px`;
  }

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/ContextualSaveBar/ContextualSaveBar.scss.js
  var styles25 = {
    "ContextualSaveBar": "Polaris-Frame-ContextualSaveBar",
    "LogoContainer": "Polaris-Frame-ContextualSaveBar__LogoContainer",
    "ContextControl": "Polaris-Frame-ContextualSaveBar__ContextControl",
    "Message": "Polaris-Frame-ContextualSaveBar__Message",
    "Contents": "Polaris-Frame-ContextualSaveBar__Contents",
    "fullWidth": "Polaris-Frame-ContextualSaveBar--fullWidth",
    "ActionContainer": "Polaris-Frame-ContextualSaveBar__ActionContainer",
    "Action": "Polaris-Frame-ContextualSaveBar__Action"
  };

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/ContextualSaveBar/components/DiscardConfirmationModal/DiscardConfirmationModal.js
  var import_react100 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Modal/Modal.js
  var import_react99 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Modal/Modal.scss.js
  var styles26 = {
    "BodyWrapper": "Polaris-Modal__BodyWrapper",
    "Body": "Polaris-Modal__Body",
    "IFrame": "Polaris-Modal__IFrame",
    "Spinner": "Polaris-Modal__Spinner"
  };

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Dialog/Dialog.js
  var import_react94 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Dialog/Dialog.scss.js
  var styles27 = {
    "Container": "Polaris-Modal-Dialog__Container",
    "Dialog": "Polaris-Modal-Dialog",
    "Modal": "Polaris-Modal-Dialog__Modal",
    "limitHeight": "Polaris-Modal-Dialog--limitHeight",
    "sizeSmall": "Polaris-Modal-Dialog--sizeSmall",
    "sizeLarge": "Polaris-Modal-Dialog--sizeLarge",
    "fullScreen": "Polaris-Modal-Dialog--fullScreen",
    "animateFadeUp": "Polaris-Modal-Dialog--animateFadeUp",
    "entering": "Polaris-Modal-Dialog--entering",
    "exiting": "Polaris-Modal-Dialog--exiting",
    "exited": "Polaris-Modal-Dialog--exited",
    "entered": "Polaris-Modal-Dialog--entered"
  };

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Dialog/Dialog.js
  function Dialog({
    instant,
    labelledBy,
    children: children2,
    onClose,
    onExited,
    onEntered,
    large,
    small,
    limitHeight,
    fullScreen,
    ...props
  }) {
    const containerNode = (0, import_react94.useRef)(null);
    const classes = classNames(styles27.Modal, small && styles27.sizeSmall, large && styles27.sizeLarge, limitHeight && styles27.limitHeight, fullScreen && styles27.fullScreen);
    const TransitionChild = instant ? Transition_default : FadeUp;
    (0, import_react94.useEffect)(() => {
      containerNode.current && !containerNode.current.contains(document.activeElement) && focusFirstFocusableNode(containerNode.current);
    }, []);
    return /* @__PURE__ */ import_react94.default.createElement(TransitionChild, Object.assign({}, props, {
      nodeRef: containerNode,
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: parseInt(tokens.motion["duration-200"].value, 10),
      onEntered,
      onExited
    }), /* @__PURE__ */ import_react94.default.createElement("div", {
      className: styles27.Container,
      "data-polaris-layer": true,
      "data-polaris-overlay": true,
      ref: containerNode
    }, /* @__PURE__ */ import_react94.default.createElement(TrapFocus, null, /* @__PURE__ */ import_react94.default.createElement("div", {
      role: "dialog",
      "aria-modal": true,
      "aria-labelledby": labelledBy,
      tabIndex: -1,
      className: styles27.Dialog
    }, /* @__PURE__ */ import_react94.default.createElement("div", {
      className: classes
    }, /* @__PURE__ */ import_react94.default.createElement(KeypressListener, {
      keyCode: Key.Escape,
      handler: onClose
    }), children2)))));
  }
  var fadeUpClasses = {
    appear: classNames(styles27.animateFadeUp, styles27.entering),
    appearActive: classNames(styles27.animateFadeUp, styles27.entered),
    enter: classNames(styles27.animateFadeUp, styles27.entering),
    enterActive: classNames(styles27.animateFadeUp, styles27.entered),
    exit: classNames(styles27.animateFadeUp, styles27.exiting),
    exitActive: classNames(styles27.animateFadeUp, styles27.exited)
  };
  function FadeUp({
    children: children2,
    ...props
  }) {
    return /* @__PURE__ */ import_react94.default.createElement(CSSTransition_default, Object.assign({}, props, {
      classNames: fadeUpClasses
    }), children2);
  }

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Header/Header.js
  var import_react96 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Header/Header.scss.js
  var styles28 = {
    "Header": "Polaris-Modal-Header",
    "titleHidden": "Polaris-Modal-Header--titleHidden",
    "Title": "Polaris-Modal-Header__Title"
  };

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/CloseButton/CloseButton.js
  var import_react95 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/CloseButton/CloseButton.scss.js
  var styles29 = {
    "CloseButton": "Polaris-Modal-CloseButton",
    "titleHidden": "Polaris-Modal-CloseButton--titleHidden"
  };

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/CloseButton/CloseButton.js
  function CloseButton({
    titleHidden = false,
    onClick
  }) {
    const i18n = useI18n();
    return /* @__PURE__ */ import_react95.default.createElement("button", {
      onClick,
      className: classNames(styles29.CloseButton, titleHidden && styles29.titleHidden),
      "aria-label": i18n.translate("Polaris.Common.close")
    }, /* @__PURE__ */ import_react95.default.createElement(Icon, {
      source: SvgMobileCancelMajor,
      color: "base"
    }));
  }

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Header/Header.js
  function Header({
    id,
    titleHidden,
    children: children2,
    onClose
  }) {
    return /* @__PURE__ */ import_react96.default.createElement("div", {
      className: titleHidden || !children2 ? styles28.titleHidden : styles28.Header
    }, /* @__PURE__ */ import_react96.default.createElement("div", {
      id,
      className: styles28.Title
    }, /* @__PURE__ */ import_react96.default.createElement(DisplayText, {
      element: "h2",
      size: "small"
    }, children2)), /* @__PURE__ */ import_react96.default.createElement(CloseButton, {
      titleHidden,
      onClick: onClose
    }));
  }

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Section/Section.js
  var import_react97 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Section/Section.scss.js
  var styles30 = {
    "Section": "Polaris-Modal-Section",
    "subdued": "Polaris-Modal-Section--subdued",
    "flush": "Polaris-Modal-Section--flush",
    "titleHidden": "Polaris-Modal-Section--titleHidden"
  };

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Section/Section.js
  function Section3({
    children: children2,
    flush = false,
    subdued = false,
    titleHidden = false
  }) {
    const className = classNames(styles30.Section, flush && styles30.flush, subdued && styles30.subdued, titleHidden && styles30.titleHidden);
    return /* @__PURE__ */ import_react97.default.createElement("section", {
      className
    }, children2);
  }

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Footer/Footer.js
  var import_react98 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Footer/Footer.scss.js
  var styles31 = {
    "Footer": "Polaris-Modal-Footer",
    "FooterContent": "Polaris-Modal-Footer__FooterContent"
  };

  // node_modules/@shopify/polaris/build/esm/components/Modal/components/Footer/Footer.js
  function Footer({
    primaryAction,
    secondaryActions,
    children: children2
  }) {
    const primaryActionButton = primaryAction && buttonsFrom(primaryAction, {
      primary: true
    }) || null;
    const secondaryActionButtons = secondaryActions && buttonsFrom(secondaryActions) || null;
    const actions = primaryActionButton || secondaryActionButtons ? /* @__PURE__ */ import_react98.default.createElement(ButtonGroup, null, secondaryActionButtons, primaryActionButton) : null;
    return /* @__PURE__ */ import_react98.default.createElement("div", {
      className: styles31.Footer
    }, /* @__PURE__ */ import_react98.default.createElement("div", {
      className: styles31.FooterContent
    }, /* @__PURE__ */ import_react98.default.createElement(Stack, {
      alignment: "center"
    }, /* @__PURE__ */ import_react98.default.createElement(Stack.Item, {
      fill: true
    }, children2), actions)));
  }

  // node_modules/@shopify/polaris/build/esm/components/Modal/Modal.js
  var IFRAME_LOADING_HEIGHT = 200;
  var DEFAULT_IFRAME_CONTENT_HEIGHT = 400;
  var Modal = function Modal2({
    children: children2,
    title,
    titleHidden = false,
    src,
    iFrameName,
    open,
    instant,
    sectioned,
    loading,
    large,
    small,
    limitHeight,
    footer,
    primaryAction,
    secondaryActions,
    onScrolledToBottom,
    activator,
    onClose,
    onIFrameLoad,
    onTransitionEnd,
    noScroll,
    fullScreen
  }) {
    const [iframeHeight, setIframeHeight] = (0, import_react99.useState)(IFRAME_LOADING_HEIGHT);
    const headerId = useUniqueId("modal-header");
    const activatorRef = (0, import_react99.useRef)(null);
    const i18n = useI18n();
    const iframeTitle = i18n.translate("Polaris.Modal.iFrameTitle");
    let dialog;
    let backdrop;
    const handleEntered = (0, import_react99.useCallback)(() => {
      if (onTransitionEnd) {
        onTransitionEnd();
      }
    }, [onTransitionEnd]);
    const handleExited = (0, import_react99.useCallback)(() => {
      setIframeHeight(IFRAME_LOADING_HEIGHT);
      const activatorElement = activator && isRef2(activator) ? activator && activator.current : activatorRef.current;
      if (activatorElement) {
        requestAnimationFrame(() => focusFirstFocusableNode(activatorElement));
      }
    }, [activator]);
    const handleIFrameLoad = (0, import_react99.useCallback)((evt) => {
      const iframe = evt.target;
      if (iframe && iframe.contentWindow) {
        try {
          setIframeHeight(iframe.contentWindow.document.body.scrollHeight);
        } catch (_error) {
          setIframeHeight(DEFAULT_IFRAME_CONTENT_HEIGHT);
        }
      }
      if (onIFrameLoad != null) {
        onIFrameLoad(evt);
      }
    }, [onIFrameLoad]);
    if (open) {
      const footerMarkup = !footer && !primaryAction && !secondaryActions ? null : /* @__PURE__ */ import_react99.default.createElement(Footer, {
        primaryAction,
        secondaryActions
      }, footer);
      const content = sectioned ? wrapWithComponent(children2, Section3, {
        titleHidden
      }) : children2;
      const body = loading ? /* @__PURE__ */ import_react99.default.createElement("div", {
        className: styles26.Spinner
      }, /* @__PURE__ */ import_react99.default.createElement(Spinner, null)) : content;
      const scrollContainerMarkup = noScroll ? /* @__PURE__ */ import_react99.default.createElement("div", {
        className: styles26.Body
      }, body) : /* @__PURE__ */ import_react99.default.createElement(Scrollable, {
        shadow: true,
        className: styles26.Body,
        onScrolledToBottom
      }, body);
      const bodyMarkup = src ? /* @__PURE__ */ import_react99.default.createElement("iframe", {
        name: iFrameName,
        title: iframeTitle,
        src,
        className: styles26.IFrame,
        onLoad: handleIFrameLoad,
        style: {
          height: `${iframeHeight}px`
        }
      }) : scrollContainerMarkup;
      dialog = /* @__PURE__ */ import_react99.default.createElement(Dialog, {
        instant,
        labelledBy: headerId,
        onClose,
        onEntered: handleEntered,
        onExited: handleExited,
        large,
        small,
        limitHeight,
        fullScreen
      }, /* @__PURE__ */ import_react99.default.createElement(Header, {
        titleHidden,
        id: headerId,
        onClose
      }, title), /* @__PURE__ */ import_react99.default.createElement("div", {
        className: styles26.BodyWrapper
      }, bodyMarkup), footerMarkup);
      backdrop = /* @__PURE__ */ import_react99.default.createElement(Backdrop, {
        onClick: onClose
      });
    }
    const animated = !instant;
    const activatorMarkup = activator && !isRef2(activator) ? /* @__PURE__ */ import_react99.default.createElement("div", {
      ref: activatorRef
    }, activator) : null;
    return /* @__PURE__ */ import_react99.default.createElement(WithinContentContext.Provider, {
      value: true
    }, activatorMarkup, /* @__PURE__ */ import_react99.default.createElement(Portal, {
      idPrefix: "modal"
    }, /* @__PURE__ */ import_react99.default.createElement(TransitionGroup_default, {
      appear: animated,
      enter: animated,
      exit: animated
    }, dialog), backdrop));
  };
  function isRef2(ref) {
    return Object.prototype.hasOwnProperty.call(ref, "current");
  }
  Modal.Section = Section3;

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/ContextualSaveBar/components/DiscardConfirmationModal/DiscardConfirmationModal.js
  function DiscardConfirmationModal({
    open,
    onDiscard,
    onCancel
  }) {
    const i18n = useI18n();
    return /* @__PURE__ */ import_react100.default.createElement(Modal, {
      title: i18n.translate("Polaris.DiscardConfirmationModal.title"),
      open,
      onClose: onCancel,
      primaryAction: {
        content: i18n.translate("Polaris.DiscardConfirmationModal.primaryAction"),
        destructive: true,
        onAction: onDiscard
      },
      secondaryActions: [{
        content: i18n.translate("Polaris.DiscardConfirmationModal.secondaryAction"),
        onAction: onCancel
      }],
      sectioned: true
    }, i18n.translate("Polaris.DiscardConfirmationModal.message"));
  }

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/ContextualSaveBar/ContextualSaveBar.js
  function ContextualSaveBar({
    alignContentFlush,
    message,
    saveAction,
    discardAction,
    fullWidth,
    contextControl,
    secondaryMenu
  }) {
    const i18n = useI18n();
    const {
      logo
    } = useFrame();
    const {
      value: discardConfirmationModalVisible,
      toggle: toggleDiscardConfirmationModal,
      setFalse: closeDiscardConfirmationModal
    } = useToggle(false);
    const handleDiscardAction = (0, import_react101.useCallback)(() => {
      if (discardAction && discardAction.onAction) {
        discardAction.onAction();
      }
      closeDiscardConfirmationModal();
    }, [closeDiscardConfirmationModal, discardAction]);
    const discardActionContent = discardAction && discardAction.content ? discardAction.content : i18n.translate("Polaris.ContextualSaveBar.discard");
    let discardActionHandler;
    if (discardAction && discardAction.discardConfirmationModal) {
      discardActionHandler = toggleDiscardConfirmationModal;
    } else if (discardAction) {
      discardActionHandler = discardAction.onAction;
    }
    const discardConfirmationModalMarkup = discardAction && discardAction.onAction && discardAction.discardConfirmationModal && /* @__PURE__ */ import_react101.default.createElement(DiscardConfirmationModal, {
      open: discardConfirmationModalVisible,
      onCancel: toggleDiscardConfirmationModal,
      onDiscard: handleDiscardAction
    });
    const discardActionMarkup = discardAction && /* @__PURE__ */ import_react101.default.createElement(Button, {
      url: discardAction.url,
      onClick: discardActionHandler,
      loading: discardAction.loading,
      disabled: discardAction.disabled,
      accessibilityLabel: discardAction.content
    }, discardActionContent);
    const saveActionContent = saveAction && saveAction.content ? saveAction.content : i18n.translate("Polaris.ContextualSaveBar.save");
    const saveActionMarkup = saveAction && /* @__PURE__ */ import_react101.default.createElement(Button, {
      primary: true,
      url: saveAction.url,
      onClick: saveAction.onAction,
      loading: saveAction.loading,
      disabled: saveAction.disabled,
      accessibilityLabel: saveAction.content
    }, saveActionContent);
    const width = getWidth(logo, 104);
    const imageMarkup = logo && /* @__PURE__ */ import_react101.default.createElement(Image, {
      style: {
        width
      },
      source: logo.contextualSaveBarSource || "",
      alt: ""
    });
    const logoMarkup = alignContentFlush || contextControl ? null : /* @__PURE__ */ import_react101.default.createElement("div", {
      className: styles25.LogoContainer,
      style: {
        width
      }
    }, imageMarkup);
    const contextControlMarkup = contextControl ? /* @__PURE__ */ import_react101.default.createElement("div", {
      className: styles25.ContextControl
    }, contextControl) : null;
    const contentsClassName = classNames(styles25.Contents, fullWidth && styles25.fullWidth);
    return /* @__PURE__ */ import_react101.default.createElement(import_react101.default.Fragment, null, /* @__PURE__ */ import_react101.default.createElement(CustomProperties, {
      colorScheme: "dark"
    }, /* @__PURE__ */ import_react101.default.createElement("div", {
      className: styles25.ContextualSaveBar
    }, contextControlMarkup, logoMarkup, /* @__PURE__ */ import_react101.default.createElement("div", {
      className: contentsClassName
    }, /* @__PURE__ */ import_react101.default.createElement("h2", {
      className: styles25.Message
    }, message), /* @__PURE__ */ import_react101.default.createElement("div", {
      className: styles25.ActionContainer
    }, /* @__PURE__ */ import_react101.default.createElement(Stack, {
      spacing: "tight",
      wrap: false
    }, secondaryMenu, discardActionMarkup, saveActionMarkup))))), discardConfirmationModalMarkup);
  }

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/ToastManager/ToastManager.js
  var import_react106 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/use-deep-effect.js
  var import_react103 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/utilities/use-deep-compare-ref.js
  var import_react102 = __toESM(require_react());
  var import_react_fast_compare = __toESM(require_react_fast_compare());
  function useDeepCompareRef(dependencies, comparator = import_react_fast_compare.default) {
    const dependencyList = (0, import_react102.useRef)(dependencies);
    if (!comparator(dependencyList.current, dependencies)) {
      dependencyList.current = dependencies;
    }
    return dependencyList.current;
  }

  // node_modules/@shopify/polaris/build/esm/utilities/use-deep-effect.js
  function useDeepEffect(callback, dependencies, customCompare) {
    (0, import_react103.useEffect)(callback, useDeepCompareRef(dependencies, customCompare));
  }

  // node_modules/@shopify/polaris/build/esm/utilities/use-deep-callback.js
  var import_react104 = __toESM(require_react());
  function useDeepCallback(callback, dependencies, customCompare) {
    return (0, import_react104.useCallback)(callback, useDeepCompareRef(dependencies, customCompare));
  }

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/ToastManager/ToastManager.scss.js
  var styles32 = {
    "ToastManager": "Polaris-Frame-ToastManager",
    "ToastWrapper": "Polaris-Frame-ToastManager__ToastWrapper",
    "ToastWrapper-enter": "Polaris-Frame-ToastManager__ToastWrapper--enter",
    "ToastWrapper-exit": "Polaris-Frame-ToastManager__ToastWrapper--exit",
    "ToastWrapper-enter-done": "Polaris-Frame-ToastManager--toastWrapperEnterDone"
  };

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/Toast/Toast.js
  var import_react105 = __toESM(require_react());

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/Toast/Toast.scss.js
  var styles33 = {
    "Toast": "Polaris-Frame-Toast",
    "Action": "Polaris-Frame-Toast__Action",
    "error": "Polaris-Frame-Toast--error",
    "CloseButton": "Polaris-Frame-Toast__CloseButton"
  };

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/Toast/Toast.js
  var DEFAULT_TOAST_DURATION = 5e3;
  var DEFAULT_TOAST_DURATION_WITH_ACTION = 1e4;
  function Toast({
    content,
    onDismiss,
    duration,
    error,
    action
  }) {
    (0, import_react105.useEffect)(() => {
      let timeoutDuration = duration || DEFAULT_TOAST_DURATION;
      if (action && !duration) {
        timeoutDuration = DEFAULT_TOAST_DURATION_WITH_ACTION;
      } else if (action && duration && duration < DEFAULT_TOAST_DURATION_WITH_ACTION) {
        console.log("Toast with action should persist for at least 10,000 milliseconds to give the merchant enough time to act on it.");
      }
      const timer = setTimeout(onDismiss, timeoutDuration);
      return () => {
        clearTimeout(timer);
      };
    }, [action, duration, onDismiss]);
    const dismissMarkup = /* @__PURE__ */ import_react105.default.createElement("button", {
      type: "button",
      className: styles33.CloseButton,
      onClick: onDismiss
    }, /* @__PURE__ */ import_react105.default.createElement(Icon, {
      source: SvgMobileCancelMajor
    }));
    const actionMarkup = action ? /* @__PURE__ */ import_react105.default.createElement("div", {
      className: styles33.Action
    }, /* @__PURE__ */ import_react105.default.createElement(Button, {
      plain: true,
      monochrome: true,
      onClick: action.onAction
    }, action.content)) : null;
    const className = classNames(styles33.Toast, error && styles33.error);
    return /* @__PURE__ */ import_react105.default.createElement(CustomProperties, {
      colorScheme: "dark"
    }, /* @__PURE__ */ import_react105.default.createElement("div", {
      className
    }, /* @__PURE__ */ import_react105.default.createElement(KeypressListener, {
      keyCode: Key.Escape,
      handler: onDismiss
    }), content, actionMarkup, dismissMarkup));
  }

  // node_modules/@shopify/polaris/build/esm/components/Frame/components/ToastManager/ToastManager.js
  var ToastManager = /* @__PURE__ */ (0, import_react106.memo)(function ToastManager2({
    toastMessages
  }) {
    const toastNodes = [];
    const updateToasts = useDeepCallback(() => {
      let targetInPos = 0;
      toastMessages.forEach((_, index2) => {
        const currentToast = toastNodes[index2];
        if (!currentToast.current)
          return;
        targetInPos += currentToast.current.clientHeight;
        currentToast.current.style.setProperty("--pc-toast-manager-translate-y-in", `-${targetInPos}px`);
        currentToast.current.style.setProperty("--pc-toast-manager-translate-y-out", `${-targetInPos + 150}px`);
      });
    }, [toastMessages, toastNodes]);
    useDeepEffect(() => {
      updateToasts();
    }, [toastMessages]);
    const toastsMarkup = toastMessages.map((toast, index2) => {
      const toastNode = /* @__PURE__ */ (0, import_react106.createRef)();
      toastNodes[index2] = toastNode;
      return /* @__PURE__ */ import_react106.default.createElement(CSSTransition_default, {
        nodeRef: toastNodes[index2],
        key: toast.id,
        timeout: {
          enter: 0,
          exit: 400
        },
        classNames: toastClasses
      }, /* @__PURE__ */ import_react106.default.createElement("div", {
        ref: toastNode
      }, /* @__PURE__ */ import_react106.default.createElement(Toast, toast)));
    });
    return /* @__PURE__ */ import_react106.default.createElement(Portal, null, /* @__PURE__ */ import_react106.default.createElement(EventListener, {
      event: "resize",
      handler: updateToasts
    }), /* @__PURE__ */ import_react106.default.createElement("div", {
      className: styles32.ToastManager,
      "aria-live": "assertive"
    }, /* @__PURE__ */ import_react106.default.createElement(TransitionGroup_default, {
      component: null
    }, toastsMarkup)));
  });
  var toastClasses = {
    enter: classNames(styles32.ToastWrapper, styles32["ToastWrapper-enter"]),
    enterDone: classNames(styles32.ToastWrapper, styles32["ToastWrapper-enter-done"]),
    exit: classNames(styles32.ToastWrapper, styles32["ToastWrapper-exit"])
  };

  // node_modules/@shopify/polaris/build/esm/components/Frame/Frame.js
  var APP_FRAME_MAIN = "AppFrameMain";
  var APP_FRAME_NAV = "AppFrameNav";
  var APP_FRAME_TOP_BAR = "AppFrameTopBar";
  var APP_FRAME_LOADING_BAR = "AppFrameLoadingBar";
  var FrameInner = class extends import_react107.PureComponent {
    constructor(...args) {
      super(...args);
      this.state = {
        skipFocused: false,
        globalRibbonHeight: 0,
        loadingStack: 0,
        toastMessages: [],
        showContextualSaveBar: false
      };
      this.contextualSaveBar = null;
      this.globalRibbonContainer = null;
      this.navigationNode = /* @__PURE__ */ (0, import_react107.createRef)();
      this.setGlobalRibbonHeight = () => {
        const {
          globalRibbonContainer
        } = this;
        if (globalRibbonContainer) {
          this.setState({
            globalRibbonHeight: globalRibbonContainer.offsetHeight
          }, this.setGlobalRibbonRootProperty);
        }
      };
      this.setOffset = () => {
        const {
          offset = "0px"
        } = this.props;
        setRootProperty("--pc-frame-offset", offset);
      };
      this.setGlobalRibbonRootProperty = () => {
        const {
          globalRibbonHeight
        } = this.state;
        setRootProperty("--pc-frame-global-ribbon-height", `${globalRibbonHeight}px`);
      };
      this.showToast = (toast) => {
        this.setState(({
          toastMessages
        }) => {
          const hasToastById = toastMessages.find(({
            id
          }) => id === toast.id) != null;
          return {
            toastMessages: hasToastById ? toastMessages : [...toastMessages, toast]
          };
        });
      };
      this.hideToast = ({
        id
      }) => {
        this.setState(({
          toastMessages
        }) => {
          return {
            toastMessages: toastMessages.filter(({
              id: toastId
            }) => id !== toastId)
          };
        });
      };
      this.setContextualSaveBar = (props) => {
        const {
          showContextualSaveBar
        } = this.state;
        this.contextualSaveBar = {
          ...props
        };
        if (showContextualSaveBar === true) {
          this.forceUpdate();
        } else {
          this.setState({
            showContextualSaveBar: true
          });
        }
      };
      this.removeContextualSaveBar = () => {
        this.contextualSaveBar = null;
        this.setState({
          showContextualSaveBar: false
        });
      };
      this.startLoading = () => {
        this.setState(({
          loadingStack
        }) => ({
          loadingStack: loadingStack + 1
        }));
      };
      this.stopLoading = () => {
        this.setState(({
          loadingStack
        }) => ({
          loadingStack: Math.max(0, loadingStack - 1)
        }));
      };
      this.handleResize = () => {
        if (this.props.globalRibbon) {
          this.setGlobalRibbonHeight();
        }
      };
      this.handleFocus = () => {
        this.setState({
          skipFocused: true
        });
      };
      this.handleBlur = () => {
        this.setState({
          skipFocused: false
        });
      };
      this.handleClick = (event) => {
        const {
          skipToContentTarget
        } = this.props;
        if (skipToContentTarget && skipToContentTarget.current) {
          skipToContentTarget.current.focus();
          event === null || event === void 0 ? void 0 : event.preventDefault();
        }
      };
      this.handleNavigationDismiss = () => {
        const {
          onNavigationDismiss
        } = this.props;
        if (onNavigationDismiss != null) {
          onNavigationDismiss();
        }
      };
      this.setGlobalRibbonContainer = (node) => {
        this.globalRibbonContainer = node;
      };
      this.handleNavKeydown = (event) => {
        const {
          key
        } = event;
        const {
          mediaQuery: {
            isNavigationCollapsed
          },
          showMobileNavigation
        } = this.props;
        const mobileNavShowing = isNavigationCollapsed && showMobileNavigation;
        if (mobileNavShowing && key === "Escape") {
          this.handleNavigationDismiss();
        }
      };
    }
    componentDidMount() {
      this.handleResize();
      if (this.props.globalRibbon) {
        return;
      }
      this.setGlobalRibbonRootProperty();
      this.setOffset();
    }
    componentDidUpdate(prevProps) {
      if (this.props.globalRibbon !== prevProps.globalRibbon) {
        this.setGlobalRibbonHeight();
      }
      this.setOffset();
    }
    render() {
      const {
        skipFocused,
        loadingStack,
        toastMessages,
        showContextualSaveBar
      } = this.state;
      const {
        logo,
        children: children2,
        navigation,
        topBar,
        globalRibbon,
        showMobileNavigation = false,
        skipToContentTarget,
        i18n,
        mediaQuery: {
          isNavigationCollapsed
        }
      } = this.props;
      const navClassName = classNames(styles22.Navigation, showMobileNavigation && styles22["Navigation-visible"]);
      const mobileNavHidden = isNavigationCollapsed && !showMobileNavigation;
      const mobileNavShowing = isNavigationCollapsed && showMobileNavigation;
      const tabIndex = mobileNavShowing ? 0 : -1;
      const mobileNavAttributes = {
        ...mobileNavShowing && {
          "aria-modal": true,
          role: "dialog"
        }
      };
      const navigationMarkup = navigation ? /* @__PURE__ */ import_react107.default.createElement(TrapFocus, {
        trapping: mobileNavShowing
      }, /* @__PURE__ */ import_react107.default.createElement(CSSTransition_default, {
        nodeRef: this.navigationNode,
        appear: isNavigationCollapsed,
        exit: isNavigationCollapsed,
        in: showMobileNavigation,
        timeout: parseInt(tokens.motion["duration-300"].value, 10),
        classNames: navTransitionClasses
      }, /* @__PURE__ */ import_react107.default.createElement("div", Object.assign({
        key: "NavContent"
      }, mobileNavAttributes, {
        "aria-label": i18n.translate("Polaris.Frame.navigationLabel"),
        ref: this.navigationNode,
        className: navClassName,
        onKeyDown: this.handleNavKeydown,
        id: APP_FRAME_NAV,
        hidden: mobileNavHidden
      }), navigation, /* @__PURE__ */ import_react107.default.createElement("button", {
        type: "button",
        className: styles22.NavigationDismiss,
        onClick: this.handleNavigationDismiss,
        "aria-hidden": mobileNavHidden || !isNavigationCollapsed && !showMobileNavigation,
        "aria-label": i18n.translate("Polaris.Frame.Navigation.closeMobileNavigationLabel"),
        tabIndex
      }, /* @__PURE__ */ import_react107.default.createElement(Icon, {
        source: SvgMobileCancelMajor
      }))))) : null;
      const loadingMarkup = loadingStack > 0 ? /* @__PURE__ */ import_react107.default.createElement("div", {
        className: styles22.LoadingBar,
        id: APP_FRAME_LOADING_BAR
      }, /* @__PURE__ */ import_react107.default.createElement(Loading, null)) : null;
      const contextualSaveBarMarkup = /* @__PURE__ */ import_react107.default.createElement(CSSAnimation, {
        in: showContextualSaveBar,
        className: styles22.ContextualSaveBar,
        type: "fade"
      }, /* @__PURE__ */ import_react107.default.createElement(ContextualSaveBar, this.contextualSaveBar));
      const topBarMarkup = topBar ? /* @__PURE__ */ import_react107.default.createElement("div", Object.assign({
        className: styles22.TopBar
      }, layer.props, dataPolarisTopBar.props, {
        id: APP_FRAME_TOP_BAR
      }), topBar) : null;
      const globalRibbonMarkup = globalRibbon ? /* @__PURE__ */ import_react107.default.createElement("div", {
        className: styles22.GlobalRibbonContainer,
        ref: this.setGlobalRibbonContainer
      }, globalRibbon) : null;
      const skipClassName = classNames(styles22.Skip, skipFocused && styles22.focused);
      const skipTarget = skipToContentTarget !== null && skipToContentTarget !== void 0 && skipToContentTarget.current ? skipToContentTarget.current.id : APP_FRAME_MAIN;
      const skipMarkup = /* @__PURE__ */ import_react107.default.createElement("div", {
        className: skipClassName
      }, /* @__PURE__ */ import_react107.default.createElement("a", {
        href: `#${skipTarget}`,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        onClick: this.handleClick
      }, i18n.translate("Polaris.Frame.skipToContent")));
      const navigationAttributes = navigation ? {
        "data-has-navigation": true
      } : {};
      const frameClassName = classNames(styles22.Frame, navigation && styles22.hasNav, topBar && styles22.hasTopBar);
      const navigationOverlayMarkup = showMobileNavigation && isNavigationCollapsed ? /* @__PURE__ */ import_react107.default.createElement(Backdrop, {
        belowNavigation: true,
        onClick: this.handleNavigationDismiss,
        onTouchStart: this.handleNavigationDismiss
      }) : null;
      const context2 = {
        logo,
        showToast: this.showToast,
        hideToast: this.hideToast,
        startLoading: this.startLoading,
        stopLoading: this.stopLoading,
        setContextualSaveBar: this.setContextualSaveBar,
        removeContextualSaveBar: this.removeContextualSaveBar
      };
      return /* @__PURE__ */ import_react107.default.createElement(FrameContext.Provider, {
        value: context2
      }, /* @__PURE__ */ import_react107.default.createElement("div", Object.assign({
        className: frameClassName
      }, layer.props, navigationAttributes), skipMarkup, topBarMarkup, navigationMarkup, contextualSaveBarMarkup, loadingMarkup, navigationOverlayMarkup, /* @__PURE__ */ import_react107.default.createElement("main", {
        className: styles22.Main,
        id: APP_FRAME_MAIN,
        "data-has-global-ribbon": Boolean(globalRibbon)
      }, /* @__PURE__ */ import_react107.default.createElement("div", {
        className: styles22.Content
      }, children2)), /* @__PURE__ */ import_react107.default.createElement(ToastManager, {
        toastMessages
      }), globalRibbonMarkup, /* @__PURE__ */ import_react107.default.createElement(EventListener, {
        event: "resize",
        handler: this.handleResize
      })));
    }
  };
  var navTransitionClasses = {
    enter: classNames(styles22["Navigation-enter"]),
    enterActive: classNames(styles22["Navigation-enterActive"]),
    enterDone: classNames(styles22["Navigation-enterActive"]),
    exit: classNames(styles22["Navigation-exit"]),
    exitActive: classNames(styles22["Navigation-exitActive"])
  };
  function Frame(props) {
    const i18n = useI18n();
    const mediaQuery = useMediaQuery();
    return /* @__PURE__ */ import_react107.default.createElement(FrameInner, Object.assign({}, props, {
      i18n,
      mediaQuery
    }));
  }

  // node_modules/@shopify/polaris/build/esm/components/Loading/Loading.js
  var import_react108 = __toESM(require_react());
  var Loading2 = /* @__PURE__ */ (0, import_react108.memo)(function Loading3() {
    const {
      startLoading,
      stopLoading
    } = useFrame();
    (0, import_react108.useEffect)(() => {
      startLoading();
      return () => {
        stopLoading();
      };
    }, [startLoading, stopLoading]);
    return null;
  });

  // src/components/app.jsx
  var import_react122 = __toESM(require_react());

  // src/components/Users/RoutesSwitch.jsx
  var import_react121 = __toESM(require_react());

  // node_modules/react-router/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }

  // node_modules/react-router/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
  function _inheritsLoose2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }

  // node_modules/react-router/esm/react-router.js
  var import_react110 = __toESM(require_react());
  var import_prop_types6 = __toESM(require_prop_types());

  // node_modules/resolve-pathname/esm/resolve-pathname.js
  function isAbsolute(pathname) {
    return pathname.charAt(0) === "/";
  }
  function spliceOne(list, index2) {
    for (var i = index2, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
      list[i] = list[k];
    }
    list.pop();
  }
  function resolvePathname(to, from) {
    if (from === void 0)
      from = "";
    var toParts = to && to.split("/") || [];
    var fromParts = from && from.split("/") || [];
    var isToAbs = to && isAbsolute(to);
    var isFromAbs = from && isAbsolute(from);
    var mustEndAbs = isToAbs || isFromAbs;
    if (to && isAbsolute(to)) {
      fromParts = toParts;
    } else if (toParts.length) {
      fromParts.pop();
      fromParts = fromParts.concat(toParts);
    }
    if (!fromParts.length)
      return "/";
    var hasTrailingSlash;
    if (fromParts.length) {
      var last = fromParts[fromParts.length - 1];
      hasTrailingSlash = last === "." || last === ".." || last === "";
    } else {
      hasTrailingSlash = false;
    }
    var up = 0;
    for (var i = fromParts.length; i >= 0; i--) {
      var part = fromParts[i];
      if (part === ".") {
        spliceOne(fromParts, i);
      } else if (part === "..") {
        spliceOne(fromParts, i);
        up++;
      } else if (up) {
        spliceOne(fromParts, i);
        up--;
      }
    }
    if (!mustEndAbs)
      for (; up--; up)
        fromParts.unshift("..");
    if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
      fromParts.unshift("");
    var result2 = fromParts.join("/");
    if (hasTrailingSlash && result2.substr(-1) !== "/")
      result2 += "/";
    return result2;
  }
  var resolve_pathname_default = resolvePathname;

  // node_modules/value-equal/esm/value-equal.js
  function valueOf(obj) {
    return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
  }
  function valueEqual(a, b) {
    if (a === b)
      return true;
    if (a == null || b == null)
      return false;
    if (Array.isArray(a)) {
      return Array.isArray(b) && a.length === b.length && a.every(function(item, index2) {
        return valueEqual(item, b[index2]);
      });
    }
    if (typeof a === "object" || typeof b === "object") {
      var aValue = valueOf(a);
      var bValue = valueOf(b);
      if (aValue !== a || bValue !== b)
        return valueEqual(aValue, bValue);
      return Object.keys(Object.assign({}, a, b)).every(function(key) {
        return valueEqual(a[key], b[key]);
      });
    }
    return false;
  }
  var value_equal_default = valueEqual;

  // node_modules/tiny-warning/dist/tiny-warning.esm.js
  var isProduction = false;
  function warning(condition, message) {
    if (!isProduction) {
      if (condition) {
        return;
      }
      var text = "Warning: " + message;
      if (typeof console !== "undefined") {
        console.warn(text);
      }
      try {
        throw Error(text);
      } catch (x) {
      }
    }
  }
  var tiny_warning_esm_default = warning;

  // node_modules/tiny-invariant/dist/tiny-invariant.esm.js
  var isProduction2 = false;
  var prefix = "Invariant failed";
  function invariant(condition, message) {
    if (condition) {
      return;
    }
    if (isProduction2) {
      throw new Error(prefix);
    }
    var provided = typeof message === "function" ? message() : message;
    var value = provided ? prefix + ": " + provided : prefix;
    throw new Error(value);
  }

  // node_modules/history/esm/history.js
  function addLeadingSlash(path) {
    return path.charAt(0) === "/" ? path : "/" + path;
  }
  function stripLeadingSlash(path) {
    return path.charAt(0) === "/" ? path.substr(1) : path;
  }
  function hasBasename(path, prefix2) {
    return path.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path.charAt(prefix2.length)) !== -1;
  }
  function stripBasename(path, prefix2) {
    return hasBasename(path, prefix2) ? path.substr(prefix2.length) : path;
  }
  function stripTrailingSlash(path) {
    return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
  }
  function parsePath(path) {
    var pathname = path || "/";
    var search = "";
    var hash = "";
    var hashIndex = pathname.indexOf("#");
    if (hashIndex !== -1) {
      hash = pathname.substr(hashIndex);
      pathname = pathname.substr(0, hashIndex);
    }
    var searchIndex = pathname.indexOf("?");
    if (searchIndex !== -1) {
      search = pathname.substr(searchIndex);
      pathname = pathname.substr(0, searchIndex);
    }
    return {
      pathname,
      search: search === "?" ? "" : search,
      hash: hash === "#" ? "" : hash
    };
  }
  function createPath(location) {
    var pathname = location.pathname, search = location.search, hash = location.hash;
    var path = pathname || "/";
    if (search && search !== "?")
      path += search.charAt(0) === "?" ? search : "?" + search;
    if (hash && hash !== "#")
      path += hash.charAt(0) === "#" ? hash : "#" + hash;
    return path;
  }
  function createLocation(path, state, key, currentLocation) {
    var location;
    if (typeof path === "string") {
      location = parsePath(path);
      location.state = state;
    } else {
      location = _extends({}, path);
      if (location.pathname === void 0)
        location.pathname = "";
      if (location.search) {
        if (location.search.charAt(0) !== "?")
          location.search = "?" + location.search;
      } else {
        location.search = "";
      }
      if (location.hash) {
        if (location.hash.charAt(0) !== "#")
          location.hash = "#" + location.hash;
      } else {
        location.hash = "";
      }
      if (state !== void 0 && location.state === void 0)
        location.state = state;
    }
    try {
      location.pathname = decodeURI(location.pathname);
    } catch (e) {
      if (e instanceof URIError) {
        throw new URIError('Pathname "' + location.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
      } else {
        throw e;
      }
    }
    if (key)
      location.key = key;
    if (currentLocation) {
      if (!location.pathname) {
        location.pathname = currentLocation.pathname;
      } else if (location.pathname.charAt(0) !== "/") {
        location.pathname = resolve_pathname_default(location.pathname, currentLocation.pathname);
      }
    } else {
      if (!location.pathname) {
        location.pathname = "/";
      }
    }
    return location;
  }
  function locationsAreEqual(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && value_equal_default(a.state, b.state);
  }
  function createTransitionManager() {
    var prompt = null;
    function setPrompt(nextPrompt) {
      true ? tiny_warning_esm_default(prompt == null, "A history supports only one prompt at a time") : void 0;
      prompt = nextPrompt;
      return function() {
        if (prompt === nextPrompt)
          prompt = null;
      };
    }
    function confirmTransitionTo(location, action, getUserConfirmation, callback) {
      if (prompt != null) {
        var result2 = typeof prompt === "function" ? prompt(location, action) : prompt;
        if (typeof result2 === "string") {
          if (typeof getUserConfirmation === "function") {
            getUserConfirmation(result2, callback);
          } else {
            true ? tiny_warning_esm_default(false, "A history needs a getUserConfirmation function in order to use a prompt message") : void 0;
            callback(true);
          }
        } else {
          callback(result2 !== false);
        }
      } else {
        callback(true);
      }
    }
    var listeners = [];
    function appendListener(fn) {
      var isActive = true;
      function listener() {
        if (isActive)
          fn.apply(void 0, arguments);
      }
      listeners.push(listener);
      return function() {
        isActive = false;
        listeners = listeners.filter(function(item) {
          return item !== listener;
        });
      };
    }
    function notifyListeners() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      listeners.forEach(function(listener) {
        return listener.apply(void 0, args);
      });
    }
    return {
      setPrompt,
      confirmTransitionTo,
      appendListener,
      notifyListeners
    };
  }
  var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  function getConfirmation(message, callback) {
    callback(window.confirm(message));
  }
  function supportsHistory() {
    var ua = window.navigator.userAgent;
    if ((ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) && ua.indexOf("Mobile Safari") !== -1 && ua.indexOf("Chrome") === -1 && ua.indexOf("Windows Phone") === -1)
      return false;
    return window.history && "pushState" in window.history;
  }
  function supportsPopStateOnHashChange() {
    return window.navigator.userAgent.indexOf("Trident") === -1;
  }
  function supportsGoWithoutReloadUsingHash() {
    return window.navigator.userAgent.indexOf("Firefox") === -1;
  }
  function isExtraneousPopstateEvent(event) {
    return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
  }
  var PopStateEvent = "popstate";
  var HashChangeEvent = "hashchange";
  function getHistoryState() {
    try {
      return window.history.state || {};
    } catch (e) {
      return {};
    }
  }
  function createBrowserHistory(props) {
    if (props === void 0) {
      props = {};
    }
    !canUseDOM ? true ? invariant(false, "Browser history needs a DOM") : invariant(false) : void 0;
    var globalHistory = window.history;
    var canUseHistory = supportsHistory();
    var needsHashChangeListener = !supportsPopStateOnHashChange();
    var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
    function getDOMLocation(historyState) {
      var _ref = historyState || {}, key = _ref.key, state = _ref.state;
      var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
      var path = pathname + search + hash;
      true ? tiny_warning_esm_default(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : void 0;
      if (basename)
        path = stripBasename(path, basename);
      return createLocation(path, state, key);
    }
    function createKey() {
      return Math.random().toString(36).substr(2, keyLength);
    }
    var transitionManager = createTransitionManager();
    function setState(nextState) {
      _extends(history, nextState);
      history.length = globalHistory.length;
      transitionManager.notifyListeners(history.location, history.action);
    }
    function handlePopState(event) {
      if (isExtraneousPopstateEvent(event))
        return;
      handlePop(getDOMLocation(event.state));
    }
    function handleHashChange() {
      handlePop(getDOMLocation(getHistoryState()));
    }
    var forceNextPop = false;
    function handlePop(location) {
      if (forceNextPop) {
        forceNextPop = false;
        setState();
      } else {
        var action = "POP";
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
          if (ok) {
            setState({
              action,
              location
            });
          } else {
            revertPop(location);
          }
        });
      }
    }
    function revertPop(fromLocation) {
      var toLocation = history.location;
      var toIndex = allKeys.indexOf(toLocation.key);
      if (toIndex === -1)
        toIndex = 0;
      var fromIndex = allKeys.indexOf(fromLocation.key);
      if (fromIndex === -1)
        fromIndex = 0;
      var delta = toIndex - fromIndex;
      if (delta) {
        forceNextPop = true;
        go(delta);
      }
    }
    var initialLocation = getDOMLocation(getHistoryState());
    var allKeys = [initialLocation.key];
    function createHref(location) {
      return basename + createPath(location);
    }
    function push(path, state) {
      true ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
      var action = "PUSH";
      var location = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        var href = createHref(location);
        var key = location.key, state2 = location.state;
        if (canUseHistory) {
          globalHistory.pushState({
            key,
            state: state2
          }, null, href);
          if (forceRefresh) {
            window.location.href = href;
          } else {
            var prevIndex = allKeys.indexOf(history.location.key);
            var nextKeys = allKeys.slice(0, prevIndex + 1);
            nextKeys.push(location.key);
            allKeys = nextKeys;
            setState({
              action,
              location
            });
          }
        } else {
          true ? tiny_warning_esm_default(state2 === void 0, "Browser history cannot push state in browsers that do not support HTML5 history") : void 0;
          window.location.href = href;
        }
      });
    }
    function replace(path, state) {
      true ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
      var action = "REPLACE";
      var location = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        var href = createHref(location);
        var key = location.key, state2 = location.state;
        if (canUseHistory) {
          globalHistory.replaceState({
            key,
            state: state2
          }, null, href);
          if (forceRefresh) {
            window.location.replace(href);
          } else {
            var prevIndex = allKeys.indexOf(history.location.key);
            if (prevIndex !== -1)
              allKeys[prevIndex] = location.key;
            setState({
              action,
              location
            });
          }
        } else {
          true ? tiny_warning_esm_default(state2 === void 0, "Browser history cannot replace state in browsers that do not support HTML5 history") : void 0;
          window.location.replace(href);
        }
      });
    }
    function go(n) {
      globalHistory.go(n);
    }
    function goBack() {
      go(-1);
    }
    function goForward() {
      go(1);
    }
    var listenerCount = 0;
    function checkDOMListeners(delta) {
      listenerCount += delta;
      if (listenerCount === 1 && delta === 1) {
        window.addEventListener(PopStateEvent, handlePopState);
        if (needsHashChangeListener)
          window.addEventListener(HashChangeEvent, handleHashChange);
      } else if (listenerCount === 0) {
        window.removeEventListener(PopStateEvent, handlePopState);
        if (needsHashChangeListener)
          window.removeEventListener(HashChangeEvent, handleHashChange);
      }
    }
    var isBlocked = false;
    function block2(prompt) {
      if (prompt === void 0) {
        prompt = false;
      }
      var unblock = transitionManager.setPrompt(prompt);
      if (!isBlocked) {
        checkDOMListeners(1);
        isBlocked = true;
      }
      return function() {
        if (isBlocked) {
          isBlocked = false;
          checkDOMListeners(-1);
        }
        return unblock();
      };
    }
    function listen(listener) {
      var unlisten = transitionManager.appendListener(listener);
      checkDOMListeners(1);
      return function() {
        checkDOMListeners(-1);
        unlisten();
      };
    }
    var history = {
      length: globalHistory.length,
      action: "POP",
      location: initialLocation,
      createHref,
      push,
      replace,
      go,
      goBack,
      goForward,
      block: block2,
      listen
    };
    return history;
  }
  var HashChangeEvent$1 = "hashchange";
  var HashPathCoders = {
    hashbang: {
      encodePath: function encodePath(path) {
        return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
      },
      decodePath: function decodePath(path) {
        return path.charAt(0) === "!" ? path.substr(1) : path;
      }
    },
    noslash: {
      encodePath: stripLeadingSlash,
      decodePath: addLeadingSlash
    },
    slash: {
      encodePath: addLeadingSlash,
      decodePath: addLeadingSlash
    }
  };
  function stripHash(url) {
    var hashIndex = url.indexOf("#");
    return hashIndex === -1 ? url : url.slice(0, hashIndex);
  }
  function getHashPath() {
    var href = window.location.href;
    var hashIndex = href.indexOf("#");
    return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
  }
  function pushHashPath(path) {
    window.location.hash = path;
  }
  function replaceHashPath(path) {
    window.location.replace(stripHash(window.location.href) + "#" + path);
  }
  function createHashHistory(props) {
    if (props === void 0) {
      props = {};
    }
    !canUseDOM ? true ? invariant(false, "Hash history needs a DOM") : invariant(false) : void 0;
    var globalHistory = window.history;
    var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
    var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "";
    var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
    function getDOMLocation() {
      var path2 = decodePath2(getHashPath());
      true ? tiny_warning_esm_default(!basename || hasBasename(path2, basename), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path2 + '" to begin with "' + basename + '".') : void 0;
      if (basename)
        path2 = stripBasename(path2, basename);
      return createLocation(path2);
    }
    var transitionManager = createTransitionManager();
    function setState(nextState) {
      _extends(history, nextState);
      history.length = globalHistory.length;
      transitionManager.notifyListeners(history.location, history.action);
    }
    var forceNextPop = false;
    var ignorePath = null;
    function locationsAreEqual$$1(a, b) {
      return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
    }
    function handleHashChange() {
      var path2 = getHashPath();
      var encodedPath2 = encodePath2(path2);
      if (path2 !== encodedPath2) {
        replaceHashPath(encodedPath2);
      } else {
        var location = getDOMLocation();
        var prevLocation = history.location;
        if (!forceNextPop && locationsAreEqual$$1(prevLocation, location))
          return;
        if (ignorePath === createPath(location))
          return;
        ignorePath = null;
        handlePop(location);
      }
    }
    function handlePop(location) {
      if (forceNextPop) {
        forceNextPop = false;
        setState();
      } else {
        var action = "POP";
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
          if (ok) {
            setState({
              action,
              location
            });
          } else {
            revertPop(location);
          }
        });
      }
    }
    function revertPop(fromLocation) {
      var toLocation = history.location;
      var toIndex = allPaths.lastIndexOf(createPath(toLocation));
      if (toIndex === -1)
        toIndex = 0;
      var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
      if (fromIndex === -1)
        fromIndex = 0;
      var delta = toIndex - fromIndex;
      if (delta) {
        forceNextPop = true;
        go(delta);
      }
    }
    var path = getHashPath();
    var encodedPath = encodePath2(path);
    if (path !== encodedPath)
      replaceHashPath(encodedPath);
    var initialLocation = getDOMLocation();
    var allPaths = [createPath(initialLocation)];
    function createHref(location) {
      var baseTag = document.querySelector("base");
      var href = "";
      if (baseTag && baseTag.getAttribute("href")) {
        href = stripHash(window.location.href);
      }
      return href + "#" + encodePath2(basename + createPath(location));
    }
    function push(path2, state) {
      true ? tiny_warning_esm_default(state === void 0, "Hash history cannot push state; it is ignored") : void 0;
      var action = "PUSH";
      var location = createLocation(path2, void 0, void 0, history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        var path3 = createPath(location);
        var encodedPath2 = encodePath2(basename + path3);
        var hashChanged = getHashPath() !== encodedPath2;
        if (hashChanged) {
          ignorePath = path3;
          pushHashPath(encodedPath2);
          var prevIndex = allPaths.lastIndexOf(createPath(history.location));
          var nextPaths = allPaths.slice(0, prevIndex + 1);
          nextPaths.push(path3);
          allPaths = nextPaths;
          setState({
            action,
            location
          });
        } else {
          true ? tiny_warning_esm_default(false, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack") : void 0;
          setState();
        }
      });
    }
    function replace(path2, state) {
      true ? tiny_warning_esm_default(state === void 0, "Hash history cannot replace state; it is ignored") : void 0;
      var action = "REPLACE";
      var location = createLocation(path2, void 0, void 0, history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        var path3 = createPath(location);
        var encodedPath2 = encodePath2(basename + path3);
        var hashChanged = getHashPath() !== encodedPath2;
        if (hashChanged) {
          ignorePath = path3;
          replaceHashPath(encodedPath2);
        }
        var prevIndex = allPaths.indexOf(createPath(history.location));
        if (prevIndex !== -1)
          allPaths[prevIndex] = path3;
        setState({
          action,
          location
        });
      });
    }
    function go(n) {
      true ? tiny_warning_esm_default(canGoWithoutReload, "Hash history go(n) causes a full page reload in this browser") : void 0;
      globalHistory.go(n);
    }
    function goBack() {
      go(-1);
    }
    function goForward() {
      go(1);
    }
    var listenerCount = 0;
    function checkDOMListeners(delta) {
      listenerCount += delta;
      if (listenerCount === 1 && delta === 1) {
        window.addEventListener(HashChangeEvent$1, handleHashChange);
      } else if (listenerCount === 0) {
        window.removeEventListener(HashChangeEvent$1, handleHashChange);
      }
    }
    var isBlocked = false;
    function block2(prompt) {
      if (prompt === void 0) {
        prompt = false;
      }
      var unblock = transitionManager.setPrompt(prompt);
      if (!isBlocked) {
        checkDOMListeners(1);
        isBlocked = true;
      }
      return function() {
        if (isBlocked) {
          isBlocked = false;
          checkDOMListeners(-1);
        }
        return unblock();
      };
    }
    function listen(listener) {
      var unlisten = transitionManager.appendListener(listener);
      checkDOMListeners(1);
      return function() {
        checkDOMListeners(-1);
        unlisten();
      };
    }
    var history = {
      length: globalHistory.length,
      action: "POP",
      location: initialLocation,
      createHref,
      push,
      replace,
      go,
      goBack,
      goForward,
      block: block2,
      listen
    };
    return history;
  }
  function clamp(n, lowerBound, upperBound) {
    return Math.min(Math.max(n, lowerBound), upperBound);
  }
  function createMemoryHistory(props) {
    if (props === void 0) {
      props = {};
    }
    var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
    var transitionManager = createTransitionManager();
    function setState(nextState) {
      _extends(history, nextState);
      history.length = history.entries.length;
      transitionManager.notifyListeners(history.location, history.action);
    }
    function createKey() {
      return Math.random().toString(36).substr(2, keyLength);
    }
    var index2 = clamp(initialIndex, 0, initialEntries.length - 1);
    var entries = initialEntries.map(function(entry) {
      return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
    });
    var createHref = createPath;
    function push(path, state) {
      true ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
      var action = "PUSH";
      var location = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        var prevIndex = history.index;
        var nextIndex = prevIndex + 1;
        var nextEntries = history.entries.slice(0);
        if (nextEntries.length > nextIndex) {
          nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
        } else {
          nextEntries.push(location);
        }
        setState({
          action,
          location,
          index: nextIndex,
          entries: nextEntries
        });
      });
    }
    function replace(path, state) {
      true ? tiny_warning_esm_default(!(typeof path === "object" && path.state !== void 0 && state !== void 0), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
      var action = "REPLACE";
      var location = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
        if (!ok)
          return;
        history.entries[history.index] = location;
        setState({
          action,
          location
        });
      });
    }
    function go(n) {
      var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
      var action = "POP";
      var location = history.entries[nextIndex];
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
        if (ok) {
          setState({
            action,
            location,
            index: nextIndex
          });
        } else {
          setState();
        }
      });
    }
    function goBack() {
      go(-1);
    }
    function goForward() {
      go(1);
    }
    function canGo(n) {
      var nextIndex = history.index + n;
      return nextIndex >= 0 && nextIndex < history.entries.length;
    }
    function block2(prompt) {
      if (prompt === void 0) {
        prompt = false;
      }
      return transitionManager.setPrompt(prompt);
    }
    function listen(listener) {
      return transitionManager.appendListener(listener);
    }
    var history = {
      length: entries.length,
      action: "POP",
      location: entries[index2],
      index: index2,
      entries,
      createHref,
      push,
      replace,
      go,
      goBack,
      goForward,
      canGo,
      block: block2,
      listen
    };
    return history;
  }

  // node_modules/mini-create-react-context/dist/esm/index.js
  var import_react109 = __toESM(require_react());

  // node_modules/mini-create-react-context/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf2(o, p) {
    _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf2(o, p);
  }

  // node_modules/mini-create-react-context/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
  function _inheritsLoose3(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf2(subClass, superClass);
  }

  // node_modules/mini-create-react-context/dist/esm/index.js
  var import_prop_types5 = __toESM(require_prop_types());
  var MAX_SIGNED_31_BIT_INT = 1073741823;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  function getUniqueId() {
    var key = "__global_unique_id__";
    return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
  }
  function objectIs(x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }
  function createEventEmitter(value) {
    var handlers = [];
    return {
      on: function on(handler) {
        handlers.push(handler);
      },
      off: function off(handler) {
        handlers = handlers.filter(function(h) {
          return h !== handler;
        });
      },
      get: function get4() {
        return value;
      },
      set: function set(newValue, changedBits) {
        value = newValue;
        handlers.forEach(function(handler) {
          return handler(value, changedBits);
        });
      }
    };
  }
  function onlyChild(children2) {
    return Array.isArray(children2) ? children2[0] : children2;
  }
  function createReactContext(defaultValue, calculateChangedBits) {
    var _Provider$childContex, _Consumer$contextType;
    var contextProp = "__create-react-context-" + getUniqueId() + "__";
    var Provider = /* @__PURE__ */ function(_Component) {
      _inheritsLoose3(Provider2, _Component);
      function Provider2() {
        var _this;
        _this = _Component.apply(this, arguments) || this;
        _this.emitter = createEventEmitter(_this.props.value);
        return _this;
      }
      var _proto = Provider2.prototype;
      _proto.getChildContext = function getChildContext() {
        var _ref;
        return _ref = {}, _ref[contextProp] = this.emitter, _ref;
      };
      _proto.componentWillReceiveProps = function componentWillReceiveProps2(nextProps) {
        if (this.props.value !== nextProps.value) {
          var oldValue = this.props.value;
          var newValue = nextProps.value;
          var changedBits;
          if (objectIs(oldValue, newValue)) {
            changedBits = 0;
          } else {
            changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
            if (true) {
              tiny_warning_esm_default((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, "calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: " + changedBits);
            }
            changedBits |= 0;
            if (changedBits !== 0) {
              this.emitter.set(nextProps.value, changedBits);
            }
          }
        }
      };
      _proto.render = function render() {
        return this.props.children;
      };
      return Provider2;
    }(import_react109.Component);
    Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = import_prop_types5.default.object.isRequired, _Provider$childContex);
    var Consumer = /* @__PURE__ */ function(_Component2) {
      _inheritsLoose3(Consumer2, _Component2);
      function Consumer2() {
        var _this2;
        _this2 = _Component2.apply(this, arguments) || this;
        _this2.state = {
          value: _this2.getValue()
        };
        _this2.onUpdate = function(newValue, changedBits) {
          var observedBits = _this2.observedBits | 0;
          if ((observedBits & changedBits) !== 0) {
            _this2.setState({
              value: _this2.getValue()
            });
          }
        };
        return _this2;
      }
      var _proto2 = Consumer2.prototype;
      _proto2.componentWillReceiveProps = function componentWillReceiveProps2(nextProps) {
        var observedBits = nextProps.observedBits;
        this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
      };
      _proto2.componentDidMount = function componentDidMount() {
        if (this.context[contextProp]) {
          this.context[contextProp].on(this.onUpdate);
        }
        var observedBits = this.props.observedBits;
        this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
      };
      _proto2.componentWillUnmount = function componentWillUnmount() {
        if (this.context[contextProp]) {
          this.context[contextProp].off(this.onUpdate);
        }
      };
      _proto2.getValue = function getValue() {
        if (this.context[contextProp]) {
          return this.context[contextProp].get();
        } else {
          return defaultValue;
        }
      };
      _proto2.render = function render() {
        return onlyChild(this.props.children)(this.state.value);
      };
      return Consumer2;
    }(import_react109.Component);
    Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = import_prop_types5.default.object, _Consumer$contextType);
    return {
      Provider,
      Consumer
    };
  }
  var index = import_react109.default.createContext || createReactContext;
  var esm_default = index;

  // node_modules/react-router/node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends2() {
    _extends2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }

  // node_modules/react-router/esm/react-router.js
  var import_path_to_regexp = __toESM(require_path_to_regexp());
  var import_react_is = __toESM(require_react_is());

  // node_modules/react-router/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }

  // node_modules/react-router/esm/react-router.js
  var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
  var createNamedContext = function createNamedContext2(name) {
    var context2 = esm_default();
    context2.displayName = name;
    return context2;
  };
  var historyContext = /* @__PURE__ */ createNamedContext("Router-History");
  var context = /* @__PURE__ */ createNamedContext("Router");
  var Router = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(Router2, _React$Component);
    Router2.computeRootMatch = function computeRootMatch(pathname) {
      return {
        path: "/",
        url: "/",
        params: {},
        isExact: pathname === "/"
      };
    };
    function Router2(props) {
      var _this;
      _this = _React$Component.call(this, props) || this;
      _this.state = {
        location: props.history.location
      };
      _this._isMounted = false;
      _this._pendingLocation = null;
      if (!props.staticContext) {
        _this.unlisten = props.history.listen(function(location) {
          if (_this._isMounted) {
            _this.setState({
              location
            });
          } else {
            _this._pendingLocation = location;
          }
        });
      }
      return _this;
    }
    var _proto = Router2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this._isMounted = true;
      if (this._pendingLocation) {
        this.setState({
          location: this._pendingLocation
        });
      }
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this.unlisten) {
        this.unlisten();
        this._isMounted = false;
        this._pendingLocation = null;
      }
    };
    _proto.render = function render() {
      return /* @__PURE__ */ import_react110.default.createElement(context.Provider, {
        value: {
          history: this.props.history,
          location: this.state.location,
          match: Router2.computeRootMatch(this.state.location.pathname),
          staticContext: this.props.staticContext
        }
      }, /* @__PURE__ */ import_react110.default.createElement(historyContext.Provider, {
        children: this.props.children || null,
        value: this.props.history
      }));
    };
    return Router2;
  }(import_react110.default.Component);
  if (true) {
    Router.propTypes = {
      children: import_prop_types6.default.node,
      history: import_prop_types6.default.object.isRequired,
      staticContext: import_prop_types6.default.object
    };
    Router.prototype.componentDidUpdate = function(prevProps) {
      true ? tiny_warning_esm_default(prevProps.history === this.props.history, "You cannot change <Router history>") : void 0;
    };
  }
  var MemoryRouter = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(MemoryRouter2, _React$Component);
    function MemoryRouter2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.history = createMemoryHistory(_this.props);
      return _this;
    }
    var _proto = MemoryRouter2.prototype;
    _proto.render = function render() {
      return /* @__PURE__ */ import_react110.default.createElement(Router, {
        history: this.history,
        children: this.props.children
      });
    };
    return MemoryRouter2;
  }(import_react110.default.Component);
  if (true) {
    MemoryRouter.propTypes = {
      initialEntries: import_prop_types6.default.array,
      initialIndex: import_prop_types6.default.number,
      getUserConfirmation: import_prop_types6.default.func,
      keyLength: import_prop_types6.default.number,
      children: import_prop_types6.default.node
    };
    MemoryRouter.prototype.componentDidMount = function() {
      true ? tiny_warning_esm_default(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { MemoryRouter as Router }`.") : void 0;
    };
  }
  var Lifecycle = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(Lifecycle2, _React$Component);
    function Lifecycle2() {
      return _React$Component.apply(this, arguments) || this;
    }
    var _proto = Lifecycle2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      if (this.props.onMount)
        this.props.onMount.call(this, this);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (this.props.onUpdate)
        this.props.onUpdate.call(this, this, prevProps);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this.props.onUnmount)
        this.props.onUnmount.call(this, this);
    };
    _proto.render = function render() {
      return null;
    };
    return Lifecycle2;
  }(import_react110.default.Component);
  function Prompt(_ref) {
    var message = _ref.message, _ref$when = _ref.when, when = _ref$when === void 0 ? true : _ref$when;
    return /* @__PURE__ */ import_react110.default.createElement(context.Consumer, null, function(context2) {
      !context2 ? true ? invariant(false, "You should not use <Prompt> outside a <Router>") : invariant(false) : void 0;
      if (!when || context2.staticContext)
        return null;
      var method = context2.history.block;
      return /* @__PURE__ */ import_react110.default.createElement(Lifecycle, {
        onMount: function onMount(self2) {
          self2.release = method(message);
        },
        onUpdate: function onUpdate(self2, prevProps) {
          if (prevProps.message !== message) {
            self2.release();
            self2.release = method(message);
          }
        },
        onUnmount: function onUnmount(self2) {
          self2.release();
        },
        message
      });
    });
  }
  if (true) {
    messageType = import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.string]);
    Prompt.propTypes = {
      when: import_prop_types6.default.bool,
      message: messageType.isRequired
    };
  }
  var messageType;
  var cache = {};
  var cacheLimit = 1e4;
  var cacheCount = 0;
  function compilePath(path) {
    if (cache[path])
      return cache[path];
    var generator = import_path_to_regexp.default.compile(path);
    if (cacheCount < cacheLimit) {
      cache[path] = generator;
      cacheCount++;
    }
    return generator;
  }
  function generatePath(path, params) {
    if (path === void 0) {
      path = "/";
    }
    if (params === void 0) {
      params = {};
    }
    return path === "/" ? path : compilePath(path)(params, {
      pretty: true
    });
  }
  function Redirect(_ref) {
    var computedMatch = _ref.computedMatch, to = _ref.to, _ref$push = _ref.push, push = _ref$push === void 0 ? false : _ref$push;
    return /* @__PURE__ */ import_react110.default.createElement(context.Consumer, null, function(context2) {
      !context2 ? true ? invariant(false, "You should not use <Redirect> outside a <Router>") : invariant(false) : void 0;
      var history = context2.history, staticContext = context2.staticContext;
      var method = push ? history.push : history.replace;
      var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends2({}, to, {
        pathname: generatePath(to.pathname, computedMatch.params)
      }) : to);
      if (staticContext) {
        method(location);
        return null;
      }
      return /* @__PURE__ */ import_react110.default.createElement(Lifecycle, {
        onMount: function onMount() {
          method(location);
        },
        onUpdate: function onUpdate(self2, prevProps) {
          var prevLocation = createLocation(prevProps.to);
          if (!locationsAreEqual(prevLocation, _extends2({}, location, {
            key: prevLocation.key
          }))) {
            method(location);
          }
        },
        to
      });
    });
  }
  if (true) {
    Redirect.propTypes = {
      push: import_prop_types6.default.bool,
      from: import_prop_types6.default.string,
      to: import_prop_types6.default.oneOfType([import_prop_types6.default.string, import_prop_types6.default.object]).isRequired
    };
  }
  var cache$1 = {};
  var cacheLimit$1 = 1e4;
  var cacheCount$1 = 0;
  function compilePath$1(path, options) {
    var cacheKey = "" + options.end + options.strict + options.sensitive;
    var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
    if (pathCache[path])
      return pathCache[path];
    var keys = [];
    var regexp = (0, import_path_to_regexp.default)(path, keys, options);
    var result2 = {
      regexp,
      keys
    };
    if (cacheCount$1 < cacheLimit$1) {
      pathCache[path] = result2;
      cacheCount$1++;
    }
    return result2;
  }
  function matchPath(pathname, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof options === "string" || Array.isArray(options)) {
      options = {
        path: options
      };
    }
    var _options = options, path = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
    var paths = [].concat(path);
    return paths.reduce(function(matched, path2) {
      if (!path2 && path2 !== "")
        return null;
      if (matched)
        return matched;
      var _compilePath = compilePath$1(path2, {
        end: exact,
        strict,
        sensitive
      }), regexp = _compilePath.regexp, keys = _compilePath.keys;
      var match = regexp.exec(pathname);
      if (!match)
        return null;
      var url = match[0], values2 = match.slice(1);
      var isExact = pathname === url;
      if (exact && !isExact)
        return null;
      return {
        path: path2,
        url: path2 === "/" && url === "" ? "/" : url,
        isExact,
        params: keys.reduce(function(memo7, key, index2) {
          memo7[key.name] = values2[index2];
          return memo7;
        }, {})
      };
    }, null);
  }
  function isEmptyChildren(children2) {
    return import_react110.default.Children.count(children2) === 0;
  }
  function evalChildrenDev(children2, props, path) {
    var value = children2(props);
    true ? tiny_warning_esm_default(value !== void 0, "You returned `undefined` from the `children` function of " + ("<Route" + (path ? ' path="' + path + '"' : "") + ">, but you ") + "should have returned a React element or `null`") : void 0;
    return value || null;
  }
  var Route = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(Route2, _React$Component);
    function Route2() {
      return _React$Component.apply(this, arguments) || this;
    }
    var _proto = Route2.prototype;
    _proto.render = function render() {
      var _this = this;
      return /* @__PURE__ */ import_react110.default.createElement(context.Consumer, null, function(context$1) {
        !context$1 ? true ? invariant(false, "You should not use <Route> outside a <Router>") : invariant(false) : void 0;
        var location = _this.props.location || context$1.location;
        var match = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;
        var props = _extends2({}, context$1, {
          location,
          match
        });
        var _this$props = _this.props, children2 = _this$props.children, component = _this$props.component, render2 = _this$props.render;
        if (Array.isArray(children2) && isEmptyChildren(children2)) {
          children2 = null;
        }
        return /* @__PURE__ */ import_react110.default.createElement(context.Provider, {
          value: props
        }, props.match ? children2 ? typeof children2 === "function" ? true ? evalChildrenDev(children2, props, _this.props.path) : children2(props) : children2 : component ? /* @__PURE__ */ import_react110.default.createElement(component, props) : render2 ? render2(props) : null : typeof children2 === "function" ? true ? evalChildrenDev(children2, props, _this.props.path) : children2(props) : null);
      });
    };
    return Route2;
  }(import_react110.default.Component);
  if (true) {
    Route.propTypes = {
      children: import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.node]),
      component: function component(props, propName) {
        if (props[propName] && !(0, import_react_is.isValidElementType)(props[propName])) {
          return new Error("Invalid prop 'component' supplied to 'Route': the prop is not a valid React component");
        }
      },
      exact: import_prop_types6.default.bool,
      location: import_prop_types6.default.object,
      path: import_prop_types6.default.oneOfType([import_prop_types6.default.string, import_prop_types6.default.arrayOf(import_prop_types6.default.string)]),
      render: import_prop_types6.default.func,
      sensitive: import_prop_types6.default.bool,
      strict: import_prop_types6.default.bool
    };
    Route.prototype.componentDidMount = function() {
      true ? tiny_warning_esm_default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.component), "You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored") : void 0;
      true ? tiny_warning_esm_default(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.render), "You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored") : void 0;
      true ? tiny_warning_esm_default(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored") : void 0;
    };
    Route.prototype.componentDidUpdate = function(prevProps) {
      true ? tiny_warning_esm_default(!(this.props.location && !prevProps.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
      true ? tiny_warning_esm_default(!(!this.props.location && prevProps.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
    };
  }
  function addLeadingSlash2(path) {
    return path.charAt(0) === "/" ? path : "/" + path;
  }
  function addBasename(basename, location) {
    if (!basename)
      return location;
    return _extends2({}, location, {
      pathname: addLeadingSlash2(basename) + location.pathname
    });
  }
  function stripBasename2(basename, location) {
    if (!basename)
      return location;
    var base = addLeadingSlash2(basename);
    if (location.pathname.indexOf(base) !== 0)
      return location;
    return _extends2({}, location, {
      pathname: location.pathname.substr(base.length)
    });
  }
  function createURL(location) {
    return typeof location === "string" ? location : createPath(location);
  }
  function staticHandler(methodName) {
    return function() {
      true ? invariant(false, "You cannot %s with <StaticRouter>", methodName) : invariant(false);
    };
  }
  function noop4() {
  }
  var StaticRouter = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(StaticRouter2, _React$Component);
    function StaticRouter2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.handlePush = function(location) {
        return _this.navigateTo(location, "PUSH");
      };
      _this.handleReplace = function(location) {
        return _this.navigateTo(location, "REPLACE");
      };
      _this.handleListen = function() {
        return noop4;
      };
      _this.handleBlock = function() {
        return noop4;
      };
      return _this;
    }
    var _proto = StaticRouter2.prototype;
    _proto.navigateTo = function navigateTo(location, action) {
      var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
      context2.action = action;
      context2.location = addBasename(basename, createLocation(location));
      context2.url = createURL(context2.location);
    };
    _proto.render = function render() {
      var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose2(_this$props2, ["basename", "context", "location"]);
      var history = {
        createHref: function createHref(path) {
          return addLeadingSlash2(basename + createURL(path));
        },
        action: "POP",
        location: stripBasename2(basename, createLocation(location)),
        push: this.handlePush,
        replace: this.handleReplace,
        go: staticHandler("go"),
        goBack: staticHandler("goBack"),
        goForward: staticHandler("goForward"),
        listen: this.handleListen,
        block: this.handleBlock
      };
      return /* @__PURE__ */ import_react110.default.createElement(Router, _extends2({}, rest, {
        history,
        staticContext: context2
      }));
    };
    return StaticRouter2;
  }(import_react110.default.Component);
  if (true) {
    StaticRouter.propTypes = {
      basename: import_prop_types6.default.string,
      context: import_prop_types6.default.object,
      location: import_prop_types6.default.oneOfType([import_prop_types6.default.string, import_prop_types6.default.object])
    };
    StaticRouter.prototype.componentDidMount = function() {
      true ? tiny_warning_esm_default(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { StaticRouter as Router }`.") : void 0;
    };
  }
  var Switch = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(Switch2, _React$Component);
    function Switch2() {
      return _React$Component.apply(this, arguments) || this;
    }
    var _proto = Switch2.prototype;
    _proto.render = function render() {
      var _this = this;
      return /* @__PURE__ */ import_react110.default.createElement(context.Consumer, null, function(context2) {
        !context2 ? true ? invariant(false, "You should not use <Switch> outside a <Router>") : invariant(false) : void 0;
        var location = _this.props.location || context2.location;
        var element, match;
        import_react110.default.Children.forEach(_this.props.children, function(child) {
          if (match == null && /* @__PURE__ */ import_react110.default.isValidElement(child)) {
            element = child;
            var path = child.props.path || child.props.from;
            match = path ? matchPath(location.pathname, _extends2({}, child.props, {
              path
            })) : context2.match;
          }
        });
        return match ? /* @__PURE__ */ import_react110.default.cloneElement(element, {
          location,
          computedMatch: match
        }) : null;
      });
    };
    return Switch2;
  }(import_react110.default.Component);
  if (true) {
    Switch.propTypes = {
      children: import_prop_types6.default.node,
      location: import_prop_types6.default.object
    };
    Switch.prototype.componentDidUpdate = function(prevProps) {
      true ? tiny_warning_esm_default(!(this.props.location && !prevProps.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : void 0;
      true ? tiny_warning_esm_default(!(!this.props.location && prevProps.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : void 0;
    };
  }
  var useContext11 = import_react110.default.useContext;
  function useHistory() {
    if (true) {
      !(typeof useContext11 === "function") ? true ? invariant(false, "You must use React >= 16.8 in order to use useHistory()") : invariant(false) : void 0;
    }
    return useContext11(historyContext);
  }
  function useLocation() {
    if (true) {
      !(typeof useContext11 === "function") ? true ? invariant(false, "You must use React >= 16.8 in order to use useLocation()") : invariant(false) : void 0;
    }
    return useContext11(context).location;
  }
  function useParams() {
    if (true) {
      !(typeof useContext11 === "function") ? true ? invariant(false, "You must use React >= 16.8 in order to use useParams()") : invariant(false) : void 0;
    }
    var match = useContext11(context).match;
    return match ? match.params : {};
  }
  if (true) {
    if (typeof window !== "undefined") {
      global2 = window;
      key = "__react_router_build__";
      buildNames = {
        cjs: "CommonJS",
        esm: "ES modules",
        umd: "UMD"
      };
      if (global2[key] && global2[key] !== "esm") {
        initialBuildName = buildNames[global2[key]];
        secondaryBuildName = buildNames["esm"];
        throw new Error("You are loading the " + secondaryBuildName + " build of React Router " + ("on a page that is already running the " + initialBuildName + " ") + "build, so things won't work right.");
      }
      global2[key] = "esm";
    }
  }
  var global2;
  var key;
  var buildNames;
  var initialBuildName;
  var secondaryBuildName;

  // node_modules/react-router-dom/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf3(o, p) {
    _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf3(o, p);
  }

  // node_modules/react-router-dom/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
  function _inheritsLoose4(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf3(subClass, superClass);
  }

  // node_modules/react-router-dom/esm/react-router-dom.js
  var import_react111 = __toESM(require_react());
  var import_prop_types7 = __toESM(require_prop_types());

  // node_modules/react-router-dom/node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends3() {
    _extends3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }

  // node_modules/react-router-dom/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose3(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }

  // node_modules/react-router-dom/esm/react-router-dom.js
  var BrowserRouter = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose4(BrowserRouter2, _React$Component);
    function BrowserRouter2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.history = createBrowserHistory(_this.props);
      return _this;
    }
    var _proto = BrowserRouter2.prototype;
    _proto.render = function render() {
      return /* @__PURE__ */ import_react111.default.createElement(Router, {
        history: this.history,
        children: this.props.children
      });
    };
    return BrowserRouter2;
  }(import_react111.default.Component);
  if (true) {
    BrowserRouter.propTypes = {
      basename: import_prop_types7.default.string,
      children: import_prop_types7.default.node,
      forceRefresh: import_prop_types7.default.bool,
      getUserConfirmation: import_prop_types7.default.func,
      keyLength: import_prop_types7.default.number
    };
    BrowserRouter.prototype.componentDidMount = function() {
      true ? tiny_warning_esm_default(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { BrowserRouter as Router }`.") : void 0;
    };
  }
  var HashRouter = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose4(HashRouter2, _React$Component);
    function HashRouter2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.history = createHashHistory(_this.props);
      return _this;
    }
    var _proto = HashRouter2.prototype;
    _proto.render = function render() {
      return /* @__PURE__ */ import_react111.default.createElement(Router, {
        history: this.history,
        children: this.props.children
      });
    };
    return HashRouter2;
  }(import_react111.default.Component);
  if (true) {
    HashRouter.propTypes = {
      basename: import_prop_types7.default.string,
      children: import_prop_types7.default.node,
      getUserConfirmation: import_prop_types7.default.func,
      hashType: import_prop_types7.default.oneOf(["hashbang", "noslash", "slash"])
    };
    HashRouter.prototype.componentDidMount = function() {
      true ? tiny_warning_esm_default(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { HashRouter as Router }`.") : void 0;
    };
  }
  var resolveToLocation = function resolveToLocation2(to, currentLocation) {
    return typeof to === "function" ? to(currentLocation) : to;
  };
  var normalizeToLocation = function normalizeToLocation2(to, currentLocation) {
    return typeof to === "string" ? createLocation(to, null, null, currentLocation) : to;
  };
  var forwardRefShim = function forwardRefShim2(C) {
    return C;
  };
  var forwardRef4 = import_react111.default.forwardRef;
  if (typeof forwardRef4 === "undefined") {
    forwardRef4 = forwardRefShim;
  }
  function isModifiedEvent(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
  }
  var LinkAnchor = forwardRef4(function(_ref, forwardedRef) {
    var innerRef = _ref.innerRef, navigate = _ref.navigate, _onClick = _ref.onClick, rest = _objectWithoutPropertiesLoose3(_ref, ["innerRef", "navigate", "onClick"]);
    var target = rest.target;
    var props = _extends3({}, rest, {
      onClick: function onClick(event) {
        try {
          if (_onClick)
            _onClick(event);
        } catch (ex) {
          event.preventDefault();
          throw ex;
        }
        if (!event.defaultPrevented && event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
          event.preventDefault();
          navigate();
        }
      }
    });
    if (forwardRefShim !== forwardRef4) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.ref = innerRef;
    }
    return /* @__PURE__ */ import_react111.default.createElement("a", props);
  });
  if (true) {
    LinkAnchor.displayName = "LinkAnchor";
  }
  var Link = forwardRef4(function(_ref2, forwardedRef) {
    var _ref2$component = _ref2.component, component = _ref2$component === void 0 ? LinkAnchor : _ref2$component, replace = _ref2.replace, to = _ref2.to, innerRef = _ref2.innerRef, rest = _objectWithoutPropertiesLoose3(_ref2, ["component", "replace", "to", "innerRef"]);
    return /* @__PURE__ */ import_react111.default.createElement(context.Consumer, null, function(context2) {
      !context2 ? true ? invariant(false, "You should not use <Link> outside a <Router>") : invariant(false) : void 0;
      var history = context2.history;
      var location = normalizeToLocation(resolveToLocation(to, context2.location), context2.location);
      var href = location ? history.createHref(location) : "";
      var props = _extends3({}, rest, {
        href,
        navigate: function navigate() {
          var location2 = resolveToLocation(to, context2.location);
          var isDuplicateNavigation = createPath(context2.location) === createPath(normalizeToLocation(location2));
          var method = replace || isDuplicateNavigation ? history.replace : history.push;
          method(location2);
        }
      });
      if (forwardRefShim !== forwardRef4) {
        props.ref = forwardedRef || innerRef;
      } else {
        props.innerRef = innerRef;
      }
      return /* @__PURE__ */ import_react111.default.createElement(component, props);
    });
  });
  if (true) {
    toType = import_prop_types7.default.oneOfType([import_prop_types7.default.string, import_prop_types7.default.object, import_prop_types7.default.func]);
    refType = import_prop_types7.default.oneOfType([import_prop_types7.default.string, import_prop_types7.default.func, import_prop_types7.default.shape({
      current: import_prop_types7.default.any
    })]);
    Link.displayName = "Link";
    Link.propTypes = {
      innerRef: refType,
      onClick: import_prop_types7.default.func,
      replace: import_prop_types7.default.bool,
      target: import_prop_types7.default.string,
      to: toType.isRequired
    };
  }
  var toType;
  var refType;
  var forwardRefShim$1 = function forwardRefShim3(C) {
    return C;
  };
  var forwardRef$1 = import_react111.default.forwardRef;
  if (typeof forwardRef$1 === "undefined") {
    forwardRef$1 = forwardRefShim$1;
  }
  function joinClassnames() {
    for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
      classnames[_key] = arguments[_key];
    }
    return classnames.filter(function(i) {
      return i;
    }).join(" ");
  }
  var NavLink = forwardRef$1(function(_ref, forwardedRef) {
    var _ref$ariaCurrent = _ref["aria-current"], ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent, _ref$activeClassName = _ref.activeClassName, activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName, activeStyle = _ref.activeStyle, classNameProp = _ref.className, exact = _ref.exact, isActiveProp = _ref.isActive, locationProp = _ref.location, sensitive = _ref.sensitive, strict = _ref.strict, styleProp = _ref.style, to = _ref.to, innerRef = _ref.innerRef, rest = _objectWithoutPropertiesLoose3(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
    return /* @__PURE__ */ import_react111.default.createElement(context.Consumer, null, function(context2) {
      !context2 ? true ? invariant(false, "You should not use <NavLink> outside a <Router>") : invariant(false) : void 0;
      var currentLocation = locationProp || context2.location;
      var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
      var path = toLocation.pathname;
      var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
      var match = escapedPath ? matchPath(currentLocation.pathname, {
        path: escapedPath,
        exact,
        sensitive,
        strict
      }) : null;
      var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
      var className = typeof classNameProp === "function" ? classNameProp(isActive) : classNameProp;
      var style4 = typeof styleProp === "function" ? styleProp(isActive) : styleProp;
      if (isActive) {
        className = joinClassnames(className, activeClassName);
        style4 = _extends3({}, style4, activeStyle);
      }
      var props = _extends3({
        "aria-current": isActive && ariaCurrent || null,
        className,
        style: style4,
        to: toLocation
      }, rest);
      if (forwardRefShim$1 !== forwardRef$1) {
        props.ref = forwardedRef || innerRef;
      } else {
        props.innerRef = innerRef;
      }
      return /* @__PURE__ */ import_react111.default.createElement(Link, props);
    });
  });
  if (true) {
    NavLink.displayName = "NavLink";
    ariaCurrentType = import_prop_types7.default.oneOf(["page", "step", "location", "date", "time", "true", "false"]);
    NavLink.propTypes = _extends3({}, Link.propTypes, {
      "aria-current": ariaCurrentType,
      activeClassName: import_prop_types7.default.string,
      activeStyle: import_prop_types7.default.object,
      className: import_prop_types7.default.oneOfType([import_prop_types7.default.string, import_prop_types7.default.func]),
      exact: import_prop_types7.default.bool,
      isActive: import_prop_types7.default.func,
      location: import_prop_types7.default.object,
      sensitive: import_prop_types7.default.bool,
      strict: import_prop_types7.default.bool,
      style: import_prop_types7.default.oneOfType([import_prop_types7.default.object, import_prop_types7.default.func])
    });
  }
  var ariaCurrentType;

  // src/components/Users/users.jsx
  var import_react116 = __toESM(require_react());

  // src/components/Users/user.jsx
  var import_react112 = __toESM(require_react());

  // node_modules/react-virtualized/dist/es/ArrowKeyStepper/ArrowKeyStepper.js
  var import_classCallCheck4 = __toESM(require_classCallCheck());
  var import_createClass4 = __toESM(require_createClass());
  var import_possibleConstructorReturn2 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf2 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized3 = __toESM(require_assertThisInitialized());
  var import_inherits2 = __toESM(require_inherits());
  var import_defineProperty4 = __toESM(require_defineProperty());
  var React80 = __toESM(require_react());

  // node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js
  function componentWillMount() {
    var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
    if (state !== null && state !== void 0) {
      this.setState(state);
    }
  }
  function componentWillReceiveProps(nextProps) {
    function updater(prevState) {
      var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
      return state !== null && state !== void 0 ? state : null;
    }
    this.setState(updater.bind(this));
  }
  function componentWillUpdate(nextProps, nextState) {
    try {
      var prevProps = this.props;
      var prevState = this.state;
      this.props = nextProps;
      this.state = nextState;
      this.__reactInternalSnapshotFlag = true;
      this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
    } finally {
      this.props = prevProps;
      this.state = prevState;
    }
  }
  componentWillMount.__suppressDeprecationWarning = true;
  componentWillReceiveProps.__suppressDeprecationWarning = true;
  componentWillUpdate.__suppressDeprecationWarning = true;
  function polyfill(Component6) {
    var prototype2 = Component6.prototype;
    if (!prototype2 || !prototype2.isReactComponent) {
      throw new Error("Can only polyfill class components");
    }
    if (typeof Component6.getDerivedStateFromProps !== "function" && typeof prototype2.getSnapshotBeforeUpdate !== "function") {
      return Component6;
    }
    var foundWillMountName = null;
    var foundWillReceivePropsName = null;
    var foundWillUpdateName = null;
    if (typeof prototype2.componentWillMount === "function") {
      foundWillMountName = "componentWillMount";
    } else if (typeof prototype2.UNSAFE_componentWillMount === "function") {
      foundWillMountName = "UNSAFE_componentWillMount";
    }
    if (typeof prototype2.componentWillReceiveProps === "function") {
      foundWillReceivePropsName = "componentWillReceiveProps";
    } else if (typeof prototype2.UNSAFE_componentWillReceiveProps === "function") {
      foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
    }
    if (typeof prototype2.componentWillUpdate === "function") {
      foundWillUpdateName = "componentWillUpdate";
    } else if (typeof prototype2.UNSAFE_componentWillUpdate === "function") {
      foundWillUpdateName = "UNSAFE_componentWillUpdate";
    }
    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
      var componentName = Component6.displayName || Component6.name;
      var newApiName = typeof Component6.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
      throw Error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + componentName + " uses " + newApiName + " but also contains the following legacy lifecycles:" + (foundWillMountName !== null ? "\n  " + foundWillMountName : "") + (foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "") + (foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks");
    }
    if (typeof Component6.getDerivedStateFromProps === "function") {
      prototype2.componentWillMount = componentWillMount;
      prototype2.componentWillReceiveProps = componentWillReceiveProps;
    }
    if (typeof prototype2.getSnapshotBeforeUpdate === "function") {
      if (typeof prototype2.componentDidUpdate !== "function") {
        throw new Error("Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype");
      }
      prototype2.componentWillUpdate = componentWillUpdate;
      var componentDidUpdate = prototype2.componentDidUpdate;
      prototype2.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
        var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
        componentDidUpdate.call(this, prevProps, prevState, snapshot);
      };
    }
    return Component6;
  }

  // node_modules/react-virtualized/dist/es/Grid/Grid.js
  var import_extends6 = __toESM(require_extends());
  var import_classCallCheck3 = __toESM(require_classCallCheck());
  var import_createClass3 = __toESM(require_createClass());
  var import_possibleConstructorReturn = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized2 = __toESM(require_assertThisInitialized());
  var import_inherits = __toESM(require_inherits());
  var import_defineProperty3 = __toESM(require_defineProperty());
  var React79 = __toESM(require_react());

  // node_modules/clsx/dist/clsx.m.js
  function r(e) {
    var t, f, n = "";
    if (typeof e == "string" || typeof e == "number")
      n += e;
    else if (typeof e == "object")
      if (Array.isArray(e))
        for (t = 0; t < e.length; t++)
          e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
      else
        for (t in e)
          e[t] && (n && (n += " "), n += t);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length; )
      (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }
  var clsx_m_default = clsx;

  // node_modules/react-virtualized/dist/es/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js
  function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {
    var cellCount = _ref.cellCount, cellSize = _ref.cellSize, computeMetadataCallback = _ref.computeMetadataCallback, computeMetadataCallbackProps = _ref.computeMetadataCallbackProps, nextCellsCount = _ref.nextCellsCount, nextCellSize = _ref.nextCellSize, nextScrollToIndex = _ref.nextScrollToIndex, scrollToIndex = _ref.scrollToIndex, updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;
    if (cellCount !== nextCellsCount || (typeof cellSize === "number" || typeof nextCellSize === "number") && cellSize !== nextCellSize) {
      computeMetadataCallback(computeMetadataCallbackProps);
      if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {
        updateScrollOffsetForScrollToIndex();
      }
    }
  }

  // node_modules/react-virtualized/dist/es/Grid/utils/ScalingCellSizeAndPositionManager.js
  var import_objectWithoutProperties = __toESM(require_objectWithoutProperties());
  var import_classCallCheck2 = __toESM(require_classCallCheck());
  var import_createClass2 = __toESM(require_createClass());
  var import_defineProperty2 = __toESM(require_defineProperty());

  // node_modules/react-virtualized/dist/es/Grid/utils/CellSizeAndPositionManager.js
  var import_classCallCheck = __toESM(require_classCallCheck());
  var import_createClass = __toESM(require_createClass());
  var import_defineProperty = __toESM(require_defineProperty());

  // node_modules/react-virtualized/dist/es/Grid/types.js
  var React78 = __toESM(require_react());
  var import_prop_types8 = __toESM(require_prop_types());
  var bpfrpt_proptype_CellPosition = false ? null : {
    "columnIndex": import_prop_types8.default.number.isRequired,
    "rowIndex": import_prop_types8.default.number.isRequired
  };
  var bpfrpt_proptype_CellRendererParams = false ? null : {
    "columnIndex": import_prop_types8.default.number.isRequired,
    "isScrolling": import_prop_types8.default.bool.isRequired,
    "isVisible": import_prop_types8.default.bool.isRequired,
    "key": import_prop_types8.default.string.isRequired,
    "parent": import_prop_types8.default.object.isRequired,
    "rowIndex": import_prop_types8.default.number.isRequired,
    "style": import_prop_types8.default.object.isRequired
  };
  var bpfrpt_proptype_CellRenderer = false ? null : import_prop_types8.default.func;
  var bpfrpt_proptype_CellCache = false ? null : import_prop_types8.default.objectOf(import_prop_types8.default.node.isRequired);
  var bpfrpt_proptype_StyleCache = false ? null : import_prop_types8.default.objectOf(import_prop_types8.default.object.isRequired);
  var bpfrpt_proptype_CellRangeRendererParams = false ? null : {
    "cellCache": import_prop_types8.default.objectOf(import_prop_types8.default.node.isRequired).isRequired,
    "cellRenderer": import_prop_types8.default.func.isRequired,
    "columnSizeAndPositionManager": function columnSizeAndPositionManager() {
      return (typeof ScalingCellSizeAndPositionManager === "function" ? import_prop_types8.default.instanceOf(ScalingCellSizeAndPositionManager).isRequired : import_prop_types8.default.any.isRequired).apply(this, arguments);
    },
    "columnStartIndex": import_prop_types8.default.number.isRequired,
    "columnStopIndex": import_prop_types8.default.number.isRequired,
    "deferredMeasurementCache": import_prop_types8.default.object,
    "horizontalOffsetAdjustment": import_prop_types8.default.number.isRequired,
    "isScrolling": import_prop_types8.default.bool.isRequired,
    "isScrollingOptOut": import_prop_types8.default.bool.isRequired,
    "parent": import_prop_types8.default.object.isRequired,
    "rowSizeAndPositionManager": function rowSizeAndPositionManager() {
      return (typeof ScalingCellSizeAndPositionManager === "function" ? import_prop_types8.default.instanceOf(ScalingCellSizeAndPositionManager).isRequired : import_prop_types8.default.any.isRequired).apply(this, arguments);
    },
    "rowStartIndex": import_prop_types8.default.number.isRequired,
    "rowStopIndex": import_prop_types8.default.number.isRequired,
    "scrollLeft": import_prop_types8.default.number.isRequired,
    "scrollTop": import_prop_types8.default.number.isRequired,
    "styleCache": import_prop_types8.default.objectOf(import_prop_types8.default.object.isRequired).isRequired,
    "verticalOffsetAdjustment": import_prop_types8.default.number.isRequired,
    "visibleColumnIndices": import_prop_types8.default.object.isRequired,
    "visibleRowIndices": import_prop_types8.default.object.isRequired
  };
  var bpfrpt_proptype_CellRangeRenderer = false ? null : import_prop_types8.default.func;
  var bpfrpt_proptype_CellSizeGetter = false ? null : import_prop_types8.default.func;
  var bpfrpt_proptype_CellSize = false ? null : import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.number]);
  var bpfrpt_proptype_NoContentRenderer = false ? null : import_prop_types8.default.func;
  var bpfrpt_proptype_Scroll = false ? null : {
    "clientHeight": import_prop_types8.default.number.isRequired,
    "clientWidth": import_prop_types8.default.number.isRequired,
    "scrollHeight": import_prop_types8.default.number.isRequired,
    "scrollLeft": import_prop_types8.default.number.isRequired,
    "scrollTop": import_prop_types8.default.number.isRequired,
    "scrollWidth": import_prop_types8.default.number.isRequired
  };
  var bpfrpt_proptype_ScrollbarPresenceChange = false ? null : {
    "horizontal": import_prop_types8.default.bool.isRequired,
    "vertical": import_prop_types8.default.bool.isRequired,
    "size": import_prop_types8.default.number.isRequired
  };
  var bpfrpt_proptype_RenderedSection = false ? null : {
    "columnOverscanStartIndex": import_prop_types8.default.number.isRequired,
    "columnOverscanStopIndex": import_prop_types8.default.number.isRequired,
    "columnStartIndex": import_prop_types8.default.number.isRequired,
    "columnStopIndex": import_prop_types8.default.number.isRequired,
    "rowOverscanStartIndex": import_prop_types8.default.number.isRequired,
    "rowOverscanStopIndex": import_prop_types8.default.number.isRequired,
    "rowStartIndex": import_prop_types8.default.number.isRequired,
    "rowStopIndex": import_prop_types8.default.number.isRequired
  };
  var bpfrpt_proptype_OverscanIndicesGetterParams = false ? null : {
    "direction": import_prop_types8.default.oneOf(["horizontal", "vertical"]).isRequired,
    "scrollDirection": import_prop_types8.default.oneOf([-1, 1]).isRequired,
    "cellCount": import_prop_types8.default.number.isRequired,
    "overscanCellsCount": import_prop_types8.default.number.isRequired,
    "startIndex": import_prop_types8.default.number.isRequired,
    "stopIndex": import_prop_types8.default.number.isRequired
  };
  var bpfrpt_proptype_OverscanIndices = false ? null : {
    "overscanStartIndex": import_prop_types8.default.number.isRequired,
    "overscanStopIndex": import_prop_types8.default.number.isRequired
  };
  var bpfrpt_proptype_OverscanIndicesGetter = false ? null : import_prop_types8.default.func;
  var bpfrpt_proptype_Alignment = false ? null : import_prop_types8.default.oneOf(["auto", "end", "start", "center"]);
  var bpfrpt_proptype_VisibleCellRange = false ? null : {
    "start": import_prop_types8.default.number,
    "stop": import_prop_types8.default.number
  };

  // node_modules/react-virtualized/dist/es/Grid/utils/CellSizeAndPositionManager.js
  var CellSizeAndPositionManager = /* @__PURE__ */ function() {
    function CellSizeAndPositionManager2(_ref) {
      var cellCount = _ref.cellCount, cellSizeGetter = _ref.cellSizeGetter, estimatedCellSize = _ref.estimatedCellSize;
      (0, import_classCallCheck.default)(this, CellSizeAndPositionManager2);
      (0, import_defineProperty.default)(this, "_cellSizeAndPositionData", {});
      (0, import_defineProperty.default)(this, "_lastMeasuredIndex", -1);
      (0, import_defineProperty.default)(this, "_lastBatchedIndex", -1);
      (0, import_defineProperty.default)(this, "_cellCount", void 0);
      (0, import_defineProperty.default)(this, "_cellSizeGetter", void 0);
      (0, import_defineProperty.default)(this, "_estimatedCellSize", void 0);
      this._cellSizeGetter = cellSizeGetter;
      this._cellCount = cellCount;
      this._estimatedCellSize = estimatedCellSize;
    }
    (0, import_createClass.default)(CellSizeAndPositionManager2, [{
      key: "areOffsetsAdjusted",
      value: function areOffsetsAdjusted() {
        return false;
      }
    }, {
      key: "configure",
      value: function configure(_ref2) {
        var cellCount = _ref2.cellCount, estimatedCellSize = _ref2.estimatedCellSize, cellSizeGetter = _ref2.cellSizeGetter;
        this._cellCount = cellCount;
        this._estimatedCellSize = estimatedCellSize;
        this._cellSizeGetter = cellSizeGetter;
      }
    }, {
      key: "getCellCount",
      value: function getCellCount() {
        return this._cellCount;
      }
    }, {
      key: "getEstimatedCellSize",
      value: function getEstimatedCellSize() {
        return this._estimatedCellSize;
      }
    }, {
      key: "getLastMeasuredIndex",
      value: function getLastMeasuredIndex() {
        return this._lastMeasuredIndex;
      }
    }, {
      key: "getOffsetAdjustment",
      value: function getOffsetAdjustment() {
        return 0;
      }
    }, {
      key: "getSizeAndPositionOfCell",
      value: function getSizeAndPositionOfCell(index2) {
        if (index2 < 0 || index2 >= this._cellCount) {
          throw Error("Requested index ".concat(index2, " is outside of range 0..").concat(this._cellCount));
        }
        if (index2 > this._lastMeasuredIndex) {
          var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
          var offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;
          for (var i = this._lastMeasuredIndex + 1; i <= index2; i++) {
            var size2 = this._cellSizeGetter({
              index: i
            });
            if (size2 === void 0 || isNaN(size2)) {
              throw Error("Invalid size returned for cell ".concat(i, " of value ").concat(size2));
            } else if (size2 === null) {
              this._cellSizeAndPositionData[i] = {
                offset,
                size: 0
              };
              this._lastBatchedIndex = index2;
            } else {
              this._cellSizeAndPositionData[i] = {
                offset,
                size: size2
              };
              offset += size2;
              this._lastMeasuredIndex = index2;
            }
          }
        }
        return this._cellSizeAndPositionData[index2];
      }
    }, {
      key: "getSizeAndPositionOfLastMeasuredCell",
      value: function getSizeAndPositionOfLastMeasuredCell() {
        return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {
          offset: 0,
          size: 0
        };
      }
    }, {
      key: "getTotalSize",
      value: function getTotalSize() {
        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
        var totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;
        var numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;
        var totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;
        return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;
      }
    }, {
      key: "getUpdatedOffsetForIndex",
      value: function getUpdatedOffsetForIndex2(_ref3) {
        var _ref3$align = _ref3.align, align = _ref3$align === void 0 ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
        if (containerSize <= 0) {
          return 0;
        }
        var datum = this.getSizeAndPositionOfCell(targetIndex);
        var maxOffset = datum.offset;
        var minOffset = maxOffset - containerSize + datum.size;
        var idealOffset;
        switch (align) {
          case "start":
            idealOffset = maxOffset;
            break;
          case "end":
            idealOffset = minOffset;
            break;
          case "center":
            idealOffset = maxOffset - (containerSize - datum.size) / 2;
            break;
          default:
            idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
            break;
        }
        var totalSize = this.getTotalSize();
        return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
      }
    }, {
      key: "getVisibleCellRange",
      value: function getVisibleCellRange(params) {
        var containerSize = params.containerSize, offset = params.offset;
        var totalSize = this.getTotalSize();
        if (totalSize === 0) {
          return {};
        }
        var maxOffset = offset + containerSize;
        var start = this._findNearestCell(offset);
        var datum = this.getSizeAndPositionOfCell(start);
        offset = datum.offset + datum.size;
        var stop = start;
        while (offset < maxOffset && stop < this._cellCount - 1) {
          stop++;
          offset += this.getSizeAndPositionOfCell(stop).size;
        }
        return {
          start,
          stop
        };
      }
    }, {
      key: "resetCell",
      value: function resetCell(index2) {
        this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index2 - 1);
      }
    }, {
      key: "_binarySearch",
      value: function _binarySearch(high, low, offset) {
        while (low <= high) {
          var middle = low + Math.floor((high - low) / 2);
          var currentOffset = this.getSizeAndPositionOfCell(middle).offset;
          if (currentOffset === offset) {
            return middle;
          } else if (currentOffset < offset) {
            low = middle + 1;
          } else if (currentOffset > offset) {
            high = middle - 1;
          }
        }
        if (low > 0) {
          return low - 1;
        } else {
          return 0;
        }
      }
    }, {
      key: "_exponentialSearch",
      value: function _exponentialSearch(index2, offset) {
        var interval = 1;
        while (index2 < this._cellCount && this.getSizeAndPositionOfCell(index2).offset < offset) {
          index2 += interval;
          interval *= 2;
        }
        return this._binarySearch(Math.min(index2, this._cellCount - 1), Math.floor(index2 / 2), offset);
      }
    }, {
      key: "_findNearestCell",
      value: function _findNearestCell(offset) {
        if (isNaN(offset)) {
          throw Error("Invalid offset ".concat(offset, " specified"));
        }
        offset = Math.max(0, offset);
        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
        var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);
        if (lastMeasuredCellSizeAndPosition.offset >= offset) {
          return this._binarySearch(lastMeasuredIndex, 0, offset);
        } else {
          return this._exponentialSearch(lastMeasuredIndex, offset);
        }
      }
    }]);
    return CellSizeAndPositionManager2;
  }();

  // node_modules/react-virtualized/dist/es/Grid/utils/maxElementSize.js
  var DEFAULT_MAX_ELEMENT_SIZE = 15e5;
  var CHROME_MAX_ELEMENT_SIZE = 16777100;
  var isBrowser = function isBrowser2() {
    return typeof window !== "undefined";
  };
  var isChrome = function isChrome2() {
    return !!window.chrome;
  };
  var getMaxElementSize = function getMaxElementSize2() {
    if (isBrowser()) {
      if (isChrome()) {
        return CHROME_MAX_ELEMENT_SIZE;
      }
    }
    return DEFAULT_MAX_ELEMENT_SIZE;
  };

  // node_modules/react-virtualized/dist/es/Grid/utils/ScalingCellSizeAndPositionManager.js
  var ScalingCellSizeAndPositionManager = /* @__PURE__ */ function() {
    function ScalingCellSizeAndPositionManager2(_ref) {
      var _ref$maxScrollSize = _ref.maxScrollSize, maxScrollSize = _ref$maxScrollSize === void 0 ? getMaxElementSize() : _ref$maxScrollSize, params = (0, import_objectWithoutProperties.default)(_ref, ["maxScrollSize"]);
      (0, import_classCallCheck2.default)(this, ScalingCellSizeAndPositionManager2);
      (0, import_defineProperty2.default)(this, "_cellSizeAndPositionManager", void 0);
      (0, import_defineProperty2.default)(this, "_maxScrollSize", void 0);
      this._cellSizeAndPositionManager = new CellSizeAndPositionManager(params);
      this._maxScrollSize = maxScrollSize;
    }
    (0, import_createClass2.default)(ScalingCellSizeAndPositionManager2, [{
      key: "areOffsetsAdjusted",
      value: function areOffsetsAdjusted() {
        return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;
      }
    }, {
      key: "configure",
      value: function configure(params) {
        this._cellSizeAndPositionManager.configure(params);
      }
    }, {
      key: "getCellCount",
      value: function getCellCount() {
        return this._cellSizeAndPositionManager.getCellCount();
      }
    }, {
      key: "getEstimatedCellSize",
      value: function getEstimatedCellSize() {
        return this._cellSizeAndPositionManager.getEstimatedCellSize();
      }
    }, {
      key: "getLastMeasuredIndex",
      value: function getLastMeasuredIndex() {
        return this._cellSizeAndPositionManager.getLastMeasuredIndex();
      }
    }, {
      key: "getOffsetAdjustment",
      value: function getOffsetAdjustment(_ref2) {
        var containerSize = _ref2.containerSize, offset = _ref2.offset;
        var totalSize = this._cellSizeAndPositionManager.getTotalSize();
        var safeTotalSize = this.getTotalSize();
        var offsetPercentage = this._getOffsetPercentage({
          containerSize,
          offset,
          totalSize: safeTotalSize
        });
        return Math.round(offsetPercentage * (safeTotalSize - totalSize));
      }
    }, {
      key: "getSizeAndPositionOfCell",
      value: function getSizeAndPositionOfCell(index2) {
        return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index2);
      }
    }, {
      key: "getSizeAndPositionOfLastMeasuredCell",
      value: function getSizeAndPositionOfLastMeasuredCell() {
        return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();
      }
    }, {
      key: "getTotalSize",
      value: function getTotalSize() {
        return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());
      }
    }, {
      key: "getUpdatedOffsetForIndex",
      value: function getUpdatedOffsetForIndex2(_ref3) {
        var _ref3$align = _ref3.align, align = _ref3$align === void 0 ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
        currentOffset = this._safeOffsetToOffset({
          containerSize,
          offset: currentOffset
        });
        var offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
          align,
          containerSize,
          currentOffset,
          targetIndex
        });
        return this._offsetToSafeOffset({
          containerSize,
          offset
        });
      }
    }, {
      key: "getVisibleCellRange",
      value: function getVisibleCellRange(_ref4) {
        var containerSize = _ref4.containerSize, offset = _ref4.offset;
        offset = this._safeOffsetToOffset({
          containerSize,
          offset
        });
        return this._cellSizeAndPositionManager.getVisibleCellRange({
          containerSize,
          offset
        });
      }
    }, {
      key: "resetCell",
      value: function resetCell(index2) {
        this._cellSizeAndPositionManager.resetCell(index2);
      }
    }, {
      key: "_getOffsetPercentage",
      value: function _getOffsetPercentage(_ref5) {
        var containerSize = _ref5.containerSize, offset = _ref5.offset, totalSize = _ref5.totalSize;
        return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);
      }
    }, {
      key: "_offsetToSafeOffset",
      value: function _offsetToSafeOffset(_ref6) {
        var containerSize = _ref6.containerSize, offset = _ref6.offset;
        var totalSize = this._cellSizeAndPositionManager.getTotalSize();
        var safeTotalSize = this.getTotalSize();
        if (totalSize === safeTotalSize) {
          return offset;
        } else {
          var offsetPercentage = this._getOffsetPercentage({
            containerSize,
            offset,
            totalSize
          });
          return Math.round(offsetPercentage * (safeTotalSize - containerSize));
        }
      }
    }, {
      key: "_safeOffsetToOffset",
      value: function _safeOffsetToOffset(_ref7) {
        var containerSize = _ref7.containerSize, offset = _ref7.offset;
        var totalSize = this._cellSizeAndPositionManager.getTotalSize();
        var safeTotalSize = this.getTotalSize();
        if (totalSize === safeTotalSize) {
          return offset;
        } else {
          var offsetPercentage = this._getOffsetPercentage({
            containerSize,
            offset,
            totalSize: safeTotalSize
          });
          return Math.round(offsetPercentage * (totalSize - containerSize));
        }
      }
    }]);
    return ScalingCellSizeAndPositionManager2;
  }();

  // node_modules/react-virtualized/dist/es/utils/createCallbackMemoizer.js
  function createCallbackMemoizer() {
    var requireAllKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    var cachedIndices = {};
    return function(_ref) {
      var callback = _ref.callback, indices = _ref.indices;
      var keys = Object.keys(indices);
      var allInitialized = !requireAllKeys || keys.every(function(key) {
        var value = indices[key];
        return Array.isArray(value) ? value.length > 0 : value >= 0;
      });
      var indexChanged = keys.length !== Object.keys(cachedIndices).length || keys.some(function(key) {
        var cachedValue = cachedIndices[key];
        var value = indices[key];
        return Array.isArray(value) ? cachedValue.join(",") !== value.join(",") : cachedValue !== value;
      });
      cachedIndices = indices;
      if (allInitialized && indexChanged) {
        callback(indices);
      }
    };
  }

  // node_modules/react-virtualized/dist/es/Grid/defaultOverscanIndicesGetter.js
  var SCROLL_DIRECTION_BACKWARD = -1;
  var SCROLL_DIRECTION_FORWARD = 1;
  function defaultOverscanIndicesGetter(_ref) {
    var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
    if (scrollDirection === SCROLL_DIRECTION_FORWARD) {
      return {
        overscanStartIndex: Math.max(0, startIndex),
        overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
      };
    } else {
      return {
        overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
        overscanStopIndex: Math.min(cellCount - 1, stopIndex)
      };
    }
  }

  // node_modules/react-virtualized/dist/es/Grid/utils/updateScrollIndexHelper.js
  function updateScrollIndexHelper(_ref) {
    var cellSize = _ref.cellSize, cellSizeAndPositionManager = _ref.cellSizeAndPositionManager, previousCellsCount = _ref.previousCellsCount, previousCellSize = _ref.previousCellSize, previousScrollToAlignment = _ref.previousScrollToAlignment, previousScrollToIndex = _ref.previousScrollToIndex, previousSize = _ref.previousSize, scrollOffset = _ref.scrollOffset, scrollToAlignment3 = _ref.scrollToAlignment, scrollToIndex = _ref.scrollToIndex, size2 = _ref.size, sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero, updateScrollIndexCallback = _ref.updateScrollIndexCallback;
    var cellCount = cellSizeAndPositionManager.getCellCount();
    var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;
    var sizeHasChanged = size2 !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === "number" && cellSize !== previousCellSize;
    if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment3 !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {
      updateScrollIndexCallback(scrollToIndex);
    } else if (!hasScrollToIndex && cellCount > 0 && (size2 < previousSize || cellCount < previousCellsCount)) {
      if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size2) {
        updateScrollIndexCallback(cellCount - 1);
      }
    }
  }

  // node_modules/react-virtualized/dist/es/Grid/defaultCellRangeRenderer.js
  function defaultCellRangeRenderer(_ref) {
    var cellCache = _ref.cellCache, cellRenderer3 = _ref.cellRenderer, columnSizeAndPositionManager2 = _ref.columnSizeAndPositionManager, columnStartIndex = _ref.columnStartIndex, columnStopIndex = _ref.columnStopIndex, deferredMeasurementCache = _ref.deferredMeasurementCache, horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment, isScrolling = _ref.isScrolling, isScrollingOptOut = _ref.isScrollingOptOut, parent = _ref.parent, rowSizeAndPositionManager2 = _ref.rowSizeAndPositionManager, rowStartIndex = _ref.rowStartIndex, rowStopIndex = _ref.rowStopIndex, styleCache = _ref.styleCache, verticalOffsetAdjustment = _ref.verticalOffsetAdjustment, visibleColumnIndices = _ref.visibleColumnIndices, visibleRowIndices = _ref.visibleRowIndices;
    var renderedCells = [];
    var areOffsetsAdjusted = columnSizeAndPositionManager2.areOffsetsAdjusted() || rowSizeAndPositionManager2.areOffsetsAdjusted();
    var canCacheStyle = !isScrolling && !areOffsetsAdjusted;
    for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {
      var rowDatum = rowSizeAndPositionManager2.getSizeAndPositionOfCell(rowIndex);
      for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
        var columnDatum = columnSizeAndPositionManager2.getSizeAndPositionOfCell(columnIndex);
        var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;
        var key = "".concat(rowIndex, "-").concat(columnIndex);
        var style4 = void 0;
        if (canCacheStyle && styleCache[key]) {
          style4 = styleCache[key];
        } else {
          if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {
            style4 = {
              height: "auto",
              left: 0,
              position: "absolute",
              top: 0,
              width: "auto"
            };
          } else {
            style4 = {
              height: rowDatum.size,
              left: columnDatum.offset + horizontalOffsetAdjustment,
              position: "absolute",
              top: rowDatum.offset + verticalOffsetAdjustment,
              width: columnDatum.size
            };
            styleCache[key] = style4;
          }
        }
        var cellRendererParams = {
          columnIndex,
          isScrolling,
          isVisible,
          key,
          parent,
          rowIndex,
          style: style4
        };
        var renderedCell = void 0;
        if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {
          if (!cellCache[key]) {
            cellCache[key] = cellRenderer3(cellRendererParams);
          }
          renderedCell = cellCache[key];
        } else {
          renderedCell = cellRenderer3(cellRendererParams);
        }
        if (renderedCell == null || renderedCell === false) {
          continue;
        }
        if (true) {
          warnAboutMissingStyle(parent, renderedCell);
        }
        renderedCells.push(renderedCell);
      }
    }
    return renderedCells;
  }
  function warnAboutMissingStyle(parent, renderedCell) {
    if (true) {
      if (renderedCell) {
        if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {
          renderedCell = renderedCell.props.children;
        }
        if (renderedCell && renderedCell.props && renderedCell.props.style === void 0 && parent.__warnedAboutMissingStyle !== true) {
          parent.__warnedAboutMissingStyle = true;
          console.warn("Rendered cell should include style property for positioning.");
        }
      }
    }
  }

  // node_modules/dom-helpers/esm/canUseDOM.js
  var canUseDOM_default = !!(typeof window !== "undefined" && window.document && window.document.createElement);

  // node_modules/dom-helpers/esm/scrollbarSize.js
  var size;
  function scrollbarSize(recalc) {
    if (!size && size !== 0 || recalc) {
      if (canUseDOM_default) {
        var scrollDiv = document.createElement("div");
        scrollDiv.style.position = "absolute";
        scrollDiv.style.top = "-9999px";
        scrollDiv.style.width = "50px";
        scrollDiv.style.height = "50px";
        scrollDiv.style.overflow = "scroll";
        document.body.appendChild(scrollDiv);
        size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
      }
    }
    return size;
  }

  // node_modules/react-virtualized/dist/es/utils/animationFrame.js
  var win;
  if (typeof window !== "undefined") {
    win = window;
  } else if (typeof self !== "undefined") {
    win = self;
  } else {
    win = {};
  }
  var request = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function(callback) {
    return win.setTimeout(callback, 1e3 / 60);
  };
  var cancel = win.cancelAnimationFrame || win.webkitCancelAnimationFrame || win.mozCancelAnimationFrame || win.oCancelAnimationFrame || win.msCancelAnimationFrame || function(id) {
    win.clearTimeout(id);
  };
  var raf = request;
  var caf = cancel;

  // node_modules/react-virtualized/dist/es/utils/requestAnimationTimeout.js
  var import_prop_types9 = __toESM(require_prop_types());
  var bpfrpt_proptype_AnimationTimeoutId = false ? null : {
    "id": import_prop_types9.default.number.isRequired
  };
  var cancelAnimationTimeout = function cancelAnimationTimeout2(frame) {
    return caf(frame.id);
  };
  var requestAnimationTimeout = function requestAnimationTimeout2(callback, delay) {
    var start;
    Promise.resolve().then(function() {
      start = Date.now();
    });
    var timeout2 = function timeout3() {
      if (Date.now() - start >= delay) {
        callback.call();
      } else {
        frame.id = raf(timeout3);
      }
    };
    var frame = {
      id: raf(timeout2)
    };
    return frame;
  };

  // node_modules/react-virtualized/dist/es/Grid/Grid.js
  var import_prop_types10 = __toESM(require_prop_types());
  var _class;
  var _temp;
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys2(source, true).forEach(function(key) {
          (0, import_defineProperty3.default)(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;
  var SCROLL_POSITION_CHANGE_REASONS = {
    OBSERVED: "observed",
    REQUESTED: "requested"
  };
  var renderNull = function renderNull2() {
    return null;
  };
  var Grid = (_temp = _class = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits.default)(Grid2, _React$PureComponent);
    function Grid2(props) {
      var _this;
      (0, import_classCallCheck3.default)(this, Grid2);
      _this = (0, import_possibleConstructorReturn.default)(this, (0, import_getPrototypeOf.default)(Grid2).call(this, props));
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_onGridRenderedMemoizer", createCallbackMemoizer());
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_onScrollMemoizer", createCallbackMemoizer(false));
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_deferredInvalidateColumnIndex", null);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_deferredInvalidateRowIndex", null);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_recomputeScrollLeftFlag", false);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_recomputeScrollTopFlag", false);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_horizontalScrollBarSize", 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_verticalScrollBarSize", 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_scrollbarPresenceChanged", false);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_scrollingContainer", void 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_childrenToDisplay", void 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_columnStartIndex", void 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_columnStopIndex", void 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_rowStartIndex", void 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_rowStopIndex", void 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_renderedColumnStartIndex", 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_renderedColumnStopIndex", 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_renderedRowStartIndex", 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_renderedRowStopIndex", 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_initialScrollTop", void 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_initialScrollLeft", void 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_disablePointerEventsTimeoutId", void 0);
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_styleCache", {});
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_cellCache", {});
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_debounceScrollEndedCallback", function() {
        _this._disablePointerEventsTimeoutId = null;
        _this.setState({
          isScrolling: false,
          needToResetStyleCache: false
        });
      });
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_invokeOnGridRenderedHelper", function() {
        var onSectionRendered3 = _this.props.onSectionRendered;
        _this._onGridRenderedMemoizer({
          callback: onSectionRendered3,
          indices: {
            columnOverscanStartIndex: _this._columnStartIndex,
            columnOverscanStopIndex: _this._columnStopIndex,
            columnStartIndex: _this._renderedColumnStartIndex,
            columnStopIndex: _this._renderedColumnStopIndex,
            rowOverscanStartIndex: _this._rowStartIndex,
            rowOverscanStopIndex: _this._rowStopIndex,
            rowStartIndex: _this._renderedRowStartIndex,
            rowStopIndex: _this._renderedRowStopIndex
          }
        });
      });
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_setScrollingContainerRef", function(ref) {
        _this._scrollingContainer = ref;
      });
      (0, import_defineProperty3.default)((0, import_assertThisInitialized2.default)(_this), "_onScroll", function(event) {
        if (event.target === _this._scrollingContainer) {
          _this.handleScrollEvent(event.target);
        }
      });
      var columnSizeAndPositionManager2 = new ScalingCellSizeAndPositionManager({
        cellCount: props.columnCount,
        cellSizeGetter: function cellSizeGetter(params) {
          return Grid2._wrapSizeGetter(props.columnWidth)(params);
        },
        estimatedCellSize: Grid2._getEstimatedColumnSize(props)
      });
      var rowSizeAndPositionManager2 = new ScalingCellSizeAndPositionManager({
        cellCount: props.rowCount,
        cellSizeGetter: function cellSizeGetter(params) {
          return Grid2._wrapSizeGetter(props.rowHeight)(params);
        },
        estimatedCellSize: Grid2._getEstimatedRowSize(props)
      });
      _this.state = {
        instanceProps: {
          columnSizeAndPositionManager: columnSizeAndPositionManager2,
          rowSizeAndPositionManager: rowSizeAndPositionManager2,
          prevColumnWidth: props.columnWidth,
          prevRowHeight: props.rowHeight,
          prevColumnCount: props.columnCount,
          prevRowCount: props.rowCount,
          prevIsScrolling: props.isScrolling === true,
          prevScrollToColumn: props.scrollToColumn,
          prevScrollToRow: props.scrollToRow,
          scrollbarSize: 0,
          scrollbarSizeMeasured: false
        },
        isScrolling: false,
        scrollDirectionHorizontal: SCROLL_DIRECTION_FORWARD,
        scrollDirectionVertical: SCROLL_DIRECTION_FORWARD,
        scrollLeft: 0,
        scrollTop: 0,
        scrollPositionChangeReason: null,
        needToResetStyleCache: false
      };
      if (props.scrollToRow > 0) {
        _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);
      }
      if (props.scrollToColumn > 0) {
        _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);
      }
      return _this;
    }
    (0, import_createClass3.default)(Grid2, [{
      key: "getOffsetForCell",
      value: function getOffsetForCell() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$alignment = _ref.alignment, alignment = _ref$alignment === void 0 ? this.props.scrollToAlignment : _ref$alignment, _ref$columnIndex = _ref.columnIndex, columnIndex = _ref$columnIndex === void 0 ? this.props.scrollToColumn : _ref$columnIndex, _ref$rowIndex = _ref.rowIndex, rowIndex = _ref$rowIndex === void 0 ? this.props.scrollToRow : _ref$rowIndex;
        var offsetProps = _objectSpread({}, this.props, {
          scrollToAlignment: alignment,
          scrollToColumn: columnIndex,
          scrollToRow: rowIndex
        });
        return {
          scrollLeft: this._getCalculatedScrollLeft(offsetProps),
          scrollTop: this._getCalculatedScrollTop(offsetProps)
        };
      }
    }, {
      key: "getTotalRowsHeight",
      value: function getTotalRowsHeight() {
        return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();
      }
    }, {
      key: "getTotalColumnsWidth",
      value: function getTotalColumnsWidth() {
        return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();
      }
    }, {
      key: "handleScrollEvent",
      value: function handleScrollEvent(_ref2) {
        var _ref2$scrollLeft = _ref2.scrollLeft, scrollLeftParam = _ref2$scrollLeft === void 0 ? 0 : _ref2$scrollLeft, _ref2$scrollTop = _ref2.scrollTop, scrollTopParam = _ref2$scrollTop === void 0 ? 0 : _ref2$scrollTop;
        if (scrollTopParam < 0) {
          return;
        }
        this._debounceScrollEnded();
        var _this$props = this.props, autoHeight = _this$props.autoHeight, autoWidth = _this$props.autoWidth, height = _this$props.height, width = _this$props.width;
        var instanceProps = this.state.instanceProps;
        var scrollbarSize2 = instanceProps.scrollbarSize;
        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
        var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize2), scrollLeftParam);
        var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize2), scrollTopParam);
        if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
          var scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;
          var scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;
          var newState = {
            isScrolling: true,
            scrollDirectionHorizontal,
            scrollDirectionVertical,
            scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED
          };
          if (!autoHeight) {
            newState.scrollTop = scrollTop;
          }
          if (!autoWidth) {
            newState.scrollLeft = scrollLeft;
          }
          newState.needToResetStyleCache = false;
          this.setState(newState);
        }
        this._invokeOnScrollMemoizer({
          scrollLeft,
          scrollTop,
          totalColumnsWidth,
          totalRowsHeight
        });
      }
    }, {
      key: "invalidateCellSizeAfterRender",
      value: function invalidateCellSizeAfterRender(_ref3) {
        var columnIndex = _ref3.columnIndex, rowIndex = _ref3.rowIndex;
        this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === "number" ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;
        this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === "number" ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
      }
    }, {
      key: "measureAllCells",
      value: function measureAllCells() {
        var _this$props2 = this.props, columnCount = _this$props2.columnCount, rowCount = _this$props2.rowCount;
        var instanceProps = this.state.instanceProps;
        instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);
        instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);
      }
    }, {
      key: "recomputeGridSize",
      value: function recomputeGridSize() {
        var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$columnIndex = _ref4.columnIndex, columnIndex = _ref4$columnIndex === void 0 ? 0 : _ref4$columnIndex, _ref4$rowIndex = _ref4.rowIndex, rowIndex = _ref4$rowIndex === void 0 ? 0 : _ref4$rowIndex;
        var _this$props3 = this.props, scrollToColumn = _this$props3.scrollToColumn, scrollToRow = _this$props3.scrollToRow;
        var instanceProps = this.state.instanceProps;
        instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);
        instanceProps.rowSizeAndPositionManager.resetCell(rowIndex);
        this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);
        this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow);
        this._styleCache = {};
        this._cellCache = {};
        this.forceUpdate();
      }
    }, {
      key: "scrollToCell",
      value: function scrollToCell(_ref5) {
        var columnIndex = _ref5.columnIndex, rowIndex = _ref5.rowIndex;
        var columnCount = this.props.columnCount;
        var props = this.props;
        if (columnCount > 1 && columnIndex !== void 0) {
          this._updateScrollLeftForScrollToColumn(_objectSpread({}, props, {
            scrollToColumn: columnIndex
          }));
        }
        if (rowIndex !== void 0) {
          this._updateScrollTopForScrollToRow(_objectSpread({}, props, {
            scrollToRow: rowIndex
          }));
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props4 = this.props, getScrollbarSize = _this$props4.getScrollbarSize, height = _this$props4.height, scrollLeft = _this$props4.scrollLeft, scrollToColumn = _this$props4.scrollToColumn, scrollTop = _this$props4.scrollTop, scrollToRow = _this$props4.scrollToRow, width = _this$props4.width;
        var instanceProps = this.state.instanceProps;
        this._initialScrollTop = 0;
        this._initialScrollLeft = 0;
        this._handleInvalidatedGridSize();
        if (!instanceProps.scrollbarSizeMeasured) {
          this.setState(function(prevState) {
            var stateUpdate2 = _objectSpread({}, prevState, {
              needToResetStyleCache: false
            });
            stateUpdate2.instanceProps.scrollbarSize = getScrollbarSize();
            stateUpdate2.instanceProps.scrollbarSizeMeasured = true;
            return stateUpdate2;
          });
        }
        if (typeof scrollLeft === "number" && scrollLeft >= 0 || typeof scrollTop === "number" && scrollTop >= 0) {
          var stateUpdate = Grid2._getScrollToPositionStateUpdate({
            prevState: this.state,
            scrollLeft,
            scrollTop
          });
          if (stateUpdate) {
            stateUpdate.needToResetStyleCache = false;
            this.setState(stateUpdate);
          }
        }
        if (this._scrollingContainer) {
          if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {
            this._scrollingContainer.scrollLeft = this.state.scrollLeft;
          }
          if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {
            this._scrollingContainer.scrollTop = this.state.scrollTop;
          }
        }
        var sizeIsBiggerThanZero = height > 0 && width > 0;
        if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {
          this._updateScrollLeftForScrollToColumn();
        }
        if (scrollToRow >= 0 && sizeIsBiggerThanZero) {
          this._updateScrollTopForScrollToRow();
        }
        this._invokeOnGridRenderedHelper();
        this._invokeOnScrollMemoizer({
          scrollLeft: scrollLeft || 0,
          scrollTop: scrollTop || 0,
          totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),
          totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()
        });
        this._maybeCallOnScrollbarPresenceChange();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        var _this2 = this;
        var _this$props5 = this.props, autoHeight = _this$props5.autoHeight, autoWidth = _this$props5.autoWidth, columnCount = _this$props5.columnCount, height = _this$props5.height, rowCount = _this$props5.rowCount, scrollToAlignment3 = _this$props5.scrollToAlignment, scrollToColumn = _this$props5.scrollToColumn, scrollToRow = _this$props5.scrollToRow, width = _this$props5.width;
        var _this$state = this.state, scrollLeft = _this$state.scrollLeft, scrollPositionChangeReason = _this$state.scrollPositionChangeReason, scrollTop = _this$state.scrollTop, instanceProps = _this$state.instanceProps;
        this._handleInvalidatedGridSize();
        var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0;
        if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {
          if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {
            this._scrollingContainer.scrollLeft = scrollLeft;
          }
          if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {
            this._scrollingContainer.scrollTop = scrollTop;
          }
        }
        var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0;
        if (this._recomputeScrollLeftFlag) {
          this._recomputeScrollLeftFlag = false;
          this._updateScrollLeftForScrollToColumn(this.props);
        } else {
          updateScrollIndexHelper({
            cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,
            previousCellsCount: prevProps.columnCount,
            previousCellSize: prevProps.columnWidth,
            previousScrollToAlignment: prevProps.scrollToAlignment,
            previousScrollToIndex: prevProps.scrollToColumn,
            previousSize: prevProps.width,
            scrollOffset: scrollLeft,
            scrollToAlignment: scrollToAlignment3,
            scrollToIndex: scrollToColumn,
            size: width,
            sizeJustIncreasedFromZero,
            updateScrollIndexCallback: function updateScrollIndexCallback() {
              return _this2._updateScrollLeftForScrollToColumn(_this2.props);
            }
          });
        }
        if (this._recomputeScrollTopFlag) {
          this._recomputeScrollTopFlag = false;
          this._updateScrollTopForScrollToRow(this.props);
        } else {
          updateScrollIndexHelper({
            cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,
            previousCellsCount: prevProps.rowCount,
            previousCellSize: prevProps.rowHeight,
            previousScrollToAlignment: prevProps.scrollToAlignment,
            previousScrollToIndex: prevProps.scrollToRow,
            previousSize: prevProps.height,
            scrollOffset: scrollTop,
            scrollToAlignment: scrollToAlignment3,
            scrollToIndex: scrollToRow,
            size: height,
            sizeJustIncreasedFromZero,
            updateScrollIndexCallback: function updateScrollIndexCallback() {
              return _this2._updateScrollTopForScrollToRow(_this2.props);
            }
          });
        }
        this._invokeOnGridRenderedHelper();
        if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {
          var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
          var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
          this._invokeOnScrollMemoizer({
            scrollLeft,
            scrollTop,
            totalColumnsWidth,
            totalRowsHeight
          });
        }
        this._maybeCallOnScrollbarPresenceChange();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._disablePointerEventsTimeoutId) {
          cancelAnimationTimeout(this._disablePointerEventsTimeoutId);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props6 = this.props, autoContainerWidth = _this$props6.autoContainerWidth, autoHeight = _this$props6.autoHeight, autoWidth = _this$props6.autoWidth, className = _this$props6.className, containerProps = _this$props6.containerProps, containerRole = _this$props6.containerRole, containerStyle = _this$props6.containerStyle, height = _this$props6.height, id = _this$props6.id, noContentRenderer3 = _this$props6.noContentRenderer, role = _this$props6.role, style4 = _this$props6.style, tabIndex = _this$props6.tabIndex, width = _this$props6.width;
        var _this$state2 = this.state, instanceProps = _this$state2.instanceProps, needToResetStyleCache = _this$state2.needToResetStyleCache;
        var isScrolling = this._isScrolling();
        var gridStyle = {
          boxSizing: "border-box",
          direction: "ltr",
          height: autoHeight ? "auto" : height,
          position: "relative",
          width: autoWidth ? "auto" : width,
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        };
        if (needToResetStyleCache) {
          this._styleCache = {};
        }
        if (!this.state.isScrolling) {
          this._resetStyleCache();
        }
        this._calculateChildrenToRender(this.props, this.state);
        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
        var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;
        var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;
        if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {
          this._horizontalScrollBarSize = horizontalScrollBarSize;
          this._verticalScrollBarSize = verticalScrollBarSize;
          this._scrollbarPresenceChanged = true;
        }
        gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? "hidden" : "auto";
        gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? "hidden" : "auto";
        var childrenToDisplay = this._childrenToDisplay;
        var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;
        return React79.createElement("div", (0, import_extends6.default)({
          ref: this._setScrollingContainerRef
        }, containerProps, {
          "aria-label": this.props["aria-label"],
          "aria-readonly": this.props["aria-readonly"],
          className: clsx_m_default("ReactVirtualized__Grid", className),
          id,
          onScroll: this._onScroll,
          role,
          style: _objectSpread({}, gridStyle, {}, style4),
          tabIndex
        }), childrenToDisplay.length > 0 && React79.createElement("div", {
          className: "ReactVirtualized__Grid__innerScrollContainer",
          role: containerRole,
          style: _objectSpread({
            width: autoContainerWidth ? "auto" : totalColumnsWidth,
            height: totalRowsHeight,
            maxWidth: totalColumnsWidth,
            maxHeight: totalRowsHeight,
            overflow: "hidden",
            pointerEvents: isScrolling ? "none" : "",
            position: "relative"
          }, containerStyle)
        }, childrenToDisplay), showNoContentRenderer && noContentRenderer3());
      }
    }, {
      key: "_calculateChildrenToRender",
      value: function _calculateChildrenToRender() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
        var cellRenderer3 = props.cellRenderer, cellRangeRenderer2 = props.cellRangeRenderer, columnCount = props.columnCount, deferredMeasurementCache = props.deferredMeasurementCache, height = props.height, overscanColumnCount = props.overscanColumnCount, overscanIndicesGetter3 = props.overscanIndicesGetter, overscanRowCount = props.overscanRowCount, rowCount = props.rowCount, width = props.width, isScrollingOptOut = props.isScrollingOptOut;
        var scrollDirectionHorizontal = state.scrollDirectionHorizontal, scrollDirectionVertical = state.scrollDirectionVertical, instanceProps = state.instanceProps;
        var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;
        var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;
        var isScrolling = this._isScrolling(props, state);
        this._childrenToDisplay = [];
        if (height > 0 && width > 0) {
          var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({
            containerSize: width,
            offset: scrollLeft
          });
          var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({
            containerSize: height,
            offset: scrollTop
          });
          var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({
            containerSize: width,
            offset: scrollLeft
          });
          var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({
            containerSize: height,
            offset: scrollTop
          });
          this._renderedColumnStartIndex = visibleColumnIndices.start;
          this._renderedColumnStopIndex = visibleColumnIndices.stop;
          this._renderedRowStartIndex = visibleRowIndices.start;
          this._renderedRowStopIndex = visibleRowIndices.stop;
          var overscanColumnIndices = overscanIndicesGetter3({
            direction: "horizontal",
            cellCount: columnCount,
            overscanCellsCount: overscanColumnCount,
            scrollDirection: scrollDirectionHorizontal,
            startIndex: typeof visibleColumnIndices.start === "number" ? visibleColumnIndices.start : 0,
            stopIndex: typeof visibleColumnIndices.stop === "number" ? visibleColumnIndices.stop : -1
          });
          var overscanRowIndices = overscanIndicesGetter3({
            direction: "vertical",
            cellCount: rowCount,
            overscanCellsCount: overscanRowCount,
            scrollDirection: scrollDirectionVertical,
            startIndex: typeof visibleRowIndices.start === "number" ? visibleRowIndices.start : 0,
            stopIndex: typeof visibleRowIndices.stop === "number" ? visibleRowIndices.stop : -1
          });
          var columnStartIndex = overscanColumnIndices.overscanStartIndex;
          var columnStopIndex = overscanColumnIndices.overscanStopIndex;
          var rowStartIndex = overscanRowIndices.overscanStartIndex;
          var rowStopIndex = overscanRowIndices.overscanStopIndex;
          if (deferredMeasurementCache) {
            if (!deferredMeasurementCache.hasFixedHeight()) {
              for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {
                if (!deferredMeasurementCache.has(rowIndex, 0)) {
                  columnStartIndex = 0;
                  columnStopIndex = columnCount - 1;
                  break;
                }
              }
            }
            if (!deferredMeasurementCache.hasFixedWidth()) {
              for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
                if (!deferredMeasurementCache.has(0, columnIndex)) {
                  rowStartIndex = 0;
                  rowStopIndex = rowCount - 1;
                  break;
                }
              }
            }
          }
          this._childrenToDisplay = cellRangeRenderer2({
            cellCache: this._cellCache,
            cellRenderer: cellRenderer3,
            columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,
            columnStartIndex,
            columnStopIndex,
            deferredMeasurementCache,
            horizontalOffsetAdjustment,
            isScrolling,
            isScrollingOptOut,
            parent: this,
            rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,
            rowStartIndex,
            rowStopIndex,
            scrollLeft,
            scrollTop,
            styleCache: this._styleCache,
            verticalOffsetAdjustment,
            visibleColumnIndices,
            visibleRowIndices
          });
          this._columnStartIndex = columnStartIndex;
          this._columnStopIndex = columnStopIndex;
          this._rowStartIndex = rowStartIndex;
          this._rowStopIndex = rowStopIndex;
        }
      }
    }, {
      key: "_debounceScrollEnded",
      value: function _debounceScrollEnded() {
        var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;
        if (this._disablePointerEventsTimeoutId) {
          cancelAnimationTimeout(this._disablePointerEventsTimeoutId);
        }
        this._disablePointerEventsTimeoutId = requestAnimationTimeout(this._debounceScrollEndedCallback, scrollingResetTimeInterval);
      }
    }, {
      key: "_handleInvalidatedGridSize",
      value: function _handleInvalidatedGridSize() {
        if (typeof this._deferredInvalidateColumnIndex === "number" && typeof this._deferredInvalidateRowIndex === "number") {
          var columnIndex = this._deferredInvalidateColumnIndex;
          var rowIndex = this._deferredInvalidateRowIndex;
          this._deferredInvalidateColumnIndex = null;
          this._deferredInvalidateRowIndex = null;
          this.recomputeGridSize({
            columnIndex,
            rowIndex
          });
        }
      }
    }, {
      key: "_invokeOnScrollMemoizer",
      value: function _invokeOnScrollMemoizer(_ref6) {
        var _this3 = this;
        var scrollLeft = _ref6.scrollLeft, scrollTop = _ref6.scrollTop, totalColumnsWidth = _ref6.totalColumnsWidth, totalRowsHeight = _ref6.totalRowsHeight;
        this._onScrollMemoizer({
          callback: function callback(_ref7) {
            var scrollLeft2 = _ref7.scrollLeft, scrollTop2 = _ref7.scrollTop;
            var _this3$props = _this3.props, height = _this3$props.height, onScroll7 = _this3$props.onScroll, width = _this3$props.width;
            onScroll7({
              clientHeight: height,
              clientWidth: width,
              scrollHeight: totalRowsHeight,
              scrollLeft: scrollLeft2,
              scrollTop: scrollTop2,
              scrollWidth: totalColumnsWidth
            });
          },
          indices: {
            scrollLeft,
            scrollTop
          }
        });
      }
    }, {
      key: "_isScrolling",
      value: function _isScrolling() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
        return Object.hasOwnProperty.call(props, "isScrolling") ? Boolean(props.isScrolling) : Boolean(state.isScrolling);
      }
    }, {
      key: "_maybeCallOnScrollbarPresenceChange",
      value: function _maybeCallOnScrollbarPresenceChange() {
        if (this._scrollbarPresenceChanged) {
          var onScrollbarPresenceChange2 = this.props.onScrollbarPresenceChange;
          this._scrollbarPresenceChanged = false;
          onScrollbarPresenceChange2({
            horizontal: this._horizontalScrollBarSize > 0,
            size: this.state.instanceProps.scrollbarSize,
            vertical: this._verticalScrollBarSize > 0
          });
        }
      }
    }, {
      key: "scrollToPosition",
      value: function scrollToPosition(_ref8) {
        var scrollLeft = _ref8.scrollLeft, scrollTop = _ref8.scrollTop;
        var stateUpdate = Grid2._getScrollToPositionStateUpdate({
          prevState: this.state,
          scrollLeft,
          scrollTop
        });
        if (stateUpdate) {
          stateUpdate.needToResetStyleCache = false;
          this.setState(stateUpdate);
        }
      }
    }, {
      key: "_getCalculatedScrollLeft",
      value: function _getCalculatedScrollLeft() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
        return Grid2._getCalculatedScrollLeft(props, state);
      }
    }, {
      key: "_updateScrollLeftForScrollToColumn",
      value: function _updateScrollLeftForScrollToColumn() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
        var stateUpdate = Grid2._getScrollLeftForScrollToColumnStateUpdate(props, state);
        if (stateUpdate) {
          stateUpdate.needToResetStyleCache = false;
          this.setState(stateUpdate);
        }
      }
    }, {
      key: "_getCalculatedScrollTop",
      value: function _getCalculatedScrollTop() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
        return Grid2._getCalculatedScrollTop(props, state);
      }
    }, {
      key: "_resetStyleCache",
      value: function _resetStyleCache() {
        var styleCache = this._styleCache;
        var cellCache = this._cellCache;
        var isScrollingOptOut = this.props.isScrollingOptOut;
        this._cellCache = {};
        this._styleCache = {};
        for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {
          for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {
            var key = "".concat(rowIndex, "-").concat(columnIndex);
            this._styleCache[key] = styleCache[key];
            if (isScrollingOptOut) {
              this._cellCache[key] = cellCache[key];
            }
          }
        }
      }
    }, {
      key: "_updateScrollTopForScrollToRow",
      value: function _updateScrollTopForScrollToRow() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
        var stateUpdate = Grid2._getScrollTopForScrollToRowStateUpdate(props, state);
        if (stateUpdate) {
          stateUpdate.needToResetStyleCache = false;
          this.setState(stateUpdate);
        }
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, prevState) {
        var newState = {};
        if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {
          newState.scrollLeft = 0;
          newState.scrollTop = 0;
        } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {
          Object.assign(newState, Grid2._getScrollToPositionStateUpdate({
            prevState,
            scrollLeft: nextProps.scrollLeft,
            scrollTop: nextProps.scrollTop
          }));
        }
        var instanceProps = prevState.instanceProps;
        newState.needToResetStyleCache = false;
        if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {
          newState.needToResetStyleCache = true;
        }
        instanceProps.columnSizeAndPositionManager.configure({
          cellCount: nextProps.columnCount,
          estimatedCellSize: Grid2._getEstimatedColumnSize(nextProps),
          cellSizeGetter: Grid2._wrapSizeGetter(nextProps.columnWidth)
        });
        instanceProps.rowSizeAndPositionManager.configure({
          cellCount: nextProps.rowCount,
          estimatedCellSize: Grid2._getEstimatedRowSize(nextProps),
          cellSizeGetter: Grid2._wrapSizeGetter(nextProps.rowHeight)
        });
        if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {
          instanceProps.prevColumnCount = 0;
          instanceProps.prevRowCount = 0;
        }
        if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {
          Object.assign(newState, {
            isScrolling: false
          });
        }
        var maybeStateA;
        var maybeStateB;
        calculateSizeAndPositionDataAndUpdateScrollOffset({
          cellCount: instanceProps.prevColumnCount,
          cellSize: typeof instanceProps.prevColumnWidth === "number" ? instanceProps.prevColumnWidth : null,
          computeMetadataCallback: function computeMetadataCallback() {
            return instanceProps.columnSizeAndPositionManager.resetCell(0);
          },
          computeMetadataCallbackProps: nextProps,
          nextCellsCount: nextProps.columnCount,
          nextCellSize: typeof nextProps.columnWidth === "number" ? nextProps.columnWidth : null,
          nextScrollToIndex: nextProps.scrollToColumn,
          scrollToIndex: instanceProps.prevScrollToColumn,
          updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {
            maybeStateA = Grid2._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);
          }
        });
        calculateSizeAndPositionDataAndUpdateScrollOffset({
          cellCount: instanceProps.prevRowCount,
          cellSize: typeof instanceProps.prevRowHeight === "number" ? instanceProps.prevRowHeight : null,
          computeMetadataCallback: function computeMetadataCallback() {
            return instanceProps.rowSizeAndPositionManager.resetCell(0);
          },
          computeMetadataCallbackProps: nextProps,
          nextCellsCount: nextProps.rowCount,
          nextCellSize: typeof nextProps.rowHeight === "number" ? nextProps.rowHeight : null,
          nextScrollToIndex: nextProps.scrollToRow,
          scrollToIndex: instanceProps.prevScrollToRow,
          updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {
            maybeStateB = Grid2._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);
          }
        });
        instanceProps.prevColumnCount = nextProps.columnCount;
        instanceProps.prevColumnWidth = nextProps.columnWidth;
        instanceProps.prevIsScrolling = nextProps.isScrolling === true;
        instanceProps.prevRowCount = nextProps.rowCount;
        instanceProps.prevRowHeight = nextProps.rowHeight;
        instanceProps.prevScrollToColumn = nextProps.scrollToColumn;
        instanceProps.prevScrollToRow = nextProps.scrollToRow;
        instanceProps.scrollbarSize = nextProps.getScrollbarSize();
        if (instanceProps.scrollbarSize === void 0) {
          instanceProps.scrollbarSizeMeasured = false;
          instanceProps.scrollbarSize = 0;
        } else {
          instanceProps.scrollbarSizeMeasured = true;
        }
        newState.instanceProps = instanceProps;
        return _objectSpread({}, newState, {}, maybeStateA, {}, maybeStateB);
      }
    }, {
      key: "_getEstimatedColumnSize",
      value: function _getEstimatedColumnSize(props) {
        return typeof props.columnWidth === "number" ? props.columnWidth : props.estimatedColumnSize;
      }
    }, {
      key: "_getEstimatedRowSize",
      value: function _getEstimatedRowSize(props) {
        return typeof props.rowHeight === "number" ? props.rowHeight : props.estimatedRowSize;
      }
    }, {
      key: "_getScrollToPositionStateUpdate",
      value: function _getScrollToPositionStateUpdate(_ref9) {
        var prevState = _ref9.prevState, scrollLeft = _ref9.scrollLeft, scrollTop = _ref9.scrollTop;
        var newState = {
          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
        };
        if (typeof scrollLeft === "number" && scrollLeft >= 0) {
          newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;
          newState.scrollLeft = scrollLeft;
        }
        if (typeof scrollTop === "number" && scrollTop >= 0) {
          newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;
          newState.scrollTop = scrollTop;
        }
        if (typeof scrollLeft === "number" && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === "number" && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {
          return newState;
        }
        return {};
      }
    }, {
      key: "_wrapSizeGetter",
      value: function _wrapSizeGetter(value) {
        return typeof value === "function" ? value : function() {
          return value;
        };
      }
    }, {
      key: "_getCalculatedScrollLeft",
      value: function _getCalculatedScrollLeft(nextProps, prevState) {
        var columnCount = nextProps.columnCount, height = nextProps.height, scrollToAlignment3 = nextProps.scrollToAlignment, scrollToColumn = nextProps.scrollToColumn, width = nextProps.width;
        var scrollLeft = prevState.scrollLeft, instanceProps = prevState.instanceProps;
        if (columnCount > 0) {
          var finalColumn = columnCount - 1;
          var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);
          var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
          var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;
          return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({
            align: scrollToAlignment3,
            containerSize: width - scrollBarSize,
            currentOffset: scrollLeft,
            targetIndex
          });
        }
        return 0;
      }
    }, {
      key: "_getScrollLeftForScrollToColumnStateUpdate",
      value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {
        var scrollLeft = prevState.scrollLeft;
        var calculatedScrollLeft = Grid2._getCalculatedScrollLeft(nextProps, prevState);
        if (typeof calculatedScrollLeft === "number" && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {
          return Grid2._getScrollToPositionStateUpdate({
            prevState,
            scrollLeft: calculatedScrollLeft,
            scrollTop: -1
          });
        }
        return {};
      }
    }, {
      key: "_getCalculatedScrollTop",
      value: function _getCalculatedScrollTop(nextProps, prevState) {
        var height = nextProps.height, rowCount = nextProps.rowCount, scrollToAlignment3 = nextProps.scrollToAlignment, scrollToRow = nextProps.scrollToRow, width = nextProps.width;
        var scrollTop = prevState.scrollTop, instanceProps = prevState.instanceProps;
        if (rowCount > 0) {
          var finalRow = rowCount - 1;
          var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);
          var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
          var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;
          return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({
            align: scrollToAlignment3,
            containerSize: height - scrollBarSize,
            currentOffset: scrollTop,
            targetIndex
          });
        }
        return 0;
      }
    }, {
      key: "_getScrollTopForScrollToRowStateUpdate",
      value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {
        var scrollTop = prevState.scrollTop;
        var calculatedScrollTop = Grid2._getCalculatedScrollTop(nextProps, prevState);
        if (typeof calculatedScrollTop === "number" && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {
          return Grid2._getScrollToPositionStateUpdate({
            prevState,
            scrollLeft: -1,
            scrollTop: calculatedScrollTop
          });
        }
        return {};
      }
    }]);
    return Grid2;
  }(React79.PureComponent), (0, import_defineProperty3.default)(_class, "propTypes", false ? null : {
    "aria-label": import_prop_types10.default.string.isRequired,
    "aria-readonly": import_prop_types10.default.bool,
    "autoContainerWidth": import_prop_types10.default.bool.isRequired,
    "autoHeight": import_prop_types10.default.bool.isRequired,
    "autoWidth": import_prop_types10.default.bool.isRequired,
    "cellRenderer": function cellRenderer() {
      return (typeof bpfrpt_proptype_CellRenderer === "function" ? bpfrpt_proptype_CellRenderer.isRequired ? bpfrpt_proptype_CellRenderer.isRequired : bpfrpt_proptype_CellRenderer : import_prop_types10.default.shape(bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);
    },
    "cellRangeRenderer": function cellRangeRenderer() {
      return (typeof bpfrpt_proptype_CellRangeRenderer === "function" ? bpfrpt_proptype_CellRangeRenderer.isRequired ? bpfrpt_proptype_CellRangeRenderer.isRequired : bpfrpt_proptype_CellRangeRenderer : import_prop_types10.default.shape(bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);
    },
    "className": import_prop_types10.default.string,
    "columnCount": import_prop_types10.default.number.isRequired,
    "columnWidth": function columnWidth() {
      return (typeof bpfrpt_proptype_CellSize === "function" ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : import_prop_types10.default.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
    },
    "containerProps": import_prop_types10.default.object,
    "containerRole": import_prop_types10.default.string.isRequired,
    "containerStyle": import_prop_types10.default.object.isRequired,
    "deferredMeasurementCache": import_prop_types10.default.object,
    "estimatedColumnSize": import_prop_types10.default.number.isRequired,
    "estimatedRowSize": import_prop_types10.default.number.isRequired,
    "getScrollbarSize": import_prop_types10.default.func.isRequired,
    "height": import_prop_types10.default.number.isRequired,
    "id": import_prop_types10.default.string,
    "isScrolling": import_prop_types10.default.bool,
    "isScrollingOptOut": import_prop_types10.default.bool.isRequired,
    "noContentRenderer": function noContentRenderer() {
      return (typeof bpfrpt_proptype_NoContentRenderer === "function" ? bpfrpt_proptype_NoContentRenderer.isRequired ? bpfrpt_proptype_NoContentRenderer.isRequired : bpfrpt_proptype_NoContentRenderer : import_prop_types10.default.shape(bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);
    },
    "onScroll": import_prop_types10.default.func.isRequired,
    "onScrollbarPresenceChange": import_prop_types10.default.func.isRequired,
    "onSectionRendered": import_prop_types10.default.func.isRequired,
    "overscanColumnCount": import_prop_types10.default.number.isRequired,
    "overscanIndicesGetter": function overscanIndicesGetter() {
      return (typeof bpfrpt_proptype_OverscanIndicesGetter === "function" ? bpfrpt_proptype_OverscanIndicesGetter.isRequired ? bpfrpt_proptype_OverscanIndicesGetter.isRequired : bpfrpt_proptype_OverscanIndicesGetter : import_prop_types10.default.shape(bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);
    },
    "overscanRowCount": import_prop_types10.default.number.isRequired,
    "role": import_prop_types10.default.string.isRequired,
    "rowHeight": function rowHeight() {
      return (typeof bpfrpt_proptype_CellSize === "function" ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : import_prop_types10.default.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
    },
    "rowCount": import_prop_types10.default.number.isRequired,
    "scrollingResetTimeInterval": import_prop_types10.default.number.isRequired,
    "scrollLeft": import_prop_types10.default.number,
    "scrollToAlignment": function scrollToAlignment() {
      return (typeof bpfrpt_proptype_Alignment === "function" ? bpfrpt_proptype_Alignment.isRequired ? bpfrpt_proptype_Alignment.isRequired : bpfrpt_proptype_Alignment : import_prop_types10.default.shape(bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);
    },
    "scrollToColumn": import_prop_types10.default.number.isRequired,
    "scrollTop": import_prop_types10.default.number,
    "scrollToRow": import_prop_types10.default.number.isRequired,
    "style": import_prop_types10.default.object.isRequired,
    "tabIndex": import_prop_types10.default.number,
    "width": import_prop_types10.default.number.isRequired
  }), _temp);
  (0, import_defineProperty3.default)(Grid, "defaultProps", {
    "aria-label": "grid",
    "aria-readonly": true,
    autoContainerWidth: false,
    autoHeight: false,
    autoWidth: false,
    cellRangeRenderer: defaultCellRangeRenderer,
    containerRole: "rowgroup",
    containerStyle: {},
    estimatedColumnSize: 100,
    estimatedRowSize: 30,
    getScrollbarSize: scrollbarSize,
    noContentRenderer: renderNull,
    onScroll: function onScroll() {
    },
    onScrollbarPresenceChange: function onScrollbarPresenceChange() {
    },
    onSectionRendered: function onSectionRendered() {
    },
    overscanColumnCount: 0,
    overscanIndicesGetter: defaultOverscanIndicesGetter,
    overscanRowCount: 10,
    role: "grid",
    scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
    scrollToAlignment: "auto",
    scrollToColumn: -1,
    scrollToRow: -1,
    style: {},
    tabIndex: 0,
    isScrollingOptOut: false
  });
  polyfill(Grid);
  var Grid_default = Grid;

  // node_modules/react-virtualized/dist/es/Grid/accessibilityOverscanIndicesGetter.js
  var SCROLL_DIRECTION_FORWARD2 = 1;
  function defaultOverscanIndicesGetter2(_ref) {
    var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
    overscanCellsCount = Math.max(1, overscanCellsCount);
    if (scrollDirection === SCROLL_DIRECTION_FORWARD2) {
      return {
        overscanStartIndex: Math.max(0, startIndex - 1),
        overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
      };
    } else {
      return {
        overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
        overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)
      };
    }
  }

  // node_modules/react-virtualized/dist/es/ArrowKeyStepper/types.js
  var import_prop_types11 = __toESM(require_prop_types());
  var bpfrpt_proptype_ScrollIndices = false ? null : {
    "scrollToColumn": import_prop_types11.default.number.isRequired,
    "scrollToRow": import_prop_types11.default.number.isRequired
  };

  // node_modules/react-virtualized/dist/es/ArrowKeyStepper/ArrowKeyStepper.js
  var import_prop_types12 = __toESM(require_prop_types());
  var _class2;
  var _temp2;
  function ownKeys3(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread3(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys3(source, true).forEach(function(key) {
          (0, import_defineProperty4.default)(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys3(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var ArrowKeyStepper = (_temp2 = _class2 = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits2.default)(ArrowKeyStepper2, _React$PureComponent);
    function ArrowKeyStepper2() {
      var _getPrototypeOf22;
      var _this;
      (0, import_classCallCheck4.default)(this, ArrowKeyStepper2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = (0, import_possibleConstructorReturn2.default)(this, (_getPrototypeOf22 = (0, import_getPrototypeOf2.default)(ArrowKeyStepper2)).call.apply(_getPrototypeOf22, [this].concat(args)));
      (0, import_defineProperty4.default)((0, import_assertThisInitialized3.default)(_this), "state", {
        scrollToColumn: 0,
        scrollToRow: 0,
        instanceProps: {
          prevScrollToColumn: 0,
          prevScrollToRow: 0
        }
      });
      (0, import_defineProperty4.default)((0, import_assertThisInitialized3.default)(_this), "_columnStartIndex", 0);
      (0, import_defineProperty4.default)((0, import_assertThisInitialized3.default)(_this), "_columnStopIndex", 0);
      (0, import_defineProperty4.default)((0, import_assertThisInitialized3.default)(_this), "_rowStartIndex", 0);
      (0, import_defineProperty4.default)((0, import_assertThisInitialized3.default)(_this), "_rowStopIndex", 0);
      (0, import_defineProperty4.default)((0, import_assertThisInitialized3.default)(_this), "_onKeyDown", function(event) {
        var _this$props = _this.props, columnCount = _this$props.columnCount, disabled = _this$props.disabled, mode = _this$props.mode, rowCount = _this$props.rowCount;
        if (disabled) {
          return;
        }
        var _this$_getScrollState = _this._getScrollState(), scrollToColumnPrevious = _this$_getScrollState.scrollToColumn, scrollToRowPrevious = _this$_getScrollState.scrollToRow;
        var _this$_getScrollState2 = _this._getScrollState(), scrollToColumn = _this$_getScrollState2.scrollToColumn, scrollToRow = _this$_getScrollState2.scrollToRow;
        switch (event.key) {
          case "ArrowDown":
            scrollToRow = mode === "cells" ? Math.min(scrollToRow + 1, rowCount - 1) : Math.min(_this._rowStopIndex + 1, rowCount - 1);
            break;
          case "ArrowLeft":
            scrollToColumn = mode === "cells" ? Math.max(scrollToColumn - 1, 0) : Math.max(_this._columnStartIndex - 1, 0);
            break;
          case "ArrowRight":
            scrollToColumn = mode === "cells" ? Math.min(scrollToColumn + 1, columnCount - 1) : Math.min(_this._columnStopIndex + 1, columnCount - 1);
            break;
          case "ArrowUp":
            scrollToRow = mode === "cells" ? Math.max(scrollToRow - 1, 0) : Math.max(_this._rowStartIndex - 1, 0);
            break;
        }
        if (scrollToColumn !== scrollToColumnPrevious || scrollToRow !== scrollToRowPrevious) {
          event.preventDefault();
          _this._updateScrollState({
            scrollToColumn,
            scrollToRow
          });
        }
      });
      (0, import_defineProperty4.default)((0, import_assertThisInitialized3.default)(_this), "_onSectionRendered", function(_ref) {
        var columnStartIndex = _ref.columnStartIndex, columnStopIndex = _ref.columnStopIndex, rowStartIndex = _ref.rowStartIndex, rowStopIndex = _ref.rowStopIndex;
        _this._columnStartIndex = columnStartIndex;
        _this._columnStopIndex = columnStopIndex;
        _this._rowStartIndex = rowStartIndex;
        _this._rowStopIndex = rowStopIndex;
      });
      return _this;
    }
    (0, import_createClass4.default)(ArrowKeyStepper2, [{
      key: "setScrollIndexes",
      value: function setScrollIndexes(_ref2) {
        var scrollToColumn = _ref2.scrollToColumn, scrollToRow = _ref2.scrollToRow;
        this.setState({
          scrollToRow,
          scrollToColumn
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props, className = _this$props2.className, children2 = _this$props2.children;
        var _this$_getScrollState3 = this._getScrollState(), scrollToColumn = _this$_getScrollState3.scrollToColumn, scrollToRow = _this$_getScrollState3.scrollToRow;
        return React80.createElement("div", {
          className,
          onKeyDown: this._onKeyDown
        }, children2({
          onSectionRendered: this._onSectionRendered,
          scrollToColumn,
          scrollToRow
        }));
      }
    }, {
      key: "_getScrollState",
      value: function _getScrollState() {
        return this.props.isControlled ? this.props : this.state;
      }
    }, {
      key: "_updateScrollState",
      value: function _updateScrollState(_ref3) {
        var scrollToColumn = _ref3.scrollToColumn, scrollToRow = _ref3.scrollToRow;
        var _this$props3 = this.props, isControlled = _this$props3.isControlled, onScrollToChange = _this$props3.onScrollToChange;
        if (typeof onScrollToChange === "function") {
          onScrollToChange({
            scrollToColumn,
            scrollToRow
          });
        }
        if (!isControlled) {
          this.setState({
            scrollToColumn,
            scrollToRow
          });
        }
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, prevState) {
        if (nextProps.isControlled) {
          return {};
        }
        if (nextProps.scrollToColumn !== prevState.instanceProps.prevScrollToColumn || nextProps.scrollToRow !== prevState.instanceProps.prevScrollToRow) {
          return _objectSpread3({}, prevState, {
            scrollToColumn: nextProps.scrollToColumn,
            scrollToRow: nextProps.scrollToRow,
            instanceProps: {
              prevScrollToColumn: nextProps.scrollToColumn,
              prevScrollToRow: nextProps.scrollToRow
            }
          });
        }
        return {};
      }
    }]);
    return ArrowKeyStepper2;
  }(React80.PureComponent), (0, import_defineProperty4.default)(_class2, "propTypes", false ? null : {
    "children": import_prop_types12.default.func.isRequired,
    "className": import_prop_types12.default.string,
    "columnCount": import_prop_types12.default.number.isRequired,
    "disabled": import_prop_types12.default.bool.isRequired,
    "isControlled": import_prop_types12.default.bool.isRequired,
    "mode": import_prop_types12.default.oneOf(["cells", "edges"]).isRequired,
    "onScrollToChange": import_prop_types12.default.func,
    "rowCount": import_prop_types12.default.number.isRequired,
    "scrollToColumn": import_prop_types12.default.number.isRequired,
    "scrollToRow": import_prop_types12.default.number.isRequired
  }), _temp2);
  (0, import_defineProperty4.default)(ArrowKeyStepper, "defaultProps", {
    disabled: false,
    isControlled: false,
    mode: "edges",
    scrollToColumn: 0,
    scrollToRow: 0
  });
  polyfill(ArrowKeyStepper);

  // node_modules/react-virtualized/dist/es/AutoSizer/AutoSizer.js
  var import_classCallCheck5 = __toESM(require_classCallCheck());
  var import_createClass5 = __toESM(require_createClass());
  var import_possibleConstructorReturn3 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf3 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized4 = __toESM(require_assertThisInitialized());
  var import_inherits3 = __toESM(require_inherits());
  var import_defineProperty5 = __toESM(require_defineProperty());
  var React81 = __toESM(require_react());

  // node_modules/react-virtualized/dist/es/vendor/detectElementResize.js
  function createDetectElementResize(nonce, hostWindow) {
    var _window;
    if (typeof hostWindow !== "undefined") {
      _window = hostWindow;
    } else if (typeof window !== "undefined") {
      _window = window;
    } else if (typeof self !== "undefined") {
      _window = self;
    } else {
      _window = global;
    }
    var attachEvent = typeof _window.document !== "undefined" && _window.document.attachEvent;
    if (!attachEvent) {
      var requestFrame = function() {
        var raf2 = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function(fn) {
          return _window.setTimeout(fn, 20);
        };
        return function(fn) {
          return raf2(fn);
        };
      }();
      var cancelFrame = function() {
        var cancel2 = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
        return function(id) {
          return cancel2(id);
        };
      }();
      var resetTriggers = function resetTriggers2(element) {
        var triggers = element.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
        contract.scrollLeft = contract.scrollWidth;
        contract.scrollTop = contract.scrollHeight;
        expandChild.style.width = expand.offsetWidth + 1 + "px";
        expandChild.style.height = expand.offsetHeight + 1 + "px";
        expand.scrollLeft = expand.scrollWidth;
        expand.scrollTop = expand.scrollHeight;
      };
      var checkTriggers = function checkTriggers2(element) {
        return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
      };
      var scrollListener = function scrollListener2(e) {
        if (e.target.className && typeof e.target.className.indexOf === "function" && e.target.className.indexOf("contract-trigger") < 0 && e.target.className.indexOf("expand-trigger") < 0) {
          return;
        }
        var element = this;
        resetTriggers(this);
        if (this.__resizeRAF__) {
          cancelFrame(this.__resizeRAF__);
        }
        this.__resizeRAF__ = requestFrame(function() {
          if (checkTriggers(element)) {
            element.__resizeLast__.width = element.offsetWidth;
            element.__resizeLast__.height = element.offsetHeight;
            element.__resizeListeners__.forEach(function(fn) {
              fn.call(element, e);
            });
          }
        });
      };
      var animation = false, keyframeprefix = "", animationstartevent = "animationstart", domPrefixes = "Webkit Moz O ms".split(" "), startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "), pfx = "";
      {
        var elm = _window.document.createElement("fakeelement");
        if (elm.style.animationName !== void 0) {
          animation = true;
        }
        if (animation === false) {
          for (var i = 0; i < domPrefixes.length; i++) {
            if (elm.style[domPrefixes[i] + "AnimationName"] !== void 0) {
              pfx = domPrefixes[i];
              keyframeprefix = "-" + pfx.toLowerCase() + "-";
              animationstartevent = startEvents[i];
              animation = true;
              break;
            }
          }
        }
      }
      var animationName = "resizeanim";
      var animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ";
      var animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
    }
    var createStyles = function createStyles2(doc) {
      if (!doc.getElementById("detectElementResize")) {
        var css = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = doc.head || doc.getElementsByTagName("head")[0], style4 = doc.createElement("style");
        style4.id = "detectElementResize";
        style4.type = "text/css";
        if (nonce != null) {
          style4.setAttribute("nonce", nonce);
        }
        if (style4.styleSheet) {
          style4.styleSheet.cssText = css;
        } else {
          style4.appendChild(doc.createTextNode(css));
        }
        head.appendChild(style4);
      }
    };
    var addResizeListener = function addResizeListener2(element, fn) {
      if (attachEvent) {
        element.attachEvent("onresize", fn);
      } else {
        if (!element.__resizeTriggers__) {
          var doc = element.ownerDocument;
          var elementStyle = _window.getComputedStyle(element);
          if (elementStyle && elementStyle.position == "static") {
            element.style.position = "relative";
          }
          createStyles(doc);
          element.__resizeLast__ = {};
          element.__resizeListeners__ = [];
          (element.__resizeTriggers__ = doc.createElement("div")).className = "resize-triggers";
          var resizeTriggersHtml = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>';
          if (window.trustedTypes) {
            var staticPolicy = trustedTypes.createPolicy("react-virtualized-auto-sizer", {
              createHTML: function createHTML() {
                return resizeTriggersHtml;
              }
            });
            element.__resizeTriggers__.innerHTML = staticPolicy.createHTML("");
          } else {
            element.__resizeTriggers__.innerHTML = resizeTriggersHtml;
          }
          element.appendChild(element.__resizeTriggers__);
          resetTriggers(element);
          element.addEventListener("scroll", scrollListener, true);
          if (animationstartevent) {
            element.__resizeTriggers__.__animationListener__ = function animationListener(e) {
              if (e.animationName == animationName) {
                resetTriggers(element);
              }
            };
            element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);
          }
        }
        element.__resizeListeners__.push(fn);
      }
    };
    var removeResizeListener = function removeResizeListener2(element, fn) {
      if (attachEvent) {
        element.detachEvent("onresize", fn);
      } else {
        element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
        if (!element.__resizeListeners__.length) {
          element.removeEventListener("scroll", scrollListener, true);
          if (element.__resizeTriggers__.__animationListener__) {
            element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);
            element.__resizeTriggers__.__animationListener__ = null;
          }
          try {
            element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
          } catch (e) {
          }
        }
      }
    };
    return {
      addResizeListener,
      removeResizeListener
    };
  }

  // node_modules/react-virtualized/dist/es/AutoSizer/AutoSizer.js
  var import_prop_types13 = __toESM(require_prop_types());
  var _class3;
  var _temp3;
  function ownKeys4(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread4(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys4(source, true).forEach(function(key) {
          (0, import_defineProperty5.default)(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys4(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var AutoSizer = (_temp3 = _class3 = /* @__PURE__ */ function(_React$Component) {
    (0, import_inherits3.default)(AutoSizer2, _React$Component);
    function AutoSizer2() {
      var _getPrototypeOf22;
      var _this;
      (0, import_classCallCheck5.default)(this, AutoSizer2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = (0, import_possibleConstructorReturn3.default)(this, (_getPrototypeOf22 = (0, import_getPrototypeOf3.default)(AutoSizer2)).call.apply(_getPrototypeOf22, [this].concat(args)));
      (0, import_defineProperty5.default)((0, import_assertThisInitialized4.default)(_this), "state", {
        height: _this.props.defaultHeight || 0,
        width: _this.props.defaultWidth || 0
      });
      (0, import_defineProperty5.default)((0, import_assertThisInitialized4.default)(_this), "_parentNode", void 0);
      (0, import_defineProperty5.default)((0, import_assertThisInitialized4.default)(_this), "_autoSizer", void 0);
      (0, import_defineProperty5.default)((0, import_assertThisInitialized4.default)(_this), "_window", void 0);
      (0, import_defineProperty5.default)((0, import_assertThisInitialized4.default)(_this), "_detectElementResize", void 0);
      (0, import_defineProperty5.default)((0, import_assertThisInitialized4.default)(_this), "_onResize", function() {
        var _this$props = _this.props, disableHeight = _this$props.disableHeight, disableWidth = _this$props.disableWidth, onResize3 = _this$props.onResize;
        if (_this._parentNode) {
          var height = _this._parentNode.offsetHeight || 0;
          var width = _this._parentNode.offsetWidth || 0;
          var win2 = _this._window || window;
          var style4 = win2.getComputedStyle(_this._parentNode) || {};
          var paddingLeft = parseInt(style4.paddingLeft, 10) || 0;
          var paddingRight = parseInt(style4.paddingRight, 10) || 0;
          var paddingTop = parseInt(style4.paddingTop, 10) || 0;
          var paddingBottom = parseInt(style4.paddingBottom, 10) || 0;
          var newHeight = height - paddingTop - paddingBottom;
          var newWidth = width - paddingLeft - paddingRight;
          if (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) {
            _this.setState({
              height: height - paddingTop - paddingBottom,
              width: width - paddingLeft - paddingRight
            });
            onResize3({
              height,
              width
            });
          }
        }
      });
      (0, import_defineProperty5.default)((0, import_assertThisInitialized4.default)(_this), "_setRef", function(autoSizer) {
        _this._autoSizer = autoSizer;
      });
      return _this;
    }
    (0, import_createClass5.default)(AutoSizer2, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var nonce = this.props.nonce;
        if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {
          this._parentNode = this._autoSizer.parentNode;
          this._window = this._autoSizer.parentNode.ownerDocument.defaultView;
          this._detectElementResize = createDetectElementResize(nonce, this._window);
          this._detectElementResize.addResizeListener(this._parentNode, this._onResize);
          this._onResize();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._detectElementResize && this._parentNode) {
          this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props, children2 = _this$props2.children, className = _this$props2.className, disableHeight = _this$props2.disableHeight, disableWidth = _this$props2.disableWidth, style4 = _this$props2.style;
        var _this$state = this.state, height = _this$state.height, width = _this$state.width;
        var outerStyle = {
          overflow: "visible"
        };
        var childParams = {};
        if (!disableHeight) {
          outerStyle.height = 0;
          childParams.height = height;
        }
        if (!disableWidth) {
          outerStyle.width = 0;
          childParams.width = width;
        }
        return React81.createElement("div", {
          className,
          ref: this._setRef,
          style: _objectSpread4({}, outerStyle, {}, style4)
        }, children2(childParams));
      }
    }]);
    return AutoSizer2;
  }(React81.Component), (0, import_defineProperty5.default)(_class3, "propTypes", false ? null : {
    "children": import_prop_types13.default.func.isRequired,
    "className": import_prop_types13.default.string,
    "defaultHeight": import_prop_types13.default.number,
    "defaultWidth": import_prop_types13.default.number,
    "disableHeight": import_prop_types13.default.bool.isRequired,
    "disableWidth": import_prop_types13.default.bool.isRequired,
    "nonce": import_prop_types13.default.string,
    "onResize": import_prop_types13.default.func.isRequired,
    "style": import_prop_types13.default.object
  }), _temp3);
  (0, import_defineProperty5.default)(AutoSizer, "defaultProps", {
    onResize: function onResize() {
    },
    disableHeight: false,
    disableWidth: false,
    style: {}
  });

  // node_modules/react-virtualized/dist/es/CellMeasurer/CellMeasurer.js
  var import_classCallCheck6 = __toESM(require_classCallCheck());
  var import_createClass6 = __toESM(require_createClass());
  var import_possibleConstructorReturn4 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf4 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized5 = __toESM(require_assertThisInitialized());
  var import_inherits4 = __toESM(require_inherits());
  var import_defineProperty6 = __toESM(require_defineProperty());
  var React82 = __toESM(require_react());
  var import_react_dom3 = __toESM(require_react_dom());

  // node_modules/react-virtualized/dist/es/CellMeasurer/types.js
  var import_prop_types14 = __toESM(require_prop_types());
  var bpfrpt_proptype_CellMeasureCache = false ? null : {
    "hasFixedWidth": import_prop_types14.default.func.isRequired,
    "hasFixedHeight": import_prop_types14.default.func.isRequired,
    "has": import_prop_types14.default.func.isRequired,
    "set": import_prop_types14.default.func.isRequired,
    "getHeight": import_prop_types14.default.func.isRequired,
    "getWidth": import_prop_types14.default.func.isRequired
  };

  // node_modules/react-virtualized/dist/es/CellMeasurer/CellMeasurer.js
  var import_prop_types15 = __toESM(require_prop_types());
  var _class4;
  var _temp4;
  var CellMeasurer = (_temp4 = _class4 = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits4.default)(CellMeasurer2, _React$PureComponent);
    function CellMeasurer2() {
      var _getPrototypeOf22;
      var _this;
      (0, import_classCallCheck6.default)(this, CellMeasurer2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = (0, import_possibleConstructorReturn4.default)(this, (_getPrototypeOf22 = (0, import_getPrototypeOf4.default)(CellMeasurer2)).call.apply(_getPrototypeOf22, [this].concat(args)));
      (0, import_defineProperty6.default)((0, import_assertThisInitialized5.default)(_this), "_child", void 0);
      (0, import_defineProperty6.default)((0, import_assertThisInitialized5.default)(_this), "_measure", function() {
        var _this$props = _this.props, cache4 = _this$props.cache, _this$props$columnInd = _this$props.columnIndex, columnIndex = _this$props$columnInd === void 0 ? 0 : _this$props$columnInd, parent = _this$props.parent, _this$props$rowIndex = _this$props.rowIndex, rowIndex = _this$props$rowIndex === void 0 ? _this.props.index || 0 : _this$props$rowIndex;
        var _this$_getCellMeasure = _this._getCellMeasurements(), height = _this$_getCellMeasure.height, width = _this$_getCellMeasure.width;
        if (height !== cache4.getHeight(rowIndex, columnIndex) || width !== cache4.getWidth(rowIndex, columnIndex)) {
          cache4.set(rowIndex, columnIndex, width, height);
          if (parent && typeof parent.recomputeGridSize === "function") {
            parent.recomputeGridSize({
              columnIndex,
              rowIndex
            });
          }
        }
      });
      (0, import_defineProperty6.default)((0, import_assertThisInitialized5.default)(_this), "_registerChild", function(element) {
        if (element && !(element instanceof Element)) {
          console.warn("CellMeasurer registerChild expects to be passed Element or null");
        }
        _this._child = element;
        if (element) {
          _this._maybeMeasureCell();
        }
      });
      return _this;
    }
    (0, import_createClass6.default)(CellMeasurer2, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._maybeMeasureCell();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this._maybeMeasureCell();
      }
    }, {
      key: "render",
      value: function render() {
        var children2 = this.props.children;
        return typeof children2 === "function" ? children2({
          measure: this._measure,
          registerChild: this._registerChild
        }) : children2;
      }
    }, {
      key: "_getCellMeasurements",
      value: function _getCellMeasurements() {
        var cache4 = this.props.cache;
        var node = this._child || (0, import_react_dom3.findDOMNode)(this);
        if (node && node.ownerDocument && node.ownerDocument.defaultView && node instanceof node.ownerDocument.defaultView.HTMLElement) {
          var styleWidth = node.style.width;
          var styleHeight = node.style.height;
          if (!cache4.hasFixedWidth()) {
            node.style.width = "auto";
          }
          if (!cache4.hasFixedHeight()) {
            node.style.height = "auto";
          }
          var height = Math.ceil(node.offsetHeight);
          var width = Math.ceil(node.offsetWidth);
          if (styleWidth) {
            node.style.width = styleWidth;
          }
          if (styleHeight) {
            node.style.height = styleHeight;
          }
          return {
            height,
            width
          };
        } else {
          return {
            height: 0,
            width: 0
          };
        }
      }
    }, {
      key: "_maybeMeasureCell",
      value: function _maybeMeasureCell() {
        var _this$props2 = this.props, cache4 = _this$props2.cache, _this$props2$columnIn = _this$props2.columnIndex, columnIndex = _this$props2$columnIn === void 0 ? 0 : _this$props2$columnIn, parent = _this$props2.parent, _this$props2$rowIndex = _this$props2.rowIndex, rowIndex = _this$props2$rowIndex === void 0 ? this.props.index || 0 : _this$props2$rowIndex;
        if (!cache4.has(rowIndex, columnIndex)) {
          var _this$_getCellMeasure2 = this._getCellMeasurements(), height = _this$_getCellMeasure2.height, width = _this$_getCellMeasure2.width;
          cache4.set(rowIndex, columnIndex, width, height);
          if (parent && typeof parent.invalidateCellSizeAfterRender === "function") {
            parent.invalidateCellSizeAfterRender({
              columnIndex,
              rowIndex
            });
          }
        }
      }
    }]);
    return CellMeasurer2;
  }(React82.PureComponent), (0, import_defineProperty6.default)(_class4, "propTypes", false ? null : {
    "cache": function cache2() {
      return (typeof bpfrpt_proptype_CellMeasureCache === "function" ? bpfrpt_proptype_CellMeasureCache.isRequired ? bpfrpt_proptype_CellMeasureCache.isRequired : bpfrpt_proptype_CellMeasureCache : import_prop_types15.default.shape(bpfrpt_proptype_CellMeasureCache).isRequired).apply(this, arguments);
    },
    "children": import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.node]).isRequired,
    "columnIndex": import_prop_types15.default.number,
    "index": import_prop_types15.default.number,
    "parent": import_prop_types15.default.shape({
      invalidateCellSizeAfterRender: import_prop_types15.default.func,
      recomputeGridSize: import_prop_types15.default.func
    }).isRequired,
    "rowIndex": import_prop_types15.default.number
  }), _temp4);
  (0, import_defineProperty6.default)(CellMeasurer, "__internalCellMeasurerFlag", false);
  if (true) {
    CellMeasurer.__internalCellMeasurerFlag = true;
  }

  // node_modules/react-virtualized/dist/es/CellMeasurer/CellMeasurerCache.js
  var import_classCallCheck7 = __toESM(require_classCallCheck());
  var import_createClass7 = __toESM(require_createClass());
  var import_defineProperty7 = __toESM(require_defineProperty());

  // node_modules/react-virtualized/dist/es/Collection/Collection.js
  var import_extends7 = __toESM(require_extends());
  var import_classCallCheck11 = __toESM(require_classCallCheck());
  var import_createClass11 = __toESM(require_createClass());
  var import_possibleConstructorReturn6 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf6 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized7 = __toESM(require_assertThisInitialized());
  var import_inherits6 = __toESM(require_inherits());
  var import_defineProperty9 = __toESM(require_defineProperty());
  var import_prop_types18 = __toESM(require_prop_types());
  var React84 = __toESM(require_react());

  // node_modules/react-virtualized/dist/es/Collection/CollectionView.js
  var import_classCallCheck8 = __toESM(require_classCallCheck());
  var import_createClass8 = __toESM(require_createClass());
  var import_possibleConstructorReturn5 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf5 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized6 = __toESM(require_assertThisInitialized());
  var import_inherits5 = __toESM(require_inherits());
  var import_defineProperty8 = __toESM(require_defineProperty());
  var import_prop_types16 = __toESM(require_prop_types());
  var React83 = __toESM(require_react());
  function ownKeys5(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread5(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys5(source, true).forEach(function(key) {
          (0, import_defineProperty8.default)(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys5(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var IS_SCROLLING_TIMEOUT = 150;
  var SCROLL_POSITION_CHANGE_REASONS2 = {
    OBSERVED: "observed",
    REQUESTED: "requested"
  };
  var CollectionView = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits5.default)(CollectionView2, _React$PureComponent);
    function CollectionView2() {
      var _getPrototypeOf22;
      var _this;
      (0, import_classCallCheck8.default)(this, CollectionView2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = (0, import_possibleConstructorReturn5.default)(this, (_getPrototypeOf22 = (0, import_getPrototypeOf5.default)(CollectionView2)).call.apply(_getPrototypeOf22, [this].concat(args)));
      (0, import_defineProperty8.default)((0, import_assertThisInitialized6.default)(_this), "state", {
        isScrolling: false,
        scrollLeft: 0,
        scrollTop: 0
      });
      (0, import_defineProperty8.default)((0, import_assertThisInitialized6.default)(_this), "_calculateSizeAndPositionDataOnNextUpdate", false);
      (0, import_defineProperty8.default)((0, import_assertThisInitialized6.default)(_this), "_onSectionRenderedMemoizer", createCallbackMemoizer());
      (0, import_defineProperty8.default)((0, import_assertThisInitialized6.default)(_this), "_onScrollMemoizer", createCallbackMemoizer(false));
      (0, import_defineProperty8.default)((0, import_assertThisInitialized6.default)(_this), "_invokeOnSectionRenderedHelper", function() {
        var _this$props = _this.props, cellLayoutManager = _this$props.cellLayoutManager, onSectionRendered3 = _this$props.onSectionRendered;
        _this._onSectionRenderedMemoizer({
          callback: onSectionRendered3,
          indices: {
            indices: cellLayoutManager.getLastRenderedIndices()
          }
        });
      });
      (0, import_defineProperty8.default)((0, import_assertThisInitialized6.default)(_this), "_setScrollingContainerRef", function(ref) {
        _this._scrollingContainer = ref;
      });
      (0, import_defineProperty8.default)((0, import_assertThisInitialized6.default)(_this), "_updateScrollPositionForScrollToCell", function() {
        var _this$props2 = _this.props, cellLayoutManager = _this$props2.cellLayoutManager, height = _this$props2.height, scrollToAlignment3 = _this$props2.scrollToAlignment, scrollToCell = _this$props2.scrollToCell, width = _this$props2.width;
        var _this$state = _this.state, scrollLeft = _this$state.scrollLeft, scrollTop = _this$state.scrollTop;
        if (scrollToCell >= 0) {
          var scrollPosition2 = cellLayoutManager.getScrollPositionForCell({
            align: scrollToAlignment3,
            cellIndex: scrollToCell,
            height,
            scrollLeft,
            scrollTop,
            width
          });
          if (scrollPosition2.scrollLeft !== scrollLeft || scrollPosition2.scrollTop !== scrollTop) {
            _this._setScrollPosition(scrollPosition2);
          }
        }
      });
      (0, import_defineProperty8.default)((0, import_assertThisInitialized6.default)(_this), "_onScroll", function(event) {
        if (event.target !== _this._scrollingContainer) {
          return;
        }
        _this._enablePointerEventsAfterDelay();
        var _this$props3 = _this.props, cellLayoutManager = _this$props3.cellLayoutManager, height = _this$props3.height, isScrollingChange = _this$props3.isScrollingChange, width = _this$props3.width;
        var scrollbarSize2 = _this._scrollbarSize;
        var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(), totalHeight = _cellLayoutManager$ge.height, totalWidth = _cellLayoutManager$ge.width;
        var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize2, event.target.scrollLeft));
        var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize2, event.target.scrollTop));
        if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {
          var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS2.OBSERVED : SCROLL_POSITION_CHANGE_REASONS2.REQUESTED;
          if (!_this.state.isScrolling) {
            isScrollingChange(true);
          }
          _this.setState({
            isScrolling: true,
            scrollLeft,
            scrollPositionChangeReason,
            scrollTop
          });
        }
        _this._invokeOnScrollMemoizer({
          scrollLeft,
          scrollTop,
          totalWidth,
          totalHeight
        });
      });
      _this._scrollbarSize = scrollbarSize();
      if (_this._scrollbarSize === void 0) {
        _this._scrollbarSizeMeasured = false;
        _this._scrollbarSize = 0;
      } else {
        _this._scrollbarSizeMeasured = true;
      }
      return _this;
    }
    (0, import_createClass8.default)(CollectionView2, [{
      key: "recomputeCellSizesAndPositions",
      value: function recomputeCellSizesAndPositions() {
        this._calculateSizeAndPositionDataOnNextUpdate = true;
        this.forceUpdate();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props4 = this.props, cellLayoutManager = _this$props4.cellLayoutManager, scrollLeft = _this$props4.scrollLeft, scrollToCell = _this$props4.scrollToCell, scrollTop = _this$props4.scrollTop;
        if (!this._scrollbarSizeMeasured) {
          this._scrollbarSize = scrollbarSize();
          this._scrollbarSizeMeasured = true;
          this.setState({});
        }
        if (scrollToCell >= 0) {
          this._updateScrollPositionForScrollToCell();
        } else if (scrollLeft >= 0 || scrollTop >= 0) {
          this._setScrollPosition({
            scrollLeft,
            scrollTop
          });
        }
        this._invokeOnSectionRenderedHelper();
        var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(), totalHeight = _cellLayoutManager$ge2.height, totalWidth = _cellLayoutManager$ge2.width;
        this._invokeOnScrollMemoizer({
          scrollLeft: scrollLeft || 0,
          scrollTop: scrollTop || 0,
          totalHeight,
          totalWidth
        });
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        var _this$props5 = this.props, height = _this$props5.height, scrollToAlignment3 = _this$props5.scrollToAlignment, scrollToCell = _this$props5.scrollToCell, width = _this$props5.width;
        var _this$state2 = this.state, scrollLeft = _this$state2.scrollLeft, scrollPositionChangeReason = _this$state2.scrollPositionChangeReason, scrollTop = _this$state2.scrollTop;
        if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS2.REQUESTED) {
          if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {
            this._scrollingContainer.scrollLeft = scrollLeft;
          }
          if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {
            this._scrollingContainer.scrollTop = scrollTop;
          }
        }
        if (height !== prevProps.height || scrollToAlignment3 !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {
          this._updateScrollPositionForScrollToCell();
        }
        this._invokeOnSectionRenderedHelper();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._disablePointerEventsTimeoutId) {
          clearTimeout(this._disablePointerEventsTimeoutId);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props6 = this.props, autoHeight = _this$props6.autoHeight, cellCount = _this$props6.cellCount, cellLayoutManager = _this$props6.cellLayoutManager, className = _this$props6.className, height = _this$props6.height, horizontalOverscanSize = _this$props6.horizontalOverscanSize, id = _this$props6.id, noContentRenderer3 = _this$props6.noContentRenderer, style4 = _this$props6.style, verticalOverscanSize = _this$props6.verticalOverscanSize, width = _this$props6.width;
        var _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollLeft = _this$state3.scrollLeft, scrollTop = _this$state3.scrollTop;
        if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {
          this._lastRenderedCellCount = cellCount;
          this._lastRenderedCellLayoutManager = cellLayoutManager;
          this._calculateSizeAndPositionDataOnNextUpdate = false;
          cellLayoutManager.calculateSizeAndPositionData();
        }
        var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(), totalHeight = _cellLayoutManager$ge3.height, totalWidth = _cellLayoutManager$ge3.width;
        var left = Math.max(0, scrollLeft - horizontalOverscanSize);
        var top = Math.max(0, scrollTop - verticalOverscanSize);
        var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);
        var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);
        var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({
          height: bottom - top,
          isScrolling,
          width: right - left,
          x: left,
          y: top
        }) : [];
        var collectionStyle = {
          boxSizing: "border-box",
          direction: "ltr",
          height: autoHeight ? "auto" : height,
          position: "relative",
          WebkitOverflowScrolling: "touch",
          width,
          willChange: "transform"
        };
        var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;
        var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;
        collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? "hidden" : "auto";
        collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? "hidden" : "auto";
        return React83.createElement("div", {
          ref: this._setScrollingContainerRef,
          "aria-label": this.props["aria-label"],
          className: clsx_m_default("ReactVirtualized__Collection", className),
          id,
          onScroll: this._onScroll,
          role: "grid",
          style: _objectSpread5({}, collectionStyle, {}, style4),
          tabIndex: 0
        }, cellCount > 0 && React83.createElement("div", {
          className: "ReactVirtualized__Collection__innerScrollContainer",
          style: {
            height: totalHeight,
            maxHeight: totalHeight,
            maxWidth: totalWidth,
            overflow: "hidden",
            pointerEvents: isScrolling ? "none" : "",
            width: totalWidth
          }
        }, childrenToDisplay), cellCount === 0 && noContentRenderer3());
      }
    }, {
      key: "_enablePointerEventsAfterDelay",
      value: function _enablePointerEventsAfterDelay() {
        var _this2 = this;
        if (this._disablePointerEventsTimeoutId) {
          clearTimeout(this._disablePointerEventsTimeoutId);
        }
        this._disablePointerEventsTimeoutId = setTimeout(function() {
          var isScrollingChange = _this2.props.isScrollingChange;
          isScrollingChange(false);
          _this2._disablePointerEventsTimeoutId = null;
          _this2.setState({
            isScrolling: false
          });
        }, IS_SCROLLING_TIMEOUT);
      }
    }, {
      key: "_invokeOnScrollMemoizer",
      value: function _invokeOnScrollMemoizer(_ref) {
        var _this3 = this;
        var scrollLeft = _ref.scrollLeft, scrollTop = _ref.scrollTop, totalHeight = _ref.totalHeight, totalWidth = _ref.totalWidth;
        this._onScrollMemoizer({
          callback: function callback(_ref2) {
            var scrollLeft2 = _ref2.scrollLeft, scrollTop2 = _ref2.scrollTop;
            var _this3$props = _this3.props, height = _this3$props.height, onScroll7 = _this3$props.onScroll, width = _this3$props.width;
            onScroll7({
              clientHeight: height,
              clientWidth: width,
              scrollHeight: totalHeight,
              scrollLeft: scrollLeft2,
              scrollTop: scrollTop2,
              scrollWidth: totalWidth
            });
          },
          indices: {
            scrollLeft,
            scrollTop
          }
        });
      }
    }, {
      key: "_setScrollPosition",
      value: function _setScrollPosition(_ref3) {
        var scrollLeft = _ref3.scrollLeft, scrollTop = _ref3.scrollTop;
        var newState = {
          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS2.REQUESTED
        };
        if (scrollLeft >= 0) {
          newState.scrollLeft = scrollLeft;
        }
        if (scrollTop >= 0) {
          newState.scrollTop = scrollTop;
        }
        if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {
          this.setState(newState);
        }
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, prevState) {
        if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {
          return {
            scrollLeft: 0,
            scrollTop: 0,
            scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS2.REQUESTED
          };
        } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {
          return {
            scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,
            scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop,
            scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS2.REQUESTED
          };
        }
        return null;
      }
    }]);
    return CollectionView2;
  }(React83.PureComponent);
  (0, import_defineProperty8.default)(CollectionView, "defaultProps", {
    "aria-label": "grid",
    horizontalOverscanSize: 0,
    noContentRenderer: function noContentRenderer2() {
      return null;
    },
    onScroll: function onScroll2() {
      return null;
    },
    onSectionRendered: function onSectionRendered2() {
      return null;
    },
    scrollToAlignment: "auto",
    scrollToCell: -1,
    style: {},
    verticalOverscanSize: 0
  });
  CollectionView.propTypes = true ? {
    "aria-label": import_prop_types16.default.string,
    autoHeight: import_prop_types16.default.bool,
    cellCount: import_prop_types16.default.number.isRequired,
    cellLayoutManager: import_prop_types16.default.object.isRequired,
    className: import_prop_types16.default.string,
    height: import_prop_types16.default.number.isRequired,
    id: import_prop_types16.default.string,
    horizontalOverscanSize: import_prop_types16.default.number.isRequired,
    isScrollingChange: import_prop_types16.default.func,
    noContentRenderer: import_prop_types16.default.func.isRequired,
    onScroll: import_prop_types16.default.func.isRequired,
    onSectionRendered: import_prop_types16.default.func.isRequired,
    scrollLeft: import_prop_types16.default.number,
    scrollToAlignment: import_prop_types16.default.oneOf(["auto", "end", "start", "center"]).isRequired,
    scrollToCell: import_prop_types16.default.number.isRequired,
    scrollTop: import_prop_types16.default.number,
    style: import_prop_types16.default.object,
    verticalOverscanSize: import_prop_types16.default.number.isRequired,
    width: import_prop_types16.default.number.isRequired
  } : {};
  polyfill(CollectionView);
  var CollectionView_default = CollectionView;

  // node_modules/react-virtualized/dist/es/Collection/SectionManager.js
  var import_classCallCheck10 = __toESM(require_classCallCheck());
  var import_createClass10 = __toESM(require_createClass());

  // node_modules/react-virtualized/dist/es/Collection/Section.js
  var import_classCallCheck9 = __toESM(require_classCallCheck());
  var import_createClass9 = __toESM(require_createClass());

  // node_modules/react-virtualized/dist/es/Collection/types.js
  var import_prop_types17 = __toESM(require_prop_types());
  var bpfrpt_proptype_Index = false ? null : {
    "index": import_prop_types17.default.number.isRequired
  };
  var bpfrpt_proptype_PositionInfo = false ? null : {
    "x": import_prop_types17.default.number.isRequired,
    "y": import_prop_types17.default.number.isRequired
  };
  var bpfrpt_proptype_ScrollPosition = false ? null : {
    "scrollLeft": import_prop_types17.default.number.isRequired,
    "scrollTop": import_prop_types17.default.number.isRequired
  };
  var bpfrpt_proptype_SizeAndPositionInfo = false ? null : {
    "height": import_prop_types17.default.number.isRequired,
    "width": import_prop_types17.default.number.isRequired,
    "x": import_prop_types17.default.number.isRequired,
    "y": import_prop_types17.default.number.isRequired
  };
  var bpfrpt_proptype_SizeInfo = false ? null : {
    "height": import_prop_types17.default.number.isRequired,
    "width": import_prop_types17.default.number.isRequired
  };

  // node_modules/react-virtualized/dist/es/Collection/Section.js
  var Section4 = /* @__PURE__ */ function() {
    function Section5(_ref) {
      var height = _ref.height, width = _ref.width, x = _ref.x, y = _ref.y;
      (0, import_classCallCheck9.default)(this, Section5);
      this.height = height;
      this.width = width;
      this.x = x;
      this.y = y;
      this._indexMap = {};
      this._indices = [];
    }
    (0, import_createClass9.default)(Section5, [{
      key: "addCellIndex",
      value: function addCellIndex(_ref2) {
        var index2 = _ref2.index;
        if (!this._indexMap[index2]) {
          this._indexMap[index2] = true;
          this._indices.push(index2);
        }
      }
    }, {
      key: "getCellIndices",
      value: function getCellIndices() {
        return this._indices;
      }
    }, {
      key: "toString",
      value: function toString3() {
        return "".concat(this.x, ",").concat(this.y, " ").concat(this.width, "x").concat(this.height);
      }
    }]);
    return Section5;
  }();

  // node_modules/react-virtualized/dist/es/Collection/SectionManager.js
  var SECTION_SIZE = 100;
  var SectionManager = /* @__PURE__ */ function() {
    function SectionManager2() {
      var sectionSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : SECTION_SIZE;
      (0, import_classCallCheck10.default)(this, SectionManager2);
      this._sectionSize = sectionSize;
      this._cellMetadata = [];
      this._sections = {};
    }
    (0, import_createClass10.default)(SectionManager2, [{
      key: "getCellIndices",
      value: function getCellIndices(_ref) {
        var height = _ref.height, width = _ref.width, x = _ref.x, y = _ref.y;
        var indices = {};
        this.getSections({
          height,
          width,
          x,
          y
        }).forEach(function(section) {
          return section.getCellIndices().forEach(function(index2) {
            indices[index2] = index2;
          });
        });
        return Object.keys(indices).map(function(index2) {
          return indices[index2];
        });
      }
    }, {
      key: "getCellMetadata",
      value: function getCellMetadata(_ref2) {
        var index2 = _ref2.index;
        return this._cellMetadata[index2];
      }
    }, {
      key: "getSections",
      value: function getSections(_ref3) {
        var height = _ref3.height, width = _ref3.width, x = _ref3.x, y = _ref3.y;
        var sectionXStart = Math.floor(x / this._sectionSize);
        var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);
        var sectionYStart = Math.floor(y / this._sectionSize);
        var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);
        var sections = [];
        for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {
          for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {
            var key = "".concat(sectionX, ".").concat(sectionY);
            if (!this._sections[key]) {
              this._sections[key] = new Section4({
                height: this._sectionSize,
                width: this._sectionSize,
                x: sectionX * this._sectionSize,
                y: sectionY * this._sectionSize
              });
            }
            sections.push(this._sections[key]);
          }
        }
        return sections;
      }
    }, {
      key: "getTotalSectionCount",
      value: function getTotalSectionCount() {
        return Object.keys(this._sections).length;
      }
    }, {
      key: "toString",
      value: function toString3() {
        var _this = this;
        return Object.keys(this._sections).map(function(index2) {
          return _this._sections[index2].toString();
        });
      }
    }, {
      key: "registerCell",
      value: function registerCell(_ref4) {
        var cellMetadatum = _ref4.cellMetadatum, index2 = _ref4.index;
        this._cellMetadata[index2] = cellMetadatum;
        this.getSections(cellMetadatum).forEach(function(section) {
          return section.addCellIndex({
            index: index2
          });
        });
      }
    }]);
    return SectionManager2;
  }();

  // node_modules/react-virtualized/dist/es/Collection/utils/calculateSizeAndPositionData.js
  function calculateSizeAndPositionData(_ref) {
    var cellCount = _ref.cellCount, cellSizeAndPositionGetter = _ref.cellSizeAndPositionGetter, sectionSize = _ref.sectionSize;
    var cellMetadata = [];
    var sectionManager = new SectionManager(sectionSize);
    var height = 0;
    var width = 0;
    for (var index2 = 0; index2 < cellCount; index2++) {
      var cellMetadatum = cellSizeAndPositionGetter({
        index: index2
      });
      if (cellMetadatum.height == null || isNaN(cellMetadatum.height) || cellMetadatum.width == null || isNaN(cellMetadatum.width) || cellMetadatum.x == null || isNaN(cellMetadatum.x) || cellMetadatum.y == null || isNaN(cellMetadatum.y)) {
        throw Error("Invalid metadata returned for cell ".concat(index2, ":\n        x:").concat(cellMetadatum.x, ", y:").concat(cellMetadatum.y, ", width:").concat(cellMetadatum.width, ", height:").concat(cellMetadatum.height));
      }
      height = Math.max(height, cellMetadatum.y + cellMetadatum.height);
      width = Math.max(width, cellMetadatum.x + cellMetadatum.width);
      cellMetadata[index2] = cellMetadatum;
      sectionManager.registerCell({
        cellMetadatum,
        index: index2
      });
    }
    return {
      cellMetadata,
      height,
      sectionManager,
      width
    };
  }

  // node_modules/react-virtualized/dist/es/utils/getUpdatedOffsetForIndex.js
  function getUpdatedOffsetForIndex(_ref) {
    var _ref$align = _ref.align, align = _ref$align === void 0 ? "auto" : _ref$align, cellOffset = _ref.cellOffset, cellSize = _ref.cellSize, containerSize = _ref.containerSize, currentOffset = _ref.currentOffset;
    var maxOffset = cellOffset;
    var minOffset = maxOffset - containerSize + cellSize;
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        return maxOffset - (containerSize - cellSize) / 2;
      default:
        return Math.max(minOffset, Math.min(maxOffset, currentOffset));
    }
  }

  // node_modules/react-virtualized/dist/es/Collection/Collection.js
  var Collection = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits6.default)(Collection2, _React$PureComponent);
    function Collection2(props, context2) {
      var _this;
      (0, import_classCallCheck11.default)(this, Collection2);
      _this = (0, import_possibleConstructorReturn6.default)(this, (0, import_getPrototypeOf6.default)(Collection2).call(this, props, context2));
      _this._cellMetadata = [];
      _this._lastRenderedCellIndices = [];
      _this._cellCache = [];
      _this._isScrollingChange = _this._isScrollingChange.bind((0, import_assertThisInitialized7.default)(_this));
      _this._setCollectionViewRef = _this._setCollectionViewRef.bind((0, import_assertThisInitialized7.default)(_this));
      return _this;
    }
    (0, import_createClass11.default)(Collection2, [{
      key: "forceUpdate",
      value: function forceUpdate() {
        if (this._collectionView !== void 0) {
          this._collectionView.forceUpdate();
        }
      }
    }, {
      key: "recomputeCellSizesAndPositions",
      value: function recomputeCellSizesAndPositions() {
        this._cellCache = [];
        this._collectionView.recomputeCellSizesAndPositions();
      }
    }, {
      key: "render",
      value: function render() {
        var props = (0, import_extends7.default)({}, this.props);
        return React84.createElement(CollectionView_default, (0, import_extends7.default)({
          cellLayoutManager: this,
          isScrollingChange: this._isScrollingChange,
          ref: this._setCollectionViewRef
        }, props));
      }
    }, {
      key: "calculateSizeAndPositionData",
      value: function calculateSizeAndPositionData2() {
        var _this$props = this.props, cellCount = _this$props.cellCount, cellSizeAndPositionGetter = _this$props.cellSizeAndPositionGetter, sectionSize = _this$props.sectionSize;
        var data = calculateSizeAndPositionData({
          cellCount,
          cellSizeAndPositionGetter,
          sectionSize
        });
        this._cellMetadata = data.cellMetadata;
        this._sectionManager = data.sectionManager;
        this._height = data.height;
        this._width = data.width;
      }
    }, {
      key: "getLastRenderedIndices",
      value: function getLastRenderedIndices() {
        return this._lastRenderedCellIndices;
      }
    }, {
      key: "getScrollPositionForCell",
      value: function getScrollPositionForCell(_ref) {
        var align = _ref.align, cellIndex = _ref.cellIndex, height = _ref.height, scrollLeft = _ref.scrollLeft, scrollTop = _ref.scrollTop, width = _ref.width;
        var cellCount = this.props.cellCount;
        if (cellIndex >= 0 && cellIndex < cellCount) {
          var cellMetadata = this._cellMetadata[cellIndex];
          scrollLeft = getUpdatedOffsetForIndex({
            align,
            cellOffset: cellMetadata.x,
            cellSize: cellMetadata.width,
            containerSize: width,
            currentOffset: scrollLeft,
            targetIndex: cellIndex
          });
          scrollTop = getUpdatedOffsetForIndex({
            align,
            cellOffset: cellMetadata.y,
            cellSize: cellMetadata.height,
            containerSize: height,
            currentOffset: scrollTop,
            targetIndex: cellIndex
          });
        }
        return {
          scrollLeft,
          scrollTop
        };
      }
    }, {
      key: "getTotalSize",
      value: function getTotalSize() {
        return {
          height: this._height,
          width: this._width
        };
      }
    }, {
      key: "cellRenderers",
      value: function cellRenderers(_ref2) {
        var _this2 = this;
        var height = _ref2.height, isScrolling = _ref2.isScrolling, width = _ref2.width, x = _ref2.x, y = _ref2.y;
        var _this$props2 = this.props, cellGroupRenderer = _this$props2.cellGroupRenderer, cellRenderer3 = _this$props2.cellRenderer;
        this._lastRenderedCellIndices = this._sectionManager.getCellIndices({
          height,
          width,
          x,
          y
        });
        return cellGroupRenderer({
          cellCache: this._cellCache,
          cellRenderer: cellRenderer3,
          cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {
            var index2 = _ref3.index;
            return _this2._sectionManager.getCellMetadata({
              index: index2
            });
          },
          indices: this._lastRenderedCellIndices,
          isScrolling
        });
      }
    }, {
      key: "_isScrollingChange",
      value: function _isScrollingChange(isScrolling) {
        if (!isScrolling) {
          this._cellCache = [];
        }
      }
    }, {
      key: "_setCollectionViewRef",
      value: function _setCollectionViewRef(ref) {
        this._collectionView = ref;
      }
    }]);
    return Collection2;
  }(React84.PureComponent);
  (0, import_defineProperty9.default)(Collection, "defaultProps", {
    "aria-label": "grid",
    cellGroupRenderer: defaultCellGroupRenderer
  });
  Collection.propTypes = true ? {
    "aria-label": import_prop_types18.default.string,
    cellCount: import_prop_types18.default.number.isRequired,
    cellGroupRenderer: import_prop_types18.default.func.isRequired,
    cellRenderer: import_prop_types18.default.func.isRequired,
    cellSizeAndPositionGetter: import_prop_types18.default.func.isRequired,
    sectionSize: import_prop_types18.default.number
  } : {};
  function defaultCellGroupRenderer(_ref4) {
    var cellCache = _ref4.cellCache, cellRenderer3 = _ref4.cellRenderer, cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter, indices = _ref4.indices, isScrolling = _ref4.isScrolling;
    return indices.map(function(index2) {
      var cellMetadata = cellSizeAndPositionGetter({
        index: index2
      });
      var cellRendererProps = {
        index: index2,
        isScrolling,
        key: index2,
        style: {
          height: cellMetadata.height,
          left: cellMetadata.x,
          position: "absolute",
          top: cellMetadata.y,
          width: cellMetadata.width
        }
      };
      if (isScrolling) {
        if (!(index2 in cellCache)) {
          cellCache[index2] = cellRenderer3(cellRendererProps);
        }
        return cellCache[index2];
      } else {
        return cellRenderer3(cellRendererProps);
      }
    }).filter(function(renderedCell) {
      return !!renderedCell;
    });
  }

  // node_modules/react-virtualized/dist/es/ColumnSizer/ColumnSizer.js
  var import_classCallCheck12 = __toESM(require_classCallCheck());
  var import_createClass12 = __toESM(require_createClass());
  var import_possibleConstructorReturn7 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf7 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized8 = __toESM(require_assertThisInitialized());
  var import_inherits7 = __toESM(require_inherits());
  var import_prop_types19 = __toESM(require_prop_types());
  var React85 = __toESM(require_react());
  var ColumnSizer = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits7.default)(ColumnSizer2, _React$PureComponent);
    function ColumnSizer2(props, context2) {
      var _this;
      (0, import_classCallCheck12.default)(this, ColumnSizer2);
      _this = (0, import_possibleConstructorReturn7.default)(this, (0, import_getPrototypeOf7.default)(ColumnSizer2).call(this, props, context2));
      _this._registerChild = _this._registerChild.bind((0, import_assertThisInitialized8.default)(_this));
      return _this;
    }
    (0, import_createClass12.default)(ColumnSizer2, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this$props = this.props, columnMaxWidth = _this$props.columnMaxWidth, columnMinWidth = _this$props.columnMinWidth, columnCount = _this$props.columnCount, width = _this$props.width;
        if (columnMaxWidth !== prevProps.columnMaxWidth || columnMinWidth !== prevProps.columnMinWidth || columnCount !== prevProps.columnCount || width !== prevProps.width) {
          if (this._registeredChild) {
            this._registeredChild.recomputeGridSize();
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props, children2 = _this$props2.children, columnMaxWidth = _this$props2.columnMaxWidth, columnMinWidth = _this$props2.columnMinWidth, columnCount = _this$props2.columnCount, width = _this$props2.width;
        var safeColumnMinWidth = columnMinWidth || 1;
        var safeColumnMaxWidth = columnMaxWidth ? Math.min(columnMaxWidth, width) : width;
        var columnWidth2 = width / columnCount;
        columnWidth2 = Math.max(safeColumnMinWidth, columnWidth2);
        columnWidth2 = Math.min(safeColumnMaxWidth, columnWidth2);
        columnWidth2 = Math.floor(columnWidth2);
        var adjustedWidth = Math.min(width, columnWidth2 * columnCount);
        return children2({
          adjustedWidth,
          columnWidth: columnWidth2,
          getColumnWidth: function getColumnWidth() {
            return columnWidth2;
          },
          registerChild: this._registerChild
        });
      }
    }, {
      key: "_registerChild",
      value: function _registerChild(child) {
        if (child && typeof child.recomputeGridSize !== "function") {
          throw Error("Unexpected child type registered; only Grid/MultiGrid children are supported.");
        }
        this._registeredChild = child;
        if (this._registeredChild) {
          this._registeredChild.recomputeGridSize();
        }
      }
    }]);
    return ColumnSizer2;
  }(React85.PureComponent);
  ColumnSizer.propTypes = true ? {
    children: import_prop_types19.default.func.isRequired,
    columnMaxWidth: import_prop_types19.default.number,
    columnMinWidth: import_prop_types19.default.number,
    columnCount: import_prop_types19.default.number.isRequired,
    width: import_prop_types19.default.number.isRequired
  } : {};

  // node_modules/react-virtualized/dist/es/InfiniteLoader/InfiniteLoader.js
  var import_toConsumableArray = __toESM(require_toConsumableArray());
  var import_classCallCheck13 = __toESM(require_classCallCheck());
  var import_createClass13 = __toESM(require_createClass());
  var import_possibleConstructorReturn8 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf8 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized9 = __toESM(require_assertThisInitialized());
  var import_inherits8 = __toESM(require_inherits());
  var import_defineProperty10 = __toESM(require_defineProperty());
  var React86 = __toESM(require_react());
  var import_prop_types20 = __toESM(require_prop_types());
  var InfiniteLoader = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits8.default)(InfiniteLoader2, _React$PureComponent);
    function InfiniteLoader2(props, context2) {
      var _this;
      (0, import_classCallCheck13.default)(this, InfiniteLoader2);
      _this = (0, import_possibleConstructorReturn8.default)(this, (0, import_getPrototypeOf8.default)(InfiniteLoader2).call(this, props, context2));
      _this._loadMoreRowsMemoizer = createCallbackMemoizer();
      _this._onRowsRendered = _this._onRowsRendered.bind((0, import_assertThisInitialized9.default)(_this));
      _this._registerChild = _this._registerChild.bind((0, import_assertThisInitialized9.default)(_this));
      return _this;
    }
    (0, import_createClass13.default)(InfiniteLoader2, [{
      key: "resetLoadMoreRowsCache",
      value: function resetLoadMoreRowsCache(autoReload) {
        this._loadMoreRowsMemoizer = createCallbackMemoizer();
        if (autoReload) {
          this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var children2 = this.props.children;
        return children2({
          onRowsRendered: this._onRowsRendered,
          registerChild: this._registerChild
        });
      }
    }, {
      key: "_loadUnloadedRanges",
      value: function _loadUnloadedRanges(unloadedRanges) {
        var _this2 = this;
        var loadMoreRows = this.props.loadMoreRows;
        unloadedRanges.forEach(function(unloadedRange) {
          var promise = loadMoreRows(unloadedRange);
          if (promise) {
            promise.then(function() {
              if (isRangeVisible({
                lastRenderedStartIndex: _this2._lastRenderedStartIndex,
                lastRenderedStopIndex: _this2._lastRenderedStopIndex,
                startIndex: unloadedRange.startIndex,
                stopIndex: unloadedRange.stopIndex
              })) {
                if (_this2._registeredChild) {
                  forceUpdateReactVirtualizedComponent(_this2._registeredChild, _this2._lastRenderedStartIndex);
                }
              }
            });
          }
        });
      }
    }, {
      key: "_onRowsRendered",
      value: function _onRowsRendered(_ref) {
        var startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
        this._lastRenderedStartIndex = startIndex;
        this._lastRenderedStopIndex = stopIndex;
        this._doStuff(startIndex, stopIndex);
      }
    }, {
      key: "_doStuff",
      value: function _doStuff(startIndex, stopIndex) {
        var _ref2, _this3 = this;
        var _this$props = this.props, isRowLoaded = _this$props.isRowLoaded, minimumBatchSize = _this$props.minimumBatchSize, rowCount = _this$props.rowCount, threshold = _this$props.threshold;
        var unloadedRanges = scanForUnloadedRanges({
          isRowLoaded,
          minimumBatchSize,
          rowCount,
          startIndex: Math.max(0, startIndex - threshold),
          stopIndex: Math.min(rowCount - 1, stopIndex + threshold)
        });
        var squashedUnloadedRanges = (_ref2 = []).concat.apply(_ref2, (0, import_toConsumableArray.default)(unloadedRanges.map(function(_ref3) {
          var startIndex2 = _ref3.startIndex, stopIndex2 = _ref3.stopIndex;
          return [startIndex2, stopIndex2];
        })));
        this._loadMoreRowsMemoizer({
          callback: function callback() {
            _this3._loadUnloadedRanges(unloadedRanges);
          },
          indices: {
            squashedUnloadedRanges
          }
        });
      }
    }, {
      key: "_registerChild",
      value: function _registerChild(registeredChild) {
        this._registeredChild = registeredChild;
      }
    }]);
    return InfiniteLoader2;
  }(React86.PureComponent);
  (0, import_defineProperty10.default)(InfiniteLoader, "defaultProps", {
    minimumBatchSize: 10,
    rowCount: 0,
    threshold: 15
  });
  InfiniteLoader.propTypes = true ? {
    children: import_prop_types20.default.func.isRequired,
    isRowLoaded: import_prop_types20.default.func.isRequired,
    loadMoreRows: import_prop_types20.default.func.isRequired,
    minimumBatchSize: import_prop_types20.default.number.isRequired,
    rowCount: import_prop_types20.default.number.isRequired,
    threshold: import_prop_types20.default.number.isRequired
  } : {};
  function isRangeVisible(_ref4) {
    var lastRenderedStartIndex = _ref4.lastRenderedStartIndex, lastRenderedStopIndex = _ref4.lastRenderedStopIndex, startIndex = _ref4.startIndex, stopIndex = _ref4.stopIndex;
    return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);
  }
  function scanForUnloadedRanges(_ref5) {
    var isRowLoaded = _ref5.isRowLoaded, minimumBatchSize = _ref5.minimumBatchSize, rowCount = _ref5.rowCount, startIndex = _ref5.startIndex, stopIndex = _ref5.stopIndex;
    var unloadedRanges = [];
    var rangeStartIndex = null;
    var rangeStopIndex = null;
    for (var index2 = startIndex; index2 <= stopIndex; index2++) {
      var loaded = isRowLoaded({
        index: index2
      });
      if (!loaded) {
        rangeStopIndex = index2;
        if (rangeStartIndex === null) {
          rangeStartIndex = index2;
        }
      } else if (rangeStopIndex !== null) {
        unloadedRanges.push({
          startIndex: rangeStartIndex,
          stopIndex: rangeStopIndex
        });
        rangeStartIndex = rangeStopIndex = null;
      }
    }
    if (rangeStopIndex !== null) {
      var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);
      for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {
        if (!isRowLoaded({
          index: _index
        })) {
          rangeStopIndex = _index;
        } else {
          break;
        }
      }
      unloadedRanges.push({
        startIndex: rangeStartIndex,
        stopIndex: rangeStopIndex
      });
    }
    if (unloadedRanges.length) {
      var firstUnloadedRange = unloadedRanges[0];
      while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {
        var _index2 = firstUnloadedRange.startIndex - 1;
        if (!isRowLoaded({
          index: _index2
        })) {
          firstUnloadedRange.startIndex = _index2;
        } else {
          break;
        }
      }
    }
    return unloadedRanges;
  }
  function forceUpdateReactVirtualizedComponent(component) {
    var currentIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var recomputeSize = typeof component.recomputeGridSize === "function" ? component.recomputeGridSize : component.recomputeRowHeights;
    if (recomputeSize) {
      recomputeSize.call(component, currentIndex);
    } else {
      component.forceUpdate();
    }
  }

  // node_modules/react-virtualized/dist/es/List/List.js
  var import_extends8 = __toESM(require_extends());
  var import_classCallCheck14 = __toESM(require_classCallCheck());
  var import_createClass14 = __toESM(require_createClass());
  var import_possibleConstructorReturn9 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf9 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized10 = __toESM(require_assertThisInitialized());
  var import_inherits9 = __toESM(require_inherits());
  var import_defineProperty11 = __toESM(require_defineProperty());
  var React88 = __toESM(require_react());

  // node_modules/react-virtualized/dist/es/List/types.js
  var React87 = __toESM(require_react());
  var import_prop_types21 = __toESM(require_prop_types());
  var bpfrpt_proptype_RowRendererParams = false ? null : {
    "index": import_prop_types21.default.number.isRequired,
    "isScrolling": import_prop_types21.default.bool.isRequired,
    "isVisible": import_prop_types21.default.bool.isRequired,
    "key": import_prop_types21.default.string.isRequired,
    "parent": import_prop_types21.default.object.isRequired,
    "style": import_prop_types21.default.object.isRequired
  };
  var bpfrpt_proptype_RowRenderer = false ? null : import_prop_types21.default.func;
  var bpfrpt_proptype_RenderedRows = false ? null : {
    "overscanStartIndex": import_prop_types21.default.number.isRequired,
    "overscanStopIndex": import_prop_types21.default.number.isRequired,
    "startIndex": import_prop_types21.default.number.isRequired,
    "stopIndex": import_prop_types21.default.number.isRequired
  };
  var bpfrpt_proptype_Scroll2 = false ? null : {
    "clientHeight": import_prop_types21.default.number.isRequired,
    "scrollHeight": import_prop_types21.default.number.isRequired,
    "scrollTop": import_prop_types21.default.number.isRequired
  };

  // node_modules/react-virtualized/dist/es/List/List.js
  var import_prop_types22 = __toESM(require_prop_types());
  var _class5;
  var _temp5;
  var List = (_temp5 = _class5 = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits9.default)(List2, _React$PureComponent);
    function List2() {
      var _getPrototypeOf22;
      var _this;
      (0, import_classCallCheck14.default)(this, List2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = (0, import_possibleConstructorReturn9.default)(this, (_getPrototypeOf22 = (0, import_getPrototypeOf9.default)(List2)).call.apply(_getPrototypeOf22, [this].concat(args)));
      (0, import_defineProperty11.default)((0, import_assertThisInitialized10.default)(_this), "Grid", void 0);
      (0, import_defineProperty11.default)((0, import_assertThisInitialized10.default)(_this), "_cellRenderer", function(_ref) {
        var parent = _ref.parent, rowIndex = _ref.rowIndex, style4 = _ref.style, isScrolling = _ref.isScrolling, isVisible = _ref.isVisible, key = _ref.key;
        var rowRenderer2 = _this.props.rowRenderer;
        var widthDescriptor = Object.getOwnPropertyDescriptor(style4, "width");
        if (widthDescriptor && widthDescriptor.writable) {
          style4.width = "100%";
        }
        return rowRenderer2({
          index: rowIndex,
          style: style4,
          isScrolling,
          isVisible,
          key,
          parent
        });
      });
      (0, import_defineProperty11.default)((0, import_assertThisInitialized10.default)(_this), "_setRef", function(ref) {
        _this.Grid = ref;
      });
      (0, import_defineProperty11.default)((0, import_assertThisInitialized10.default)(_this), "_onScroll", function(_ref2) {
        var clientHeight = _ref2.clientHeight, scrollHeight = _ref2.scrollHeight, scrollTop = _ref2.scrollTop;
        var onScroll7 = _this.props.onScroll;
        onScroll7({
          clientHeight,
          scrollHeight,
          scrollTop
        });
      });
      (0, import_defineProperty11.default)((0, import_assertThisInitialized10.default)(_this), "_onSectionRendered", function(_ref3) {
        var rowOverscanStartIndex = _ref3.rowOverscanStartIndex, rowOverscanStopIndex = _ref3.rowOverscanStopIndex, rowStartIndex = _ref3.rowStartIndex, rowStopIndex = _ref3.rowStopIndex;
        var onRowsRendered3 = _this.props.onRowsRendered;
        onRowsRendered3({
          overscanStartIndex: rowOverscanStartIndex,
          overscanStopIndex: rowOverscanStopIndex,
          startIndex: rowStartIndex,
          stopIndex: rowStopIndex
        });
      });
      return _this;
    }
    (0, import_createClass14.default)(List2, [{
      key: "forceUpdateGrid",
      value: function forceUpdateGrid() {
        if (this.Grid) {
          this.Grid.forceUpdate();
        }
      }
    }, {
      key: "getOffsetForRow",
      value: function getOffsetForRow(_ref4) {
        var alignment = _ref4.alignment, index2 = _ref4.index;
        if (this.Grid) {
          var _this$Grid$getOffsetF = this.Grid.getOffsetForCell({
            alignment,
            rowIndex: index2,
            columnIndex: 0
          }), scrollTop = _this$Grid$getOffsetF.scrollTop;
          return scrollTop;
        }
        return 0;
      }
    }, {
      key: "invalidateCellSizeAfterRender",
      value: function invalidateCellSizeAfterRender(_ref5) {
        var columnIndex = _ref5.columnIndex, rowIndex = _ref5.rowIndex;
        if (this.Grid) {
          this.Grid.invalidateCellSizeAfterRender({
            rowIndex,
            columnIndex
          });
        }
      }
    }, {
      key: "measureAllRows",
      value: function measureAllRows() {
        if (this.Grid) {
          this.Grid.measureAllCells();
        }
      }
    }, {
      key: "recomputeGridSize",
      value: function recomputeGridSize() {
        var _ref6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref6$columnIndex = _ref6.columnIndex, columnIndex = _ref6$columnIndex === void 0 ? 0 : _ref6$columnIndex, _ref6$rowIndex = _ref6.rowIndex, rowIndex = _ref6$rowIndex === void 0 ? 0 : _ref6$rowIndex;
        if (this.Grid) {
          this.Grid.recomputeGridSize({
            rowIndex,
            columnIndex
          });
        }
      }
    }, {
      key: "recomputeRowHeights",
      value: function recomputeRowHeights() {
        var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        if (this.Grid) {
          this.Grid.recomputeGridSize({
            rowIndex: index2,
            columnIndex: 0
          });
        }
      }
    }, {
      key: "scrollToPosition",
      value: function scrollToPosition() {
        var scrollTop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        if (this.Grid) {
          this.Grid.scrollToPosition({
            scrollTop
          });
        }
      }
    }, {
      key: "scrollToRow",
      value: function scrollToRow() {
        var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        if (this.Grid) {
          this.Grid.scrollToCell({
            columnIndex: 0,
            rowIndex: index2
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props, className = _this$props.className, noRowsRenderer4 = _this$props.noRowsRenderer, scrollToIndex = _this$props.scrollToIndex, width = _this$props.width;
        var classNames2 = clsx_m_default("ReactVirtualized__List", className);
        return React88.createElement(Grid_default, (0, import_extends8.default)({}, this.props, {
          autoContainerWidth: true,
          cellRenderer: this._cellRenderer,
          className: classNames2,
          columnWidth: width,
          columnCount: 1,
          noContentRenderer: noRowsRenderer4,
          onScroll: this._onScroll,
          onSectionRendered: this._onSectionRendered,
          ref: this._setRef,
          scrollToRow: scrollToIndex
        }));
      }
    }]);
    return List2;
  }(React88.PureComponent), (0, import_defineProperty11.default)(_class5, "propTypes", false ? null : {
    "aria-label": import_prop_types22.default.string,
    "autoHeight": import_prop_types22.default.bool.isRequired,
    "className": import_prop_types22.default.string,
    "estimatedRowSize": import_prop_types22.default.number.isRequired,
    "height": import_prop_types22.default.number.isRequired,
    "noRowsRenderer": function noRowsRenderer() {
      return (typeof bpfrpt_proptype_NoContentRenderer === "function" ? bpfrpt_proptype_NoContentRenderer.isRequired ? bpfrpt_proptype_NoContentRenderer.isRequired : bpfrpt_proptype_NoContentRenderer : import_prop_types22.default.shape(bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);
    },
    "onRowsRendered": import_prop_types22.default.func.isRequired,
    "onScroll": import_prop_types22.default.func.isRequired,
    "overscanIndicesGetter": function overscanIndicesGetter2() {
      return (typeof bpfrpt_proptype_OverscanIndicesGetter === "function" ? bpfrpt_proptype_OverscanIndicesGetter.isRequired ? bpfrpt_proptype_OverscanIndicesGetter.isRequired : bpfrpt_proptype_OverscanIndicesGetter : import_prop_types22.default.shape(bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);
    },
    "overscanRowCount": import_prop_types22.default.number.isRequired,
    "rowHeight": function rowHeight2() {
      return (typeof bpfrpt_proptype_CellSize === "function" ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : import_prop_types22.default.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
    },
    "rowRenderer": function rowRenderer() {
      return (typeof bpfrpt_proptype_RowRenderer === "function" ? bpfrpt_proptype_RowRenderer.isRequired ? bpfrpt_proptype_RowRenderer.isRequired : bpfrpt_proptype_RowRenderer : import_prop_types22.default.shape(bpfrpt_proptype_RowRenderer).isRequired).apply(this, arguments);
    },
    "rowCount": import_prop_types22.default.number.isRequired,
    "scrollToAlignment": function scrollToAlignment2() {
      return (typeof bpfrpt_proptype_Alignment === "function" ? bpfrpt_proptype_Alignment.isRequired ? bpfrpt_proptype_Alignment.isRequired : bpfrpt_proptype_Alignment : import_prop_types22.default.shape(bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);
    },
    "scrollToIndex": import_prop_types22.default.number.isRequired,
    "scrollTop": import_prop_types22.default.number,
    "style": import_prop_types22.default.object.isRequired,
    "tabIndex": import_prop_types22.default.number,
    "width": import_prop_types22.default.number.isRequired
  }), _temp5);
  (0, import_defineProperty11.default)(List, "defaultProps", {
    autoHeight: false,
    estimatedRowSize: 30,
    onScroll: function onScroll3() {
    },
    noRowsRenderer: function noRowsRenderer2() {
      return null;
    },
    onRowsRendered: function onRowsRendered() {
    },
    overscanIndicesGetter: defaultOverscanIndicesGetter2,
    overscanRowCount: 10,
    scrollToAlignment: "auto",
    scrollToIndex: -1,
    style: {}
  });

  // node_modules/react-virtualized/dist/es/Masonry/Masonry.js
  var import_classCallCheck16 = __toESM(require_classCallCheck());
  var import_createClass16 = __toESM(require_createClass());
  var import_possibleConstructorReturn10 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf10 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized11 = __toESM(require_assertThisInitialized());
  var import_inherits10 = __toESM(require_inherits());
  var import_defineProperty13 = __toESM(require_defineProperty());
  var React89 = __toESM(require_react());

  // node_modules/react-virtualized/dist/es/Masonry/PositionCache.js
  var import_slicedToArray = __toESM(require_slicedToArray());
  var import_classCallCheck15 = __toESM(require_classCallCheck());
  var import_createClass15 = __toESM(require_createClass());
  var import_defineProperty12 = __toESM(require_defineProperty());

  // node_modules/react-virtualized/dist/es/vendor/binarySearchBounds.js
  function _GEA(a, l, h, y) {
    var i = h + 1;
    while (l <= h) {
      var m = l + h >>> 1, x = a[m];
      if (x >= y) {
        i = m;
        h = m - 1;
      } else {
        l = m + 1;
      }
    }
    return i;
  }
  function _GEP(a, l, h, y, c) {
    var i = h + 1;
    while (l <= h) {
      var m = l + h >>> 1, x = a[m];
      if (c(x, y) >= 0) {
        i = m;
        h = m - 1;
      } else {
        l = m + 1;
      }
    }
    return i;
  }
  function dispatchBsearchGE(a, y, c, l, h) {
    if (typeof c === "function") {
      return _GEP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
    } else {
      return _GEA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
    }
  }
  function _GTA(a, l, h, y) {
    var i = h + 1;
    while (l <= h) {
      var m = l + h >>> 1, x = a[m];
      if (x > y) {
        i = m;
        h = m - 1;
      } else {
        l = m + 1;
      }
    }
    return i;
  }
  function _GTP(a, l, h, y, c) {
    var i = h + 1;
    while (l <= h) {
      var m = l + h >>> 1, x = a[m];
      if (c(x, y) > 0) {
        i = m;
        h = m - 1;
      } else {
        l = m + 1;
      }
    }
    return i;
  }
  function dispatchBsearchGT(a, y, c, l, h) {
    if (typeof c === "function") {
      return _GTP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
    } else {
      return _GTA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
    }
  }
  function _LTA(a, l, h, y) {
    var i = l - 1;
    while (l <= h) {
      var m = l + h >>> 1, x = a[m];
      if (x < y) {
        i = m;
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return i;
  }
  function _LTP(a, l, h, y, c) {
    var i = l - 1;
    while (l <= h) {
      var m = l + h >>> 1, x = a[m];
      if (c(x, y) < 0) {
        i = m;
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return i;
  }
  function dispatchBsearchLT(a, y, c, l, h) {
    if (typeof c === "function") {
      return _LTP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
    } else {
      return _LTA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
    }
  }
  function _LEA(a, l, h, y) {
    var i = l - 1;
    while (l <= h) {
      var m = l + h >>> 1, x = a[m];
      if (x <= y) {
        i = m;
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return i;
  }
  function _LEP(a, l, h, y, c) {
    var i = l - 1;
    while (l <= h) {
      var m = l + h >>> 1, x = a[m];
      if (c(x, y) <= 0) {
        i = m;
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return i;
  }
  function dispatchBsearchLE(a, y, c, l, h) {
    if (typeof c === "function") {
      return _LEP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
    } else {
      return _LEA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
    }
  }
  function _EQA(a, l, h, y) {
    l - 1;
    while (l <= h) {
      var m = l + h >>> 1, x = a[m];
      if (x === y) {
        return m;
      } else if (x <= y) {
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return -1;
  }
  function _EQP(a, l, h, y, c) {
    l - 1;
    while (l <= h) {
      var m = l + h >>> 1, x = a[m];
      var p = c(x, y);
      if (p === 0) {
        return m;
      } else if (p <= 0) {
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return -1;
  }
  function dispatchBsearchEQ(a, y, c, l, h) {
    if (typeof c === "function") {
      return _EQP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
    } else {
      return _EQA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
    }
  }
  var binarySearchBounds_default = {
    ge: dispatchBsearchGE,
    gt: dispatchBsearchGT,
    lt: dispatchBsearchLT,
    le: dispatchBsearchLE,
    eq: dispatchBsearchEQ
  };

  // node_modules/react-virtualized/dist/es/vendor/intervalTree.js
  var NOT_FOUND = 0;
  var SUCCESS = 1;
  var EMPTY = 2;
  function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
    this.mid = mid;
    this.left = left;
    this.right = right;
    this.leftPoints = leftPoints;
    this.rightPoints = rightPoints;
    this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;
  }
  var proto = IntervalTreeNode.prototype;
  function copy(a, b) {
    a.mid = b.mid;
    a.left = b.left;
    a.right = b.right;
    a.leftPoints = b.leftPoints;
    a.rightPoints = b.rightPoints;
    a.count = b.count;
  }
  function rebuild(node, intervals) {
    var ntree = createIntervalTree(intervals);
    node.mid = ntree.mid;
    node.left = ntree.left;
    node.right = ntree.right;
    node.leftPoints = ntree.leftPoints;
    node.rightPoints = ntree.rightPoints;
    node.count = ntree.count;
  }
  function rebuildWithInterval(node, interval) {
    var intervals = node.intervals([]);
    intervals.push(interval);
    rebuild(node, intervals);
  }
  function rebuildWithoutInterval(node, interval) {
    var intervals = node.intervals([]);
    var idx = intervals.indexOf(interval);
    if (idx < 0) {
      return NOT_FOUND;
    }
    intervals.splice(idx, 1);
    rebuild(node, intervals);
    return SUCCESS;
  }
  proto.intervals = function(result2) {
    result2.push.apply(result2, this.leftPoints);
    if (this.left) {
      this.left.intervals(result2);
    }
    if (this.right) {
      this.right.intervals(result2);
    }
    return result2;
  };
  proto.insert = function(interval) {
    var weight = this.count - this.leftPoints.length;
    this.count += 1;
    if (interval[1] < this.mid) {
      if (this.left) {
        if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
          rebuildWithInterval(this, interval);
        } else {
          this.left.insert(interval);
        }
      } else {
        this.left = createIntervalTree([interval]);
      }
    } else if (interval[0] > this.mid) {
      if (this.right) {
        if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
          rebuildWithInterval(this, interval);
        } else {
          this.right.insert(interval);
        }
      } else {
        this.right = createIntervalTree([interval]);
      }
    } else {
      var l = binarySearchBounds_default.ge(this.leftPoints, interval, compareBegin);
      var r2 = binarySearchBounds_default.ge(this.rightPoints, interval, compareEnd);
      this.leftPoints.splice(l, 0, interval);
      this.rightPoints.splice(r2, 0, interval);
    }
  };
  proto.remove = function(interval) {
    var weight = this.count - this.leftPoints;
    if (interval[1] < this.mid) {
      if (!this.left) {
        return NOT_FOUND;
      }
      var rw = this.right ? this.right.count : 0;
      if (4 * rw > 3 * (weight - 1)) {
        return rebuildWithoutInterval(this, interval);
      }
      var r2 = this.left.remove(interval);
      if (r2 === EMPTY) {
        this.left = null;
        this.count -= 1;
        return SUCCESS;
      } else if (r2 === SUCCESS) {
        this.count -= 1;
      }
      return r2;
    } else if (interval[0] > this.mid) {
      if (!this.right) {
        return NOT_FOUND;
      }
      var lw = this.left ? this.left.count : 0;
      if (4 * lw > 3 * (weight - 1)) {
        return rebuildWithoutInterval(this, interval);
      }
      var r2 = this.right.remove(interval);
      if (r2 === EMPTY) {
        this.right = null;
        this.count -= 1;
        return SUCCESS;
      } else if (r2 === SUCCESS) {
        this.count -= 1;
      }
      return r2;
    } else {
      if (this.count === 1) {
        if (this.leftPoints[0] === interval) {
          return EMPTY;
        } else {
          return NOT_FOUND;
        }
      }
      if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
        if (this.left && this.right) {
          var p = this;
          var n = this.left;
          while (n.right) {
            p = n;
            n = n.right;
          }
          if (p === this) {
            n.right = this.right;
          } else {
            var l = this.left;
            var r2 = this.right;
            p.count -= n.count;
            p.right = n.left;
            n.left = l;
            n.right = r2;
          }
          copy(this, n);
          this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
        } else if (this.left) {
          copy(this, this.left);
        } else {
          copy(this, this.right);
        }
        return SUCCESS;
      }
      for (var l = binarySearchBounds_default.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {
        if (this.leftPoints[l][0] !== interval[0]) {
          break;
        }
        if (this.leftPoints[l] === interval) {
          this.count -= 1;
          this.leftPoints.splice(l, 1);
          for (var r2 = binarySearchBounds_default.ge(this.rightPoints, interval, compareEnd); r2 < this.rightPoints.length; ++r2) {
            if (this.rightPoints[r2][1] !== interval[1]) {
              break;
            } else if (this.rightPoints[r2] === interval) {
              this.rightPoints.splice(r2, 1);
              return SUCCESS;
            }
          }
        }
      }
      return NOT_FOUND;
    }
  };
  function reportLeftRange(arr, hi, cb) {
    for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
      var r2 = cb(arr[i]);
      if (r2) {
        return r2;
      }
    }
  }
  function reportRightRange(arr, lo, cb) {
    for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
      var r2 = cb(arr[i]);
      if (r2) {
        return r2;
      }
    }
  }
  function reportRange(arr, cb) {
    for (var i = 0; i < arr.length; ++i) {
      var r2 = cb(arr[i]);
      if (r2) {
        return r2;
      }
    }
  }
  proto.queryPoint = function(x, cb) {
    if (x < this.mid) {
      if (this.left) {
        var r2 = this.left.queryPoint(x, cb);
        if (r2) {
          return r2;
        }
      }
      return reportLeftRange(this.leftPoints, x, cb);
    } else if (x > this.mid) {
      if (this.right) {
        var r2 = this.right.queryPoint(x, cb);
        if (r2) {
          return r2;
        }
      }
      return reportRightRange(this.rightPoints, x, cb);
    } else {
      return reportRange(this.leftPoints, cb);
    }
  };
  proto.queryInterval = function(lo, hi, cb) {
    if (lo < this.mid && this.left) {
      var r2 = this.left.queryInterval(lo, hi, cb);
      if (r2) {
        return r2;
      }
    }
    if (hi > this.mid && this.right) {
      var r2 = this.right.queryInterval(lo, hi, cb);
      if (r2) {
        return r2;
      }
    }
    if (hi < this.mid) {
      return reportLeftRange(this.leftPoints, hi, cb);
    } else if (lo > this.mid) {
      return reportRightRange(this.rightPoints, lo, cb);
    } else {
      return reportRange(this.leftPoints, cb);
    }
  };
  function compareNumbers(a, b) {
    return a - b;
  }
  function compareBegin(a, b) {
    var d = a[0] - b[0];
    if (d) {
      return d;
    }
    return a[1] - b[1];
  }
  function compareEnd(a, b) {
    var d = a[1] - b[1];
    if (d) {
      return d;
    }
    return a[0] - b[0];
  }
  function createIntervalTree(intervals) {
    if (intervals.length === 0) {
      return null;
    }
    var pts = [];
    for (var i = 0; i < intervals.length; ++i) {
      pts.push(intervals[i][0], intervals[i][1]);
    }
    pts.sort(compareNumbers);
    var mid = pts[pts.length >> 1];
    var leftIntervals = [];
    var rightIntervals = [];
    var centerIntervals = [];
    for (var i = 0; i < intervals.length; ++i) {
      var s = intervals[i];
      if (s[1] < mid) {
        leftIntervals.push(s);
      } else if (mid < s[0]) {
        rightIntervals.push(s);
      } else {
        centerIntervals.push(s);
      }
    }
    var leftPoints = centerIntervals;
    var rightPoints = centerIntervals.slice();
    leftPoints.sort(compareBegin);
    rightPoints.sort(compareEnd);
    return new IntervalTreeNode(mid, createIntervalTree(leftIntervals), createIntervalTree(rightIntervals), leftPoints, rightPoints);
  }
  function IntervalTree(root2) {
    this.root = root2;
  }
  var tproto = IntervalTree.prototype;
  tproto.insert = function(interval) {
    if (this.root) {
      this.root.insert(interval);
    } else {
      this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);
    }
  };
  tproto.remove = function(interval) {
    if (this.root) {
      var r2 = this.root.remove(interval);
      if (r2 === EMPTY) {
        this.root = null;
      }
      return r2 !== NOT_FOUND;
    }
    return false;
  };
  tproto.queryPoint = function(p, cb) {
    if (this.root) {
      return this.root.queryPoint(p, cb);
    }
  };
  tproto.queryInterval = function(lo, hi, cb) {
    if (lo <= hi && this.root) {
      return this.root.queryInterval(lo, hi, cb);
    }
  };
  Object.defineProperty(tproto, "count", {
    get: function get2() {
      if (this.root) {
        return this.root.count;
      }
      return 0;
    }
  });
  Object.defineProperty(tproto, "intervals", {
    get: function get3() {
      if (this.root) {
        return this.root.intervals([]);
      }
      return [];
    }
  });
  function createWrapper(intervals) {
    if (!intervals || intervals.length === 0) {
      return new IntervalTree(null);
    }
    return new IntervalTree(createIntervalTree(intervals));
  }

  // node_modules/react-virtualized/dist/es/Masonry/PositionCache.js
  var PositionCache = /* @__PURE__ */ function() {
    function PositionCache2() {
      (0, import_classCallCheck15.default)(this, PositionCache2);
      (0, import_defineProperty12.default)(this, "_columnSizeMap", {});
      (0, import_defineProperty12.default)(this, "_intervalTree", createWrapper());
      (0, import_defineProperty12.default)(this, "_leftMap", {});
    }
    (0, import_createClass15.default)(PositionCache2, [{
      key: "estimateTotalHeight",
      value: function estimateTotalHeight(cellCount, columnCount, defaultCellHeight) {
        var unmeasuredCellCount = cellCount - this.count;
        return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;
      }
    }, {
      key: "range",
      value: function range(scrollTop, clientHeight, renderCallback) {
        var _this = this;
        this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function(_ref) {
          var _ref2 = (0, import_slicedToArray.default)(_ref, 3), top = _ref2[0], _ = _ref2[1], index2 = _ref2[2];
          return renderCallback(index2, _this._leftMap[index2], top);
        });
      }
    }, {
      key: "setPosition",
      value: function setPosition(index2, left, top, height) {
        this._intervalTree.insert([top, top + height, index2]);
        this._leftMap[index2] = left;
        var columnSizeMap = this._columnSizeMap;
        var columnHeight = columnSizeMap[left];
        if (columnHeight === void 0) {
          columnSizeMap[left] = top + height;
        } else {
          columnSizeMap[left] = Math.max(columnHeight, top + height);
        }
      }
    }, {
      key: "count",
      get: function get4() {
        return this._intervalTree.count;
      }
    }, {
      key: "shortestColumnSize",
      get: function get4() {
        var columnSizeMap = this._columnSizeMap;
        var size2 = 0;
        for (var i in columnSizeMap) {
          var height = columnSizeMap[i];
          size2 = size2 === 0 ? height : Math.min(size2, height);
        }
        return size2;
      }
    }, {
      key: "tallestColumnSize",
      get: function get4() {
        var columnSizeMap = this._columnSizeMap;
        var size2 = 0;
        for (var i in columnSizeMap) {
          var height = columnSizeMap[i];
          size2 = Math.max(size2, height);
        }
        return size2;
      }
    }]);
    return PositionCache2;
  }();

  // node_modules/react-virtualized/dist/es/Masonry/Masonry.js
  var import_prop_types23 = __toESM(require_prop_types());
  var _class6;
  var _temp6;
  function ownKeys6(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread6(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys6(source, true).forEach(function(key) {
          (0, import_defineProperty13.default)(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys6(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var emptyObject = {};
  var DEFAULT_SCROLLING_RESET_TIME_INTERVAL2 = 150;
  var Masonry = (_temp6 = _class6 = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits10.default)(Masonry2, _React$PureComponent);
    function Masonry2() {
      var _getPrototypeOf22;
      var _this;
      (0, import_classCallCheck16.default)(this, Masonry2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = (0, import_possibleConstructorReturn10.default)(this, (_getPrototypeOf22 = (0, import_getPrototypeOf10.default)(Masonry2)).call.apply(_getPrototypeOf22, [this].concat(args)));
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "state", {
        isScrolling: false,
        scrollTop: 0
      });
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_debounceResetIsScrollingId", void 0);
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_invalidateOnUpdateStartIndex", null);
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_invalidateOnUpdateStopIndex", null);
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_positionCache", new PositionCache());
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_startIndex", null);
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_startIndexMemoized", null);
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_stopIndex", null);
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_stopIndexMemoized", null);
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_debounceResetIsScrollingCallback", function() {
        _this.setState({
          isScrolling: false
        });
      });
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_setScrollingContainerRef", function(ref) {
        _this._scrollingContainer = ref;
      });
      (0, import_defineProperty13.default)((0, import_assertThisInitialized11.default)(_this), "_onScroll", function(event) {
        var height = _this.props.height;
        var eventScrollTop = event.currentTarget.scrollTop;
        var scrollTop = Math.min(Math.max(0, _this._getEstimatedTotalHeight() - height), eventScrollTop);
        if (eventScrollTop !== scrollTop) {
          return;
        }
        _this._debounceResetIsScrolling();
        if (_this.state.scrollTop !== scrollTop) {
          _this.setState({
            isScrolling: true,
            scrollTop
          });
        }
      });
      return _this;
    }
    (0, import_createClass16.default)(Masonry2, [{
      key: "clearCellPositions",
      value: function clearCellPositions() {
        this._positionCache = new PositionCache();
        this.forceUpdate();
      }
    }, {
      key: "invalidateCellSizeAfterRender",
      value: function invalidateCellSizeAfterRender(_ref) {
        var index2 = _ref.rowIndex;
        if (this._invalidateOnUpdateStartIndex === null) {
          this._invalidateOnUpdateStartIndex = index2;
          this._invalidateOnUpdateStopIndex = index2;
        } else {
          this._invalidateOnUpdateStartIndex = Math.min(this._invalidateOnUpdateStartIndex, index2);
          this._invalidateOnUpdateStopIndex = Math.max(this._invalidateOnUpdateStopIndex, index2);
        }
      }
    }, {
      key: "recomputeCellPositions",
      value: function recomputeCellPositions() {
        var stopIndex = this._positionCache.count - 1;
        this._positionCache = new PositionCache();
        this._populatePositionCache(0, stopIndex);
        this.forceUpdate();
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._checkInvalidateOnUpdate();
        this._invokeOnScrollCallback();
        this._invokeOnCellsRenderedCallback();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        this._checkInvalidateOnUpdate();
        this._invokeOnScrollCallback();
        this._invokeOnCellsRenderedCallback();
        if (this.props.scrollTop !== prevProps.scrollTop) {
          this._debounceResetIsScrolling();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._debounceResetIsScrollingId) {
          cancelAnimationTimeout(this._debounceResetIsScrollingId);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$props = this.props, autoHeight = _this$props.autoHeight, cellCount = _this$props.cellCount, cellMeasurerCache2 = _this$props.cellMeasurerCache, cellRenderer3 = _this$props.cellRenderer, className = _this$props.className, height = _this$props.height, id = _this$props.id, keyMapper2 = _this$props.keyMapper, overscanByPixels = _this$props.overscanByPixels, role = _this$props.role, style4 = _this$props.style, tabIndex = _this$props.tabIndex, width = _this$props.width, rowDirection = _this$props.rowDirection;
        var _this$state = this.state, isScrolling = _this$state.isScrolling, scrollTop = _this$state.scrollTop;
        var children2 = [];
        var estimateTotalHeight = this._getEstimatedTotalHeight();
        var shortestColumnSize = this._positionCache.shortestColumnSize;
        var measuredCellCount = this._positionCache.count;
        var startIndex = 0;
        var stopIndex;
        this._positionCache.range(Math.max(0, scrollTop - overscanByPixels), height + overscanByPixels * 2, function(index2, left, top) {
          var _style;
          if (typeof stopIndex === "undefined") {
            startIndex = index2;
            stopIndex = index2;
          } else {
            startIndex = Math.min(startIndex, index2);
            stopIndex = Math.max(stopIndex, index2);
          }
          children2.push(cellRenderer3({
            index: index2,
            isScrolling,
            key: keyMapper2(index2),
            parent: _this2,
            style: (_style = {
              height: cellMeasurerCache2.getHeight(index2)
            }, (0, import_defineProperty13.default)(_style, rowDirection === "ltr" ? "left" : "right", left), (0, import_defineProperty13.default)(_style, "position", "absolute"), (0, import_defineProperty13.default)(_style, "top", top), (0, import_defineProperty13.default)(_style, "width", cellMeasurerCache2.getWidth(index2)), _style)
          }));
        });
        if (shortestColumnSize < scrollTop + height + overscanByPixels && measuredCellCount < cellCount) {
          var batchSize = Math.min(cellCount - measuredCellCount, Math.ceil((scrollTop + height + overscanByPixels - shortestColumnSize) / cellMeasurerCache2.defaultHeight * width / cellMeasurerCache2.defaultWidth));
          for (var _index = measuredCellCount; _index < measuredCellCount + batchSize; _index++) {
            stopIndex = _index;
            children2.push(cellRenderer3({
              index: _index,
              isScrolling,
              key: keyMapper2(_index),
              parent: this,
              style: {
                width: cellMeasurerCache2.getWidth(_index)
              }
            }));
          }
        }
        this._startIndex = startIndex;
        this._stopIndex = stopIndex;
        return React89.createElement("div", {
          ref: this._setScrollingContainerRef,
          "aria-label": this.props["aria-label"],
          className: clsx_m_default("ReactVirtualized__Masonry", className),
          id,
          onScroll: this._onScroll,
          role,
          style: _objectSpread6({
            boxSizing: "border-box",
            direction: "ltr",
            height: autoHeight ? "auto" : height,
            overflowX: "hidden",
            overflowY: estimateTotalHeight < height ? "hidden" : "auto",
            position: "relative",
            width,
            WebkitOverflowScrolling: "touch",
            willChange: "transform"
          }, style4),
          tabIndex
        }, React89.createElement("div", {
          className: "ReactVirtualized__Masonry__innerScrollContainer",
          style: {
            width: "100%",
            height: estimateTotalHeight,
            maxWidth: "100%",
            maxHeight: estimateTotalHeight,
            overflow: "hidden",
            pointerEvents: isScrolling ? "none" : "",
            position: "relative"
          }
        }, children2));
      }
    }, {
      key: "_checkInvalidateOnUpdate",
      value: function _checkInvalidateOnUpdate() {
        if (typeof this._invalidateOnUpdateStartIndex === "number") {
          var startIndex = this._invalidateOnUpdateStartIndex;
          var stopIndex = this._invalidateOnUpdateStopIndex;
          this._invalidateOnUpdateStartIndex = null;
          this._invalidateOnUpdateStopIndex = null;
          this._populatePositionCache(startIndex, stopIndex);
          this.forceUpdate();
        }
      }
    }, {
      key: "_debounceResetIsScrolling",
      value: function _debounceResetIsScrolling() {
        var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;
        if (this._debounceResetIsScrollingId) {
          cancelAnimationTimeout(this._debounceResetIsScrollingId);
        }
        this._debounceResetIsScrollingId = requestAnimationTimeout(this._debounceResetIsScrollingCallback, scrollingResetTimeInterval);
      }
    }, {
      key: "_getEstimatedTotalHeight",
      value: function _getEstimatedTotalHeight() {
        var _this$props2 = this.props, cellCount = _this$props2.cellCount, cellMeasurerCache2 = _this$props2.cellMeasurerCache, width = _this$props2.width;
        var estimatedColumnCount = Math.max(1, Math.floor(width / cellMeasurerCache2.defaultWidth));
        return this._positionCache.estimateTotalHeight(cellCount, estimatedColumnCount, cellMeasurerCache2.defaultHeight);
      }
    }, {
      key: "_invokeOnScrollCallback",
      value: function _invokeOnScrollCallback() {
        var _this$props3 = this.props, height = _this$props3.height, onScroll7 = _this$props3.onScroll;
        var scrollTop = this.state.scrollTop;
        if (this._onScrollMemoized !== scrollTop) {
          onScroll7({
            clientHeight: height,
            scrollHeight: this._getEstimatedTotalHeight(),
            scrollTop
          });
          this._onScrollMemoized = scrollTop;
        }
      }
    }, {
      key: "_invokeOnCellsRenderedCallback",
      value: function _invokeOnCellsRenderedCallback() {
        if (this._startIndexMemoized !== this._startIndex || this._stopIndexMemoized !== this._stopIndex) {
          var onCellsRendered2 = this.props.onCellsRendered;
          onCellsRendered2({
            startIndex: this._startIndex,
            stopIndex: this._stopIndex
          });
          this._startIndexMemoized = this._startIndex;
          this._stopIndexMemoized = this._stopIndex;
        }
      }
    }, {
      key: "_populatePositionCache",
      value: function _populatePositionCache(startIndex, stopIndex) {
        var _this$props4 = this.props, cellMeasurerCache2 = _this$props4.cellMeasurerCache, cellPositioner2 = _this$props4.cellPositioner;
        for (var _index2 = startIndex; _index2 <= stopIndex; _index2++) {
          var _cellPositioner = cellPositioner2(_index2), left = _cellPositioner.left, top = _cellPositioner.top;
          this._positionCache.setPosition(_index2, left, top, cellMeasurerCache2.getHeight(_index2));
        }
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, prevState) {
        if (nextProps.scrollTop !== void 0 && prevState.scrollTop !== nextProps.scrollTop) {
          return {
            isScrolling: true,
            scrollTop: nextProps.scrollTop
          };
        }
        return null;
      }
    }]);
    return Masonry2;
  }(React89.PureComponent), (0, import_defineProperty13.default)(_class6, "propTypes", false ? null : {
    "autoHeight": import_prop_types23.default.bool.isRequired,
    "cellCount": import_prop_types23.default.number.isRequired,
    "cellMeasurerCache": function cellMeasurerCache() {
      return (typeof CellMeasurerCache === "function" ? import_prop_types23.default.instanceOf(CellMeasurerCache).isRequired : import_prop_types23.default.any.isRequired).apply(this, arguments);
    },
    "cellPositioner": function cellPositioner() {
      return (typeof Positioner === "function" ? import_prop_types23.default.instanceOf(Positioner).isRequired : import_prop_types23.default.any.isRequired).apply(this, arguments);
    },
    "cellRenderer": function cellRenderer2() {
      return (typeof CellRenderer === "function" ? import_prop_types23.default.instanceOf(CellRenderer).isRequired : import_prop_types23.default.any.isRequired).apply(this, arguments);
    },
    "className": import_prop_types23.default.string,
    "height": import_prop_types23.default.number.isRequired,
    "id": import_prop_types23.default.string,
    "keyMapper": function keyMapper() {
      return (typeof KeyMapper === "function" ? import_prop_types23.default.instanceOf(KeyMapper).isRequired : import_prop_types23.default.any.isRequired).apply(this, arguments);
    },
    "onCellsRendered": function onCellsRendered() {
      return (typeof OnCellsRenderedCallback === "function" ? import_prop_types23.default.instanceOf(OnCellsRenderedCallback) : import_prop_types23.default.any).apply(this, arguments);
    },
    "onScroll": function onScroll4() {
      return (typeof OnScrollCallback === "function" ? import_prop_types23.default.instanceOf(OnScrollCallback) : import_prop_types23.default.any).apply(this, arguments);
    },
    "overscanByPixels": import_prop_types23.default.number.isRequired,
    "role": import_prop_types23.default.string.isRequired,
    "scrollingResetTimeInterval": import_prop_types23.default.number.isRequired,
    "style": function style(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
      }
    },
    "tabIndex": import_prop_types23.default.number.isRequired,
    "width": import_prop_types23.default.number.isRequired,
    "rowDirection": import_prop_types23.default.string.isRequired,
    "scrollTop": import_prop_types23.default.number
  }), _temp6);
  (0, import_defineProperty13.default)(Masonry, "defaultProps", {
    autoHeight: false,
    keyMapper: identity,
    onCellsRendered: noop5,
    onScroll: noop5,
    overscanByPixels: 20,
    role: "grid",
    scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL2,
    style: emptyObject,
    tabIndex: 0,
    rowDirection: "ltr"
  });
  function identity(value) {
    return value;
  }
  function noop5() {
  }
  var bpfrpt_proptype_CellMeasurerCache = false ? null : {
    "defaultHeight": import_prop_types23.default.number.isRequired,
    "defaultWidth": import_prop_types23.default.number.isRequired,
    "getHeight": import_prop_types23.default.func.isRequired,
    "getWidth": import_prop_types23.default.func.isRequired
  };
  polyfill(Masonry);
  var bpfrpt_proptype_Positioner = false ? null : import_prop_types23.default.func;

  // node_modules/react-virtualized/dist/es/MultiGrid/MultiGrid.js
  var import_extends9 = __toESM(require_extends());
  var import_objectWithoutProperties2 = __toESM(require_objectWithoutProperties());
  var import_classCallCheck18 = __toESM(require_classCallCheck());
  var import_createClass18 = __toESM(require_createClass());
  var import_possibleConstructorReturn11 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf11 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized12 = __toESM(require_assertThisInitialized());
  var import_inherits11 = __toESM(require_inherits());
  var import_defineProperty15 = __toESM(require_defineProperty());
  var import_prop_types24 = __toESM(require_prop_types());
  var React90 = __toESM(require_react());

  // node_modules/react-virtualized/dist/es/MultiGrid/CellMeasurerCacheDecorator.js
  var import_classCallCheck17 = __toESM(require_classCallCheck());
  var import_createClass17 = __toESM(require_createClass());
  var import_defineProperty14 = __toESM(require_defineProperty());
  var CellMeasurerCacheDecorator = /* @__PURE__ */ function() {
    function CellMeasurerCacheDecorator2() {
      var _this = this;
      var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      (0, import_classCallCheck17.default)(this, CellMeasurerCacheDecorator2);
      (0, import_defineProperty14.default)(this, "_cellMeasurerCache", void 0);
      (0, import_defineProperty14.default)(this, "_columnIndexOffset", void 0);
      (0, import_defineProperty14.default)(this, "_rowIndexOffset", void 0);
      (0, import_defineProperty14.default)(this, "columnWidth", function(_ref) {
        var index2 = _ref.index;
        _this._cellMeasurerCache.columnWidth({
          index: index2 + _this._columnIndexOffset
        });
      });
      (0, import_defineProperty14.default)(this, "rowHeight", function(_ref2) {
        var index2 = _ref2.index;
        _this._cellMeasurerCache.rowHeight({
          index: index2 + _this._rowIndexOffset
        });
      });
      var cellMeasurerCache2 = params.cellMeasurerCache, _params$columnIndexOf = params.columnIndexOffset, columnIndexOffset = _params$columnIndexOf === void 0 ? 0 : _params$columnIndexOf, _params$rowIndexOffse = params.rowIndexOffset, rowIndexOffset = _params$rowIndexOffse === void 0 ? 0 : _params$rowIndexOffse;
      this._cellMeasurerCache = cellMeasurerCache2;
      this._columnIndexOffset = columnIndexOffset;
      this._rowIndexOffset = rowIndexOffset;
    }
    (0, import_createClass17.default)(CellMeasurerCacheDecorator2, [{
      key: "clear",
      value: function clear(rowIndex, columnIndex) {
        this._cellMeasurerCache.clear(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
      }
    }, {
      key: "clearAll",
      value: function clearAll() {
        this._cellMeasurerCache.clearAll();
      }
    }, {
      key: "hasFixedHeight",
      value: function hasFixedHeight() {
        return this._cellMeasurerCache.hasFixedHeight();
      }
    }, {
      key: "hasFixedWidth",
      value: function hasFixedWidth() {
        return this._cellMeasurerCache.hasFixedWidth();
      }
    }, {
      key: "getHeight",
      value: function getHeight(rowIndex) {
        var columnIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this._cellMeasurerCache.getHeight(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
      }
    }, {
      key: "getWidth",
      value: function getWidth2(rowIndex) {
        var columnIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this._cellMeasurerCache.getWidth(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
      }
    }, {
      key: "has",
      value: function has(rowIndex) {
        var columnIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this._cellMeasurerCache.has(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
      }
    }, {
      key: "set",
      value: function set(rowIndex, columnIndex, width, height) {
        this._cellMeasurerCache.set(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset, width, height);
      }
    }, {
      key: "defaultHeight",
      get: function get4() {
        return this._cellMeasurerCache.defaultHeight;
      }
    }, {
      key: "defaultWidth",
      get: function get4() {
        return this._cellMeasurerCache.defaultWidth;
      }
    }]);
    return CellMeasurerCacheDecorator2;
  }();

  // node_modules/react-virtualized/dist/es/MultiGrid/MultiGrid.js
  function ownKeys7(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread7(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys7(source, true).forEach(function(key) {
          (0, import_defineProperty15.default)(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys7(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var SCROLLBAR_SIZE_BUFFER = 20;
  var MultiGrid = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits11.default)(MultiGrid2, _React$PureComponent);
    function MultiGrid2(props, context2) {
      var _this;
      (0, import_classCallCheck18.default)(this, MultiGrid2);
      _this = (0, import_possibleConstructorReturn11.default)(this, (0, import_getPrototypeOf11.default)(MultiGrid2).call(this, props, context2));
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "state", {
        scrollLeft: 0,
        scrollTop: 0,
        scrollbarSize: 0,
        showHorizontalScrollbar: false,
        showVerticalScrollbar: false
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_deferredInvalidateColumnIndex", null);
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_deferredInvalidateRowIndex", null);
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_bottomLeftGridRef", function(ref) {
        _this._bottomLeftGrid = ref;
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_bottomRightGridRef", function(ref) {
        _this._bottomRightGrid = ref;
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_cellRendererBottomLeftGrid", function(_ref) {
        var rowIndex = _ref.rowIndex, rest = (0, import_objectWithoutProperties2.default)(_ref, ["rowIndex"]);
        var _this$props = _this.props, cellRenderer3 = _this$props.cellRenderer, fixedRowCount = _this$props.fixedRowCount, rowCount = _this$props.rowCount;
        if (rowIndex === rowCount - fixedRowCount) {
          return React90.createElement("div", {
            key: rest.key,
            style: _objectSpread7({}, rest.style, {
              height: SCROLLBAR_SIZE_BUFFER
            })
          });
        } else {
          return cellRenderer3(_objectSpread7({}, rest, {
            parent: (0, import_assertThisInitialized12.default)(_this),
            rowIndex: rowIndex + fixedRowCount
          }));
        }
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_cellRendererBottomRightGrid", function(_ref2) {
        var columnIndex = _ref2.columnIndex, rowIndex = _ref2.rowIndex, rest = (0, import_objectWithoutProperties2.default)(_ref2, ["columnIndex", "rowIndex"]);
        var _this$props2 = _this.props, cellRenderer3 = _this$props2.cellRenderer, fixedColumnCount = _this$props2.fixedColumnCount, fixedRowCount = _this$props2.fixedRowCount;
        return cellRenderer3(_objectSpread7({}, rest, {
          columnIndex: columnIndex + fixedColumnCount,
          parent: (0, import_assertThisInitialized12.default)(_this),
          rowIndex: rowIndex + fixedRowCount
        }));
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_cellRendererTopRightGrid", function(_ref3) {
        var columnIndex = _ref3.columnIndex, rest = (0, import_objectWithoutProperties2.default)(_ref3, ["columnIndex"]);
        var _this$props3 = _this.props, cellRenderer3 = _this$props3.cellRenderer, columnCount = _this$props3.columnCount, fixedColumnCount = _this$props3.fixedColumnCount;
        if (columnIndex === columnCount - fixedColumnCount) {
          return React90.createElement("div", {
            key: rest.key,
            style: _objectSpread7({}, rest.style, {
              width: SCROLLBAR_SIZE_BUFFER
            })
          });
        } else {
          return cellRenderer3(_objectSpread7({}, rest, {
            columnIndex: columnIndex + fixedColumnCount,
            parent: (0, import_assertThisInitialized12.default)(_this)
          }));
        }
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_columnWidthRightGrid", function(_ref4) {
        var index2 = _ref4.index;
        var _this$props4 = _this.props, columnCount = _this$props4.columnCount, fixedColumnCount = _this$props4.fixedColumnCount, columnWidth2 = _this$props4.columnWidth;
        var _this$state = _this.state, scrollbarSize2 = _this$state.scrollbarSize, showHorizontalScrollbar = _this$state.showHorizontalScrollbar;
        if (showHorizontalScrollbar && index2 === columnCount - fixedColumnCount) {
          return scrollbarSize2;
        }
        return typeof columnWidth2 === "function" ? columnWidth2({
          index: index2 + fixedColumnCount
        }) : columnWidth2;
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_onScroll", function(scrollInfo) {
        var scrollLeft = scrollInfo.scrollLeft, scrollTop = scrollInfo.scrollTop;
        _this.setState({
          scrollLeft,
          scrollTop
        });
        var onScroll7 = _this.props.onScroll;
        if (onScroll7) {
          onScroll7(scrollInfo);
        }
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_onScrollbarPresenceChange", function(_ref5) {
        var horizontal = _ref5.horizontal, size2 = _ref5.size, vertical = _ref5.vertical;
        var _this$state2 = _this.state, showHorizontalScrollbar = _this$state2.showHorizontalScrollbar, showVerticalScrollbar = _this$state2.showVerticalScrollbar;
        if (horizontal !== showHorizontalScrollbar || vertical !== showVerticalScrollbar) {
          _this.setState({
            scrollbarSize: size2,
            showHorizontalScrollbar: horizontal,
            showVerticalScrollbar: vertical
          });
          var onScrollbarPresenceChange2 = _this.props.onScrollbarPresenceChange;
          if (typeof onScrollbarPresenceChange2 === "function") {
            onScrollbarPresenceChange2({
              horizontal,
              size: size2,
              vertical
            });
          }
        }
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_onScrollLeft", function(scrollInfo) {
        var scrollLeft = scrollInfo.scrollLeft;
        _this._onScroll({
          scrollLeft,
          scrollTop: _this.state.scrollTop
        });
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_onScrollTop", function(scrollInfo) {
        var scrollTop = scrollInfo.scrollTop;
        _this._onScroll({
          scrollTop,
          scrollLeft: _this.state.scrollLeft
        });
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_rowHeightBottomGrid", function(_ref6) {
        var index2 = _ref6.index;
        var _this$props5 = _this.props, fixedRowCount = _this$props5.fixedRowCount, rowCount = _this$props5.rowCount, rowHeight3 = _this$props5.rowHeight;
        var _this$state3 = _this.state, scrollbarSize2 = _this$state3.scrollbarSize, showVerticalScrollbar = _this$state3.showVerticalScrollbar;
        if (showVerticalScrollbar && index2 === rowCount - fixedRowCount) {
          return scrollbarSize2;
        }
        return typeof rowHeight3 === "function" ? rowHeight3({
          index: index2 + fixedRowCount
        }) : rowHeight3;
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_topLeftGridRef", function(ref) {
        _this._topLeftGrid = ref;
      });
      (0, import_defineProperty15.default)((0, import_assertThisInitialized12.default)(_this), "_topRightGridRef", function(ref) {
        _this._topRightGrid = ref;
      });
      var deferredMeasurementCache = props.deferredMeasurementCache, _fixedColumnCount = props.fixedColumnCount, _fixedRowCount = props.fixedRowCount;
      _this._maybeCalculateCachedStyles(true);
      if (deferredMeasurementCache) {
        _this._deferredMeasurementCacheBottomLeftGrid = _fixedRowCount > 0 ? new CellMeasurerCacheDecorator({
          cellMeasurerCache: deferredMeasurementCache,
          columnIndexOffset: 0,
          rowIndexOffset: _fixedRowCount
        }) : deferredMeasurementCache;
        _this._deferredMeasurementCacheBottomRightGrid = _fixedColumnCount > 0 || _fixedRowCount > 0 ? new CellMeasurerCacheDecorator({
          cellMeasurerCache: deferredMeasurementCache,
          columnIndexOffset: _fixedColumnCount,
          rowIndexOffset: _fixedRowCount
        }) : deferredMeasurementCache;
        _this._deferredMeasurementCacheTopRightGrid = _fixedColumnCount > 0 ? new CellMeasurerCacheDecorator({
          cellMeasurerCache: deferredMeasurementCache,
          columnIndexOffset: _fixedColumnCount,
          rowIndexOffset: 0
        }) : deferredMeasurementCache;
      }
      return _this;
    }
    (0, import_createClass18.default)(MultiGrid2, [{
      key: "forceUpdateGrids",
      value: function forceUpdateGrids() {
        this._bottomLeftGrid && this._bottomLeftGrid.forceUpdate();
        this._bottomRightGrid && this._bottomRightGrid.forceUpdate();
        this._topLeftGrid && this._topLeftGrid.forceUpdate();
        this._topRightGrid && this._topRightGrid.forceUpdate();
      }
    }, {
      key: "invalidateCellSizeAfterRender",
      value: function invalidateCellSizeAfterRender() {
        var _ref7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref7$columnIndex = _ref7.columnIndex, columnIndex = _ref7$columnIndex === void 0 ? 0 : _ref7$columnIndex, _ref7$rowIndex = _ref7.rowIndex, rowIndex = _ref7$rowIndex === void 0 ? 0 : _ref7$rowIndex;
        this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === "number" ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;
        this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === "number" ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
      }
    }, {
      key: "measureAllCells",
      value: function measureAllCells() {
        this._bottomLeftGrid && this._bottomLeftGrid.measureAllCells();
        this._bottomRightGrid && this._bottomRightGrid.measureAllCells();
        this._topLeftGrid && this._topLeftGrid.measureAllCells();
        this._topRightGrid && this._topRightGrid.measureAllCells();
      }
    }, {
      key: "recomputeGridSize",
      value: function recomputeGridSize() {
        var _ref8 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref8$columnIndex = _ref8.columnIndex, columnIndex = _ref8$columnIndex === void 0 ? 0 : _ref8$columnIndex, _ref8$rowIndex = _ref8.rowIndex, rowIndex = _ref8$rowIndex === void 0 ? 0 : _ref8$rowIndex;
        var _this$props6 = this.props, fixedColumnCount = _this$props6.fixedColumnCount, fixedRowCount = _this$props6.fixedRowCount;
        var adjustedColumnIndex = Math.max(0, columnIndex - fixedColumnCount);
        var adjustedRowIndex = Math.max(0, rowIndex - fixedRowCount);
        this._bottomLeftGrid && this._bottomLeftGrid.recomputeGridSize({
          columnIndex,
          rowIndex: adjustedRowIndex
        });
        this._bottomRightGrid && this._bottomRightGrid.recomputeGridSize({
          columnIndex: adjustedColumnIndex,
          rowIndex: adjustedRowIndex
        });
        this._topLeftGrid && this._topLeftGrid.recomputeGridSize({
          columnIndex,
          rowIndex
        });
        this._topRightGrid && this._topRightGrid.recomputeGridSize({
          columnIndex: adjustedColumnIndex,
          rowIndex
        });
        this._leftGridWidth = null;
        this._topGridHeight = null;
        this._maybeCalculateCachedStyles(true);
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props7 = this.props, scrollLeft = _this$props7.scrollLeft, scrollTop = _this$props7.scrollTop;
        if (scrollLeft > 0 || scrollTop > 0) {
          var newState = {};
          if (scrollLeft > 0) {
            newState.scrollLeft = scrollLeft;
          }
          if (scrollTop > 0) {
            newState.scrollTop = scrollTop;
          }
          this.setState(newState);
        }
        this._handleInvalidatedGridSize();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this._handleInvalidatedGridSize();
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props8 = this.props, onScroll7 = _this$props8.onScroll, onSectionRendered3 = _this$props8.onSectionRendered, onScrollbarPresenceChange2 = _this$props8.onScrollbarPresenceChange, scrollLeftProp = _this$props8.scrollLeft, scrollToColumn = _this$props8.scrollToColumn, scrollTopProp = _this$props8.scrollTop, scrollToRow = _this$props8.scrollToRow, rest = (0, import_objectWithoutProperties2.default)(_this$props8, ["onScroll", "onSectionRendered", "onScrollbarPresenceChange", "scrollLeft", "scrollToColumn", "scrollTop", "scrollToRow"]);
        this._prepareForRender();
        if (this.props.width === 0 || this.props.height === 0) {
          return null;
        }
        var _this$state4 = this.state, scrollLeft = _this$state4.scrollLeft, scrollTop = _this$state4.scrollTop;
        return React90.createElement("div", {
          style: this._containerOuterStyle
        }, React90.createElement("div", {
          style: this._containerTopStyle
        }, this._renderTopLeftGrid(rest), this._renderTopRightGrid(_objectSpread7({}, rest, {
          onScroll: onScroll7,
          scrollLeft
        }))), React90.createElement("div", {
          style: this._containerBottomStyle
        }, this._renderBottomLeftGrid(_objectSpread7({}, rest, {
          onScroll: onScroll7,
          scrollTop
        })), this._renderBottomRightGrid(_objectSpread7({}, rest, {
          onScroll: onScroll7,
          onSectionRendered: onSectionRendered3,
          scrollLeft,
          scrollToColumn,
          scrollToRow,
          scrollTop
        }))));
      }
    }, {
      key: "_getBottomGridHeight",
      value: function _getBottomGridHeight(props) {
        var height = props.height;
        var topGridHeight = this._getTopGridHeight(props);
        return height - topGridHeight;
      }
    }, {
      key: "_getLeftGridWidth",
      value: function _getLeftGridWidth(props) {
        var fixedColumnCount = props.fixedColumnCount, columnWidth2 = props.columnWidth;
        if (this._leftGridWidth == null) {
          if (typeof columnWidth2 === "function") {
            var leftGridWidth = 0;
            for (var index2 = 0; index2 < fixedColumnCount; index2++) {
              leftGridWidth += columnWidth2({
                index: index2
              });
            }
            this._leftGridWidth = leftGridWidth;
          } else {
            this._leftGridWidth = columnWidth2 * fixedColumnCount;
          }
        }
        return this._leftGridWidth;
      }
    }, {
      key: "_getRightGridWidth",
      value: function _getRightGridWidth(props) {
        var width = props.width;
        var leftGridWidth = this._getLeftGridWidth(props);
        return width - leftGridWidth;
      }
    }, {
      key: "_getTopGridHeight",
      value: function _getTopGridHeight(props) {
        var fixedRowCount = props.fixedRowCount, rowHeight3 = props.rowHeight;
        if (this._topGridHeight == null) {
          if (typeof rowHeight3 === "function") {
            var topGridHeight = 0;
            for (var index2 = 0; index2 < fixedRowCount; index2++) {
              topGridHeight += rowHeight3({
                index: index2
              });
            }
            this._topGridHeight = topGridHeight;
          } else {
            this._topGridHeight = rowHeight3 * fixedRowCount;
          }
        }
        return this._topGridHeight;
      }
    }, {
      key: "_handleInvalidatedGridSize",
      value: function _handleInvalidatedGridSize() {
        if (typeof this._deferredInvalidateColumnIndex === "number") {
          var columnIndex = this._deferredInvalidateColumnIndex;
          var rowIndex = this._deferredInvalidateRowIndex;
          this._deferredInvalidateColumnIndex = null;
          this._deferredInvalidateRowIndex = null;
          this.recomputeGridSize({
            columnIndex,
            rowIndex
          });
          this.forceUpdate();
        }
      }
    }, {
      key: "_maybeCalculateCachedStyles",
      value: function _maybeCalculateCachedStyles(resetAll) {
        var _this$props9 = this.props, columnWidth2 = _this$props9.columnWidth, enableFixedColumnScroll = _this$props9.enableFixedColumnScroll, enableFixedRowScroll = _this$props9.enableFixedRowScroll, height = _this$props9.height, fixedColumnCount = _this$props9.fixedColumnCount, fixedRowCount = _this$props9.fixedRowCount, rowHeight3 = _this$props9.rowHeight, style4 = _this$props9.style, styleBottomLeftGrid = _this$props9.styleBottomLeftGrid, styleBottomRightGrid = _this$props9.styleBottomRightGrid, styleTopLeftGrid = _this$props9.styleTopLeftGrid, styleTopRightGrid = _this$props9.styleTopRightGrid, width = _this$props9.width;
        var sizeChange = resetAll || height !== this._lastRenderedHeight || width !== this._lastRenderedWidth;
        var leftSizeChange = resetAll || columnWidth2 !== this._lastRenderedColumnWidth || fixedColumnCount !== this._lastRenderedFixedColumnCount;
        var topSizeChange = resetAll || fixedRowCount !== this._lastRenderedFixedRowCount || rowHeight3 !== this._lastRenderedRowHeight;
        if (resetAll || sizeChange || style4 !== this._lastRenderedStyle) {
          this._containerOuterStyle = _objectSpread7({
            height,
            overflow: "visible",
            width
          }, style4);
        }
        if (resetAll || sizeChange || topSizeChange) {
          this._containerTopStyle = {
            height: this._getTopGridHeight(this.props),
            position: "relative",
            width
          };
          this._containerBottomStyle = {
            height: height - this._getTopGridHeight(this.props),
            overflow: "visible",
            position: "relative",
            width
          };
        }
        if (resetAll || styleBottomLeftGrid !== this._lastRenderedStyleBottomLeftGrid) {
          this._bottomLeftGridStyle = _objectSpread7({
            left: 0,
            overflowX: "hidden",
            overflowY: enableFixedColumnScroll ? "auto" : "hidden",
            position: "absolute"
          }, styleBottomLeftGrid);
        }
        if (resetAll || leftSizeChange || styleBottomRightGrid !== this._lastRenderedStyleBottomRightGrid) {
          this._bottomRightGridStyle = _objectSpread7({
            left: this._getLeftGridWidth(this.props),
            position: "absolute"
          }, styleBottomRightGrid);
        }
        if (resetAll || styleTopLeftGrid !== this._lastRenderedStyleTopLeftGrid) {
          this._topLeftGridStyle = _objectSpread7({
            left: 0,
            overflowX: "hidden",
            overflowY: "hidden",
            position: "absolute",
            top: 0
          }, styleTopLeftGrid);
        }
        if (resetAll || leftSizeChange || styleTopRightGrid !== this._lastRenderedStyleTopRightGrid) {
          this._topRightGridStyle = _objectSpread7({
            left: this._getLeftGridWidth(this.props),
            overflowX: enableFixedRowScroll ? "auto" : "hidden",
            overflowY: "hidden",
            position: "absolute",
            top: 0
          }, styleTopRightGrid);
        }
        this._lastRenderedColumnWidth = columnWidth2;
        this._lastRenderedFixedColumnCount = fixedColumnCount;
        this._lastRenderedFixedRowCount = fixedRowCount;
        this._lastRenderedHeight = height;
        this._lastRenderedRowHeight = rowHeight3;
        this._lastRenderedStyle = style4;
        this._lastRenderedStyleBottomLeftGrid = styleBottomLeftGrid;
        this._lastRenderedStyleBottomRightGrid = styleBottomRightGrid;
        this._lastRenderedStyleTopLeftGrid = styleTopLeftGrid;
        this._lastRenderedStyleTopRightGrid = styleTopRightGrid;
        this._lastRenderedWidth = width;
      }
    }, {
      key: "_prepareForRender",
      value: function _prepareForRender() {
        if (this._lastRenderedColumnWidth !== this.props.columnWidth || this._lastRenderedFixedColumnCount !== this.props.fixedColumnCount) {
          this._leftGridWidth = null;
        }
        if (this._lastRenderedFixedRowCount !== this.props.fixedRowCount || this._lastRenderedRowHeight !== this.props.rowHeight) {
          this._topGridHeight = null;
        }
        this._maybeCalculateCachedStyles();
        this._lastRenderedColumnWidth = this.props.columnWidth;
        this._lastRenderedFixedColumnCount = this.props.fixedColumnCount;
        this._lastRenderedFixedRowCount = this.props.fixedRowCount;
        this._lastRenderedRowHeight = this.props.rowHeight;
      }
    }, {
      key: "_renderBottomLeftGrid",
      value: function _renderBottomLeftGrid(props) {
        var enableFixedColumnScroll = props.enableFixedColumnScroll, fixedColumnCount = props.fixedColumnCount, fixedRowCount = props.fixedRowCount, rowCount = props.rowCount, hideBottomLeftGridScrollbar = props.hideBottomLeftGridScrollbar;
        var showVerticalScrollbar = this.state.showVerticalScrollbar;
        if (!fixedColumnCount) {
          return null;
        }
        var additionalRowCount = showVerticalScrollbar ? 1 : 0, height = this._getBottomGridHeight(props), width = this._getLeftGridWidth(props), scrollbarSize2 = this.state.showVerticalScrollbar ? this.state.scrollbarSize : 0, gridWidth = hideBottomLeftGridScrollbar ? width + scrollbarSize2 : width;
        var bottomLeftGrid = React90.createElement(Grid_default, (0, import_extends9.default)({}, props, {
          cellRenderer: this._cellRendererBottomLeftGrid,
          className: this.props.classNameBottomLeftGrid,
          columnCount: fixedColumnCount,
          deferredMeasurementCache: this._deferredMeasurementCacheBottomLeftGrid,
          height,
          onScroll: enableFixedColumnScroll ? this._onScrollTop : void 0,
          ref: this._bottomLeftGridRef,
          rowCount: Math.max(0, rowCount - fixedRowCount) + additionalRowCount,
          rowHeight: this._rowHeightBottomGrid,
          style: this._bottomLeftGridStyle,
          tabIndex: null,
          width: gridWidth
        }));
        if (hideBottomLeftGridScrollbar) {
          return React90.createElement("div", {
            className: "BottomLeftGrid_ScrollWrapper",
            style: _objectSpread7({}, this._bottomLeftGridStyle, {
              height,
              width,
              overflowY: "hidden"
            })
          }, bottomLeftGrid);
        }
        return bottomLeftGrid;
      }
    }, {
      key: "_renderBottomRightGrid",
      value: function _renderBottomRightGrid(props) {
        var columnCount = props.columnCount, fixedColumnCount = props.fixedColumnCount, fixedRowCount = props.fixedRowCount, rowCount = props.rowCount, scrollToColumn = props.scrollToColumn, scrollToRow = props.scrollToRow;
        return React90.createElement(Grid_default, (0, import_extends9.default)({}, props, {
          cellRenderer: this._cellRendererBottomRightGrid,
          className: this.props.classNameBottomRightGrid,
          columnCount: Math.max(0, columnCount - fixedColumnCount),
          columnWidth: this._columnWidthRightGrid,
          deferredMeasurementCache: this._deferredMeasurementCacheBottomRightGrid,
          height: this._getBottomGridHeight(props),
          onScroll: this._onScroll,
          onScrollbarPresenceChange: this._onScrollbarPresenceChange,
          ref: this._bottomRightGridRef,
          rowCount: Math.max(0, rowCount - fixedRowCount),
          rowHeight: this._rowHeightBottomGrid,
          scrollToColumn: scrollToColumn - fixedColumnCount,
          scrollToRow: scrollToRow - fixedRowCount,
          style: this._bottomRightGridStyle,
          width: this._getRightGridWidth(props)
        }));
      }
    }, {
      key: "_renderTopLeftGrid",
      value: function _renderTopLeftGrid(props) {
        var fixedColumnCount = props.fixedColumnCount, fixedRowCount = props.fixedRowCount;
        if (!fixedColumnCount || !fixedRowCount) {
          return null;
        }
        return React90.createElement(Grid_default, (0, import_extends9.default)({}, props, {
          className: this.props.classNameTopLeftGrid,
          columnCount: fixedColumnCount,
          height: this._getTopGridHeight(props),
          ref: this._topLeftGridRef,
          rowCount: fixedRowCount,
          style: this._topLeftGridStyle,
          tabIndex: null,
          width: this._getLeftGridWidth(props)
        }));
      }
    }, {
      key: "_renderTopRightGrid",
      value: function _renderTopRightGrid(props) {
        var columnCount = props.columnCount, enableFixedRowScroll = props.enableFixedRowScroll, fixedColumnCount = props.fixedColumnCount, fixedRowCount = props.fixedRowCount, scrollLeft = props.scrollLeft, hideTopRightGridScrollbar = props.hideTopRightGridScrollbar;
        var _this$state5 = this.state, showHorizontalScrollbar = _this$state5.showHorizontalScrollbar, scrollbarSize2 = _this$state5.scrollbarSize;
        if (!fixedRowCount) {
          return null;
        }
        var additionalColumnCount = showHorizontalScrollbar ? 1 : 0, height = this._getTopGridHeight(props), width = this._getRightGridWidth(props), additionalHeight = showHorizontalScrollbar ? scrollbarSize2 : 0;
        var gridHeight = height, style4 = this._topRightGridStyle;
        if (hideTopRightGridScrollbar) {
          gridHeight = height + additionalHeight;
          style4 = _objectSpread7({}, this._topRightGridStyle, {
            left: 0
          });
        }
        var topRightGrid = React90.createElement(Grid_default, (0, import_extends9.default)({}, props, {
          cellRenderer: this._cellRendererTopRightGrid,
          className: this.props.classNameTopRightGrid,
          columnCount: Math.max(0, columnCount - fixedColumnCount) + additionalColumnCount,
          columnWidth: this._columnWidthRightGrid,
          deferredMeasurementCache: this._deferredMeasurementCacheTopRightGrid,
          height: gridHeight,
          onScroll: enableFixedRowScroll ? this._onScrollLeft : void 0,
          ref: this._topRightGridRef,
          rowCount: fixedRowCount,
          scrollLeft,
          style: style4,
          tabIndex: null,
          width
        }));
        if (hideTopRightGridScrollbar) {
          return React90.createElement("div", {
            className: "TopRightGrid_ScrollWrapper",
            style: _objectSpread7({}, this._topRightGridStyle, {
              height,
              width,
              overflowX: "hidden"
            })
          }, topRightGrid);
        }
        return topRightGrid;
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, prevState) {
        if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {
          return {
            scrollLeft: nextProps.scrollLeft != null && nextProps.scrollLeft >= 0 ? nextProps.scrollLeft : prevState.scrollLeft,
            scrollTop: nextProps.scrollTop != null && nextProps.scrollTop >= 0 ? nextProps.scrollTop : prevState.scrollTop
          };
        }
        return null;
      }
    }]);
    return MultiGrid2;
  }(React90.PureComponent);
  (0, import_defineProperty15.default)(MultiGrid, "defaultProps", {
    classNameBottomLeftGrid: "",
    classNameBottomRightGrid: "",
    classNameTopLeftGrid: "",
    classNameTopRightGrid: "",
    enableFixedColumnScroll: false,
    enableFixedRowScroll: false,
    fixedColumnCount: 0,
    fixedRowCount: 0,
    scrollToColumn: -1,
    scrollToRow: -1,
    style: {},
    styleBottomLeftGrid: {},
    styleBottomRightGrid: {},
    styleTopLeftGrid: {},
    styleTopRightGrid: {},
    hideTopRightGridScrollbar: false,
    hideBottomLeftGridScrollbar: false
  });
  MultiGrid.propTypes = true ? {
    classNameBottomLeftGrid: import_prop_types24.default.string.isRequired,
    classNameBottomRightGrid: import_prop_types24.default.string.isRequired,
    classNameTopLeftGrid: import_prop_types24.default.string.isRequired,
    classNameTopRightGrid: import_prop_types24.default.string.isRequired,
    enableFixedColumnScroll: import_prop_types24.default.bool.isRequired,
    enableFixedRowScroll: import_prop_types24.default.bool.isRequired,
    fixedColumnCount: import_prop_types24.default.number.isRequired,
    fixedRowCount: import_prop_types24.default.number.isRequired,
    onScrollbarPresenceChange: import_prop_types24.default.func,
    style: import_prop_types24.default.object.isRequired,
    styleBottomLeftGrid: import_prop_types24.default.object.isRequired,
    styleBottomRightGrid: import_prop_types24.default.object.isRequired,
    styleTopLeftGrid: import_prop_types24.default.object.isRequired,
    styleTopRightGrid: import_prop_types24.default.object.isRequired,
    hideTopRightGridScrollbar: import_prop_types24.default.bool,
    hideBottomLeftGridScrollbar: import_prop_types24.default.bool
  } : {};
  polyfill(MultiGrid);

  // node_modules/react-virtualized/dist/es/ScrollSync/ScrollSync.js
  var import_classCallCheck19 = __toESM(require_classCallCheck());
  var import_createClass19 = __toESM(require_createClass());
  var import_possibleConstructorReturn12 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf12 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized13 = __toESM(require_assertThisInitialized());
  var import_inherits12 = __toESM(require_inherits());
  var import_prop_types25 = __toESM(require_prop_types());
  var React91 = __toESM(require_react());
  var ScrollSync = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits12.default)(ScrollSync2, _React$PureComponent);
    function ScrollSync2(props, context2) {
      var _this;
      (0, import_classCallCheck19.default)(this, ScrollSync2);
      _this = (0, import_possibleConstructorReturn12.default)(this, (0, import_getPrototypeOf12.default)(ScrollSync2).call(this, props, context2));
      _this.state = {
        clientHeight: 0,
        clientWidth: 0,
        scrollHeight: 0,
        scrollLeft: 0,
        scrollTop: 0,
        scrollWidth: 0
      };
      _this._onScroll = _this._onScroll.bind((0, import_assertThisInitialized13.default)(_this));
      return _this;
    }
    (0, import_createClass19.default)(ScrollSync2, [{
      key: "render",
      value: function render() {
        var children2 = this.props.children;
        var _this$state = this.state, clientHeight = _this$state.clientHeight, clientWidth = _this$state.clientWidth, scrollHeight = _this$state.scrollHeight, scrollLeft = _this$state.scrollLeft, scrollTop = _this$state.scrollTop, scrollWidth = _this$state.scrollWidth;
        return children2({
          clientHeight,
          clientWidth,
          onScroll: this._onScroll,
          scrollHeight,
          scrollLeft,
          scrollTop,
          scrollWidth
        });
      }
    }, {
      key: "_onScroll",
      value: function _onScroll(_ref) {
        var clientHeight = _ref.clientHeight, clientWidth = _ref.clientWidth, scrollHeight = _ref.scrollHeight, scrollLeft = _ref.scrollLeft, scrollTop = _ref.scrollTop, scrollWidth = _ref.scrollWidth;
        this.setState({
          clientHeight,
          clientWidth,
          scrollHeight,
          scrollLeft,
          scrollTop,
          scrollWidth
        });
      }
    }]);
    return ScrollSync2;
  }(React91.PureComponent);
  ScrollSync.propTypes = true ? {
    children: import_prop_types25.default.func.isRequired
  } : {};

  // node_modules/react-virtualized/dist/es/Table/types.js
  var import_prop_types26 = __toESM(require_prop_types());
  var bpfrpt_proptype_CellDataGetterParams = false ? null : {
    "columnData": import_prop_types26.default.any,
    "dataKey": import_prop_types26.default.string.isRequired,
    "rowData": function rowData(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
      }
    }
  };
  var bpfrpt_proptype_CellRendererParams2 = false ? null : {
    "cellData": import_prop_types26.default.any,
    "columnData": import_prop_types26.default.any,
    "dataKey": import_prop_types26.default.string.isRequired,
    "rowData": function rowData2(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
      }
    },
    "rowIndex": import_prop_types26.default.number.isRequired
  };
  var bpfrpt_proptype_HeaderRowRendererParams = false ? null : {
    "className": import_prop_types26.default.string.isRequired,
    "columns": import_prop_types26.default.arrayOf(function(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
      }
    }).isRequired,
    "style": function style2(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
      }
    }
  };
  var bpfrpt_proptype_HeaderRendererParams = false ? null : {
    "columnData": import_prop_types26.default.any,
    "dataKey": import_prop_types26.default.string.isRequired,
    "disableSort": import_prop_types26.default.bool,
    "label": import_prop_types26.default.any,
    "sortBy": import_prop_types26.default.string,
    "sortDirection": import_prop_types26.default.string
  };
  var bpfrpt_proptype_RowRendererParams2 = false ? null : {
    "className": import_prop_types26.default.string.isRequired,
    "columns": import_prop_types26.default.arrayOf(function(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
      }
    }).isRequired,
    "index": import_prop_types26.default.number.isRequired,
    "isScrolling": import_prop_types26.default.bool.isRequired,
    "onRowClick": import_prop_types26.default.func,
    "onRowDoubleClick": import_prop_types26.default.func,
    "onRowMouseOver": import_prop_types26.default.func,
    "onRowMouseOut": import_prop_types26.default.func,
    "rowData": function rowData3(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
      }
    },
    "style": function style3(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `".concat(propName, "` has type 'any' or 'mixed', but was not provided to `").concat(componentName, "`. Pass undefined or any other value."));
      }
    },
    "key": import_prop_types26.default.string.isRequired
  };

  // node_modules/react-virtualized/dist/es/Table/defaultCellDataGetter.js
  function defaultCellDataGetter(_ref) {
    var dataKey = _ref.dataKey, rowData4 = _ref.rowData;
    if (typeof rowData4.get === "function") {
      return rowData4.get(dataKey);
    } else {
      return rowData4[dataKey];
    }
  }

  // node_modules/react-virtualized/dist/es/Table/defaultCellRenderer.js
  function defaultCellRenderer(_ref) {
    var cellData = _ref.cellData;
    if (cellData == null) {
      return "";
    } else {
      return String(cellData);
    }
  }

  // node_modules/react-virtualized/dist/es/Table/defaultHeaderRowRenderer.js
  var React92 = __toESM(require_react());
  var import_prop_types27 = __toESM(require_prop_types());
  function defaultHeaderRowRenderer(_ref) {
    var className = _ref.className, columns = _ref.columns, style4 = _ref.style;
    return React92.createElement("div", {
      className,
      role: "row",
      style: style4
    }, columns);
  }
  defaultHeaderRowRenderer.propTypes = false ? null : bpfrpt_proptype_HeaderRowRendererParams === import_prop_types27.default.any ? {} : bpfrpt_proptype_HeaderRowRendererParams;

  // node_modules/react-virtualized/dist/es/Table/defaultHeaderRenderer.js
  var React94 = __toESM(require_react());

  // node_modules/react-virtualized/dist/es/Table/SortIndicator.js
  var import_prop_types28 = __toESM(require_prop_types());
  var React93 = __toESM(require_react());

  // node_modules/react-virtualized/dist/es/Table/SortDirection.js
  var SortDirection = {
    ASC: "ASC",
    DESC: "DESC"
  };
  var SortDirection_default = SortDirection;

  // node_modules/react-virtualized/dist/es/Table/SortIndicator.js
  function SortIndicator(_ref) {
    var sortDirection = _ref.sortDirection;
    var classNames2 = clsx_m_default("ReactVirtualized__Table__sortableHeaderIcon", {
      "ReactVirtualized__Table__sortableHeaderIcon--ASC": sortDirection === SortDirection_default.ASC,
      "ReactVirtualized__Table__sortableHeaderIcon--DESC": sortDirection === SortDirection_default.DESC
    });
    return React93.createElement("svg", {
      className: classNames2,
      width: 18,
      height: 18,
      viewBox: "0 0 24 24"
    }, sortDirection === SortDirection_default.ASC ? React93.createElement("path", {
      d: "M7 14l5-5 5 5z"
    }) : React93.createElement("path", {
      d: "M7 10l5 5 5-5z"
    }), React93.createElement("path", {
      d: "M0 0h24v24H0z",
      fill: "none"
    }));
  }
  SortIndicator.propTypes = true ? {
    sortDirection: import_prop_types28.default.oneOf([SortDirection_default.ASC, SortDirection_default.DESC])
  } : {};

  // node_modules/react-virtualized/dist/es/Table/defaultHeaderRenderer.js
  var import_prop_types29 = __toESM(require_prop_types());
  function defaultHeaderRenderer(_ref) {
    var dataKey = _ref.dataKey, label = _ref.label, sortBy = _ref.sortBy, sortDirection = _ref.sortDirection;
    var showSortIndicator = sortBy === dataKey;
    var children2 = [React94.createElement("span", {
      className: "ReactVirtualized__Table__headerTruncatedText",
      key: "label",
      title: typeof label === "string" ? label : null
    }, label)];
    if (showSortIndicator) {
      children2.push(React94.createElement(SortIndicator, {
        key: "SortIndicator",
        sortDirection
      }));
    }
    return children2;
  }
  defaultHeaderRenderer.propTypes = false ? null : bpfrpt_proptype_HeaderRendererParams === import_prop_types29.default.any ? {} : bpfrpt_proptype_HeaderRendererParams;

  // node_modules/react-virtualized/dist/es/Table/defaultRowRenderer.js
  var import_extends10 = __toESM(require_extends());
  var React95 = __toESM(require_react());
  var import_prop_types30 = __toESM(require_prop_types());
  function defaultRowRenderer(_ref) {
    var className = _ref.className, columns = _ref.columns, index2 = _ref.index, key = _ref.key, onRowClick = _ref.onRowClick, onRowDoubleClick = _ref.onRowDoubleClick, onRowMouseOut = _ref.onRowMouseOut, onRowMouseOver = _ref.onRowMouseOver, onRowRightClick = _ref.onRowRightClick, rowData4 = _ref.rowData, style4 = _ref.style;
    var a11yProps = {
      "aria-rowindex": index2 + 1
    };
    if (onRowClick || onRowDoubleClick || onRowMouseOut || onRowMouseOver || onRowRightClick) {
      a11yProps["aria-label"] = "row";
      a11yProps.tabIndex = 0;
      if (onRowClick) {
        a11yProps.onClick = function(event) {
          return onRowClick({
            event,
            index: index2,
            rowData: rowData4
          });
        };
      }
      if (onRowDoubleClick) {
        a11yProps.onDoubleClick = function(event) {
          return onRowDoubleClick({
            event,
            index: index2,
            rowData: rowData4
          });
        };
      }
      if (onRowMouseOut) {
        a11yProps.onMouseOut = function(event) {
          return onRowMouseOut({
            event,
            index: index2,
            rowData: rowData4
          });
        };
      }
      if (onRowMouseOver) {
        a11yProps.onMouseOver = function(event) {
          return onRowMouseOver({
            event,
            index: index2,
            rowData: rowData4
          });
        };
      }
      if (onRowRightClick) {
        a11yProps.onContextMenu = function(event) {
          return onRowRightClick({
            event,
            index: index2,
            rowData: rowData4
          });
        };
      }
    }
    return React95.createElement("div", (0, import_extends10.default)({}, a11yProps, {
      className,
      key,
      role: "row",
      style: style4
    }), columns);
  }
  defaultRowRenderer.propTypes = false ? null : bpfrpt_proptype_RowRendererParams2 === import_prop_types30.default.any ? {} : bpfrpt_proptype_RowRendererParams2;

  // node_modules/react-virtualized/dist/es/Table/Column.js
  var import_classCallCheck20 = __toESM(require_classCallCheck());
  var import_possibleConstructorReturn13 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf13 = __toESM(require_getPrototypeOf());
  var import_inherits13 = __toESM(require_inherits());
  var import_defineProperty16 = __toESM(require_defineProperty());
  var import_prop_types31 = __toESM(require_prop_types());
  var React96 = __toESM(require_react());
  var Column = /* @__PURE__ */ function(_React$Component) {
    (0, import_inherits13.default)(Column2, _React$Component);
    function Column2() {
      (0, import_classCallCheck20.default)(this, Column2);
      return (0, import_possibleConstructorReturn13.default)(this, (0, import_getPrototypeOf13.default)(Column2).apply(this, arguments));
    }
    return Column2;
  }(React96.Component);
  (0, import_defineProperty16.default)(Column, "defaultProps", {
    cellDataGetter: defaultCellDataGetter,
    cellRenderer: defaultCellRenderer,
    defaultSortDirection: SortDirection_default.ASC,
    flexGrow: 0,
    flexShrink: 1,
    headerRenderer: defaultHeaderRenderer,
    style: {}
  });
  Column.propTypes = true ? {
    "aria-label": import_prop_types31.default.string,
    cellDataGetter: import_prop_types31.default.func,
    cellRenderer: import_prop_types31.default.func,
    className: import_prop_types31.default.string,
    columnData: import_prop_types31.default.object,
    dataKey: import_prop_types31.default.any.isRequired,
    defaultSortDirection: import_prop_types31.default.oneOf([SortDirection_default.ASC, SortDirection_default.DESC]),
    disableSort: import_prop_types31.default.bool,
    flexGrow: import_prop_types31.default.number,
    flexShrink: import_prop_types31.default.number,
    headerClassName: import_prop_types31.default.string,
    headerRenderer: import_prop_types31.default.func.isRequired,
    headerStyle: import_prop_types31.default.object,
    id: import_prop_types31.default.string,
    label: import_prop_types31.default.node,
    maxWidth: import_prop_types31.default.number,
    minWidth: import_prop_types31.default.number,
    style: import_prop_types31.default.object,
    width: import_prop_types31.default.number.isRequired
  } : {};

  // node_modules/react-virtualized/dist/es/Table/Table.js
  var import_extends11 = __toESM(require_extends());
  var import_classCallCheck21 = __toESM(require_classCallCheck());
  var import_createClass20 = __toESM(require_createClass());
  var import_possibleConstructorReturn14 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf14 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized14 = __toESM(require_assertThisInitialized());
  var import_inherits14 = __toESM(require_inherits());
  var import_defineProperty17 = __toESM(require_defineProperty());
  var import_prop_types32 = __toESM(require_prop_types());
  var React97 = __toESM(require_react());
  var import_react_dom4 = __toESM(require_react_dom());
  function ownKeys8(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread8(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys8(source, true).forEach(function(key) {
          (0, import_defineProperty17.default)(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys8(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var Table = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits14.default)(Table2, _React$PureComponent);
    function Table2(props) {
      var _this;
      (0, import_classCallCheck21.default)(this, Table2);
      _this = (0, import_possibleConstructorReturn14.default)(this, (0, import_getPrototypeOf14.default)(Table2).call(this, props));
      _this.state = {
        scrollbarWidth: 0
      };
      _this._createColumn = _this._createColumn.bind((0, import_assertThisInitialized14.default)(_this));
      _this._createRow = _this._createRow.bind((0, import_assertThisInitialized14.default)(_this));
      _this._onScroll = _this._onScroll.bind((0, import_assertThisInitialized14.default)(_this));
      _this._onSectionRendered = _this._onSectionRendered.bind((0, import_assertThisInitialized14.default)(_this));
      _this._setRef = _this._setRef.bind((0, import_assertThisInitialized14.default)(_this));
      return _this;
    }
    (0, import_createClass20.default)(Table2, [{
      key: "forceUpdateGrid",
      value: function forceUpdateGrid() {
        if (this.Grid) {
          this.Grid.forceUpdate();
        }
      }
    }, {
      key: "getOffsetForRow",
      value: function getOffsetForRow(_ref) {
        var alignment = _ref.alignment, index2 = _ref.index;
        if (this.Grid) {
          var _this$Grid$getOffsetF = this.Grid.getOffsetForCell({
            alignment,
            rowIndex: index2
          }), scrollTop = _this$Grid$getOffsetF.scrollTop;
          return scrollTop;
        }
        return 0;
      }
    }, {
      key: "invalidateCellSizeAfterRender",
      value: function invalidateCellSizeAfterRender(_ref2) {
        var columnIndex = _ref2.columnIndex, rowIndex = _ref2.rowIndex;
        if (this.Grid) {
          this.Grid.invalidateCellSizeAfterRender({
            rowIndex,
            columnIndex
          });
        }
      }
    }, {
      key: "measureAllRows",
      value: function measureAllRows() {
        if (this.Grid) {
          this.Grid.measureAllCells();
        }
      }
    }, {
      key: "recomputeGridSize",
      value: function recomputeGridSize() {
        var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$columnIndex = _ref3.columnIndex, columnIndex = _ref3$columnIndex === void 0 ? 0 : _ref3$columnIndex, _ref3$rowIndex = _ref3.rowIndex, rowIndex = _ref3$rowIndex === void 0 ? 0 : _ref3$rowIndex;
        if (this.Grid) {
          this.Grid.recomputeGridSize({
            rowIndex,
            columnIndex
          });
        }
      }
    }, {
      key: "recomputeRowHeights",
      value: function recomputeRowHeights() {
        var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        if (this.Grid) {
          this.Grid.recomputeGridSize({
            rowIndex: index2
          });
        }
      }
    }, {
      key: "scrollToPosition",
      value: function scrollToPosition() {
        var scrollTop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        if (this.Grid) {
          this.Grid.scrollToPosition({
            scrollTop
          });
        }
      }
    }, {
      key: "scrollToRow",
      value: function scrollToRow() {
        var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        if (this.Grid) {
          this.Grid.scrollToCell({
            columnIndex: 0,
            rowIndex: index2
          });
        }
      }
    }, {
      key: "getScrollbarWidth",
      value: function getScrollbarWidth() {
        if (this.Grid) {
          var _Grid = (0, import_react_dom4.findDOMNode)(this.Grid);
          var clientWidth = _Grid.clientWidth || 0;
          var offsetWidth = _Grid.offsetWidth || 0;
          return offsetWidth - clientWidth;
        }
        return 0;
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._setScrollbarWidth();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this._setScrollbarWidth();
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        var _this$props = this.props, children2 = _this$props.children, className = _this$props.className, disableHeader = _this$props.disableHeader, gridClassName = _this$props.gridClassName, gridStyle = _this$props.gridStyle, headerHeight = _this$props.headerHeight, headerRowRenderer = _this$props.headerRowRenderer, height = _this$props.height, id = _this$props.id, noRowsRenderer4 = _this$props.noRowsRenderer, rowClassName = _this$props.rowClassName, rowStyle = _this$props.rowStyle, scrollToIndex = _this$props.scrollToIndex, style4 = _this$props.style, width = _this$props.width;
        var scrollbarWidth = this.state.scrollbarWidth;
        var availableRowsHeight = disableHeader ? height : height - headerHeight;
        var rowClass = typeof rowClassName === "function" ? rowClassName({
          index: -1
        }) : rowClassName;
        var rowStyleObject = typeof rowStyle === "function" ? rowStyle({
          index: -1
        }) : rowStyle;
        this._cachedColumnStyles = [];
        React97.Children.toArray(children2).forEach(function(column, index2) {
          var flexStyles = _this2._getFlexStyleForColumn(column, column.props.style);
          _this2._cachedColumnStyles[index2] = _objectSpread8({
            overflow: "hidden"
          }, flexStyles);
        });
        return React97.createElement("div", {
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-colcount": React97.Children.toArray(children2).length,
          "aria-rowcount": this.props.rowCount,
          className: clsx_m_default("ReactVirtualized__Table", className),
          id,
          role: "grid",
          style: style4
        }, !disableHeader && headerRowRenderer({
          className: clsx_m_default("ReactVirtualized__Table__headerRow", rowClass),
          columns: this._getHeaderColumns(),
          style: _objectSpread8({
            height: headerHeight,
            overflow: "hidden",
            paddingRight: scrollbarWidth,
            width
          }, rowStyleObject)
        }), React97.createElement(Grid_default, (0, import_extends11.default)({}, this.props, {
          "aria-readonly": null,
          autoContainerWidth: true,
          className: clsx_m_default("ReactVirtualized__Table__Grid", gridClassName),
          cellRenderer: this._createRow,
          columnWidth: width,
          columnCount: 1,
          height: availableRowsHeight,
          id: void 0,
          noContentRenderer: noRowsRenderer4,
          onScroll: this._onScroll,
          onSectionRendered: this._onSectionRendered,
          ref: this._setRef,
          role: "rowgroup",
          scrollbarWidth,
          scrollToRow: scrollToIndex,
          style: _objectSpread8({}, gridStyle, {
            overflowX: "hidden"
          })
        })));
      }
    }, {
      key: "_createColumn",
      value: function _createColumn(_ref4) {
        var column = _ref4.column, columnIndex = _ref4.columnIndex, isScrolling = _ref4.isScrolling, parent = _ref4.parent, rowData4 = _ref4.rowData, rowIndex = _ref4.rowIndex;
        var onColumnClick = this.props.onColumnClick;
        var _column$props = column.props, cellDataGetter = _column$props.cellDataGetter, cellRenderer3 = _column$props.cellRenderer, className = _column$props.className, columnData = _column$props.columnData, dataKey = _column$props.dataKey, id = _column$props.id;
        var cellData = cellDataGetter({
          columnData,
          dataKey,
          rowData: rowData4
        });
        var renderedCell = cellRenderer3({
          cellData,
          columnData,
          columnIndex,
          dataKey,
          isScrolling,
          parent,
          rowData: rowData4,
          rowIndex
        });
        var onClick = function onClick2(event) {
          onColumnClick && onColumnClick({
            columnData,
            dataKey,
            event
          });
        };
        var style4 = this._cachedColumnStyles[columnIndex];
        var title = typeof renderedCell === "string" ? renderedCell : null;
        return React97.createElement("div", {
          "aria-colindex": columnIndex + 1,
          "aria-describedby": id,
          className: clsx_m_default("ReactVirtualized__Table__rowColumn", className),
          key: "Row" + rowIndex + "-Col" + columnIndex,
          onClick,
          role: "gridcell",
          style: style4,
          title
        }, renderedCell);
      }
    }, {
      key: "_createHeader",
      value: function _createHeader(_ref5) {
        var column = _ref5.column, index2 = _ref5.index;
        var _this$props2 = this.props, headerClassName = _this$props2.headerClassName, headerStyle = _this$props2.headerStyle, onHeaderClick = _this$props2.onHeaderClick, sort = _this$props2.sort, sortBy = _this$props2.sortBy, sortDirection = _this$props2.sortDirection;
        var _column$props2 = column.props, columnData = _column$props2.columnData, dataKey = _column$props2.dataKey, defaultSortDirection = _column$props2.defaultSortDirection, disableSort = _column$props2.disableSort, headerRenderer = _column$props2.headerRenderer, id = _column$props2.id, label = _column$props2.label;
        var sortEnabled = !disableSort && sort;
        var classNames2 = clsx_m_default("ReactVirtualized__Table__headerColumn", headerClassName, column.props.headerClassName, {
          ReactVirtualized__Table__sortableHeaderColumn: sortEnabled
        });
        var style4 = this._getFlexStyleForColumn(column, _objectSpread8({}, headerStyle, {}, column.props.headerStyle));
        var renderedHeader = headerRenderer({
          columnData,
          dataKey,
          disableSort,
          label,
          sortBy,
          sortDirection
        });
        var headerOnClick, headerOnKeyDown, headerTabIndex, headerAriaSort, headerAriaLabel;
        if (sortEnabled || onHeaderClick) {
          var isFirstTimeSort = sortBy !== dataKey;
          var newSortDirection = isFirstTimeSort ? defaultSortDirection : sortDirection === SortDirection_default.DESC ? SortDirection_default.ASC : SortDirection_default.DESC;
          var onClick = function onClick2(event) {
            sortEnabled && sort({
              defaultSortDirection,
              event,
              sortBy: dataKey,
              sortDirection: newSortDirection
            });
            onHeaderClick && onHeaderClick({
              columnData,
              dataKey,
              event
            });
          };
          var onKeyDown = function onKeyDown2(event) {
            if (event.key === "Enter" || event.key === " ") {
              onClick(event);
            }
          };
          headerAriaLabel = column.props["aria-label"] || label || dataKey;
          headerAriaSort = "none";
          headerTabIndex = 0;
          headerOnClick = onClick;
          headerOnKeyDown = onKeyDown;
        }
        if (sortBy === dataKey) {
          headerAriaSort = sortDirection === SortDirection_default.ASC ? "ascending" : "descending";
        }
        return React97.createElement("div", {
          "aria-label": headerAriaLabel,
          "aria-sort": headerAriaSort,
          className: classNames2,
          id,
          key: "Header-Col" + index2,
          onClick: headerOnClick,
          onKeyDown: headerOnKeyDown,
          role: "columnheader",
          style: style4,
          tabIndex: headerTabIndex
        }, renderedHeader);
      }
    }, {
      key: "_createRow",
      value: function _createRow(_ref6) {
        var _this3 = this;
        var index2 = _ref6.rowIndex, isScrolling = _ref6.isScrolling, key = _ref6.key, parent = _ref6.parent, style4 = _ref6.style;
        var _this$props3 = this.props, children2 = _this$props3.children, onRowClick = _this$props3.onRowClick, onRowDoubleClick = _this$props3.onRowDoubleClick, onRowRightClick = _this$props3.onRowRightClick, onRowMouseOver = _this$props3.onRowMouseOver, onRowMouseOut = _this$props3.onRowMouseOut, rowClassName = _this$props3.rowClassName, rowGetter = _this$props3.rowGetter, rowRenderer2 = _this$props3.rowRenderer, rowStyle = _this$props3.rowStyle;
        var scrollbarWidth = this.state.scrollbarWidth;
        var rowClass = typeof rowClassName === "function" ? rowClassName({
          index: index2
        }) : rowClassName;
        var rowStyleObject = typeof rowStyle === "function" ? rowStyle({
          index: index2
        }) : rowStyle;
        var rowData4 = rowGetter({
          index: index2
        });
        var columns = React97.Children.toArray(children2).map(function(column, columnIndex) {
          return _this3._createColumn({
            column,
            columnIndex,
            isScrolling,
            parent,
            rowData: rowData4,
            rowIndex: index2,
            scrollbarWidth
          });
        });
        var className = clsx_m_default("ReactVirtualized__Table__row", rowClass);
        var flattenedStyle = _objectSpread8({}, style4, {
          height: this._getRowHeight(index2),
          overflow: "hidden",
          paddingRight: scrollbarWidth
        }, rowStyleObject);
        return rowRenderer2({
          className,
          columns,
          index: index2,
          isScrolling,
          key,
          onRowClick,
          onRowDoubleClick,
          onRowRightClick,
          onRowMouseOver,
          onRowMouseOut,
          rowData: rowData4,
          style: flattenedStyle
        });
      }
    }, {
      key: "_getFlexStyleForColumn",
      value: function _getFlexStyleForColumn(column) {
        var customStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var flexValue = "".concat(column.props.flexGrow, " ").concat(column.props.flexShrink, " ").concat(column.props.width, "px");
        var style4 = _objectSpread8({}, customStyle, {
          flex: flexValue,
          msFlex: flexValue,
          WebkitFlex: flexValue
        });
        if (column.props.maxWidth) {
          style4.maxWidth = column.props.maxWidth;
        }
        if (column.props.minWidth) {
          style4.minWidth = column.props.minWidth;
        }
        return style4;
      }
    }, {
      key: "_getHeaderColumns",
      value: function _getHeaderColumns() {
        var _this4 = this;
        var _this$props4 = this.props, children2 = _this$props4.children, disableHeader = _this$props4.disableHeader;
        var items = disableHeader ? [] : React97.Children.toArray(children2);
        return items.map(function(column, index2) {
          return _this4._createHeader({
            column,
            index: index2
          });
        });
      }
    }, {
      key: "_getRowHeight",
      value: function _getRowHeight(rowIndex) {
        var rowHeight3 = this.props.rowHeight;
        return typeof rowHeight3 === "function" ? rowHeight3({
          index: rowIndex
        }) : rowHeight3;
      }
    }, {
      key: "_onScroll",
      value: function _onScroll(_ref7) {
        var clientHeight = _ref7.clientHeight, scrollHeight = _ref7.scrollHeight, scrollTop = _ref7.scrollTop;
        var onScroll7 = this.props.onScroll;
        onScroll7({
          clientHeight,
          scrollHeight,
          scrollTop
        });
      }
    }, {
      key: "_onSectionRendered",
      value: function _onSectionRendered(_ref8) {
        var rowOverscanStartIndex = _ref8.rowOverscanStartIndex, rowOverscanStopIndex = _ref8.rowOverscanStopIndex, rowStartIndex = _ref8.rowStartIndex, rowStopIndex = _ref8.rowStopIndex;
        var onRowsRendered3 = this.props.onRowsRendered;
        onRowsRendered3({
          overscanStartIndex: rowOverscanStartIndex,
          overscanStopIndex: rowOverscanStopIndex,
          startIndex: rowStartIndex,
          stopIndex: rowStopIndex
        });
      }
    }, {
      key: "_setRef",
      value: function _setRef(ref) {
        this.Grid = ref;
      }
    }, {
      key: "_setScrollbarWidth",
      value: function _setScrollbarWidth() {
        var scrollbarWidth = this.getScrollbarWidth();
        this.setState({
          scrollbarWidth
        });
      }
    }]);
    return Table2;
  }(React97.PureComponent);
  (0, import_defineProperty17.default)(Table, "defaultProps", {
    disableHeader: false,
    estimatedRowSize: 30,
    headerHeight: 0,
    headerStyle: {},
    noRowsRenderer: function noRowsRenderer3() {
      return null;
    },
    onRowsRendered: function onRowsRendered2() {
      return null;
    },
    onScroll: function onScroll5() {
      return null;
    },
    overscanIndicesGetter: defaultOverscanIndicesGetter2,
    overscanRowCount: 10,
    rowRenderer: defaultRowRenderer,
    headerRowRenderer: defaultHeaderRowRenderer,
    rowStyle: {},
    scrollToAlignment: "auto",
    scrollToIndex: -1,
    style: {}
  });
  Table.propTypes = true ? {
    "aria-label": import_prop_types32.default.string,
    "aria-labelledby": import_prop_types32.default.string,
    autoHeight: import_prop_types32.default.bool,
    children: function children(props) {
      var children2 = React97.Children.toArray(props.children);
      for (var i = 0; i < children2.length; i++) {
        var childType = children2[i].type;
        if (childType !== Column && !(childType.prototype instanceof Column)) {
          return new Error("Table only accepts children of type Column");
        }
      }
    },
    className: import_prop_types32.default.string,
    disableHeader: import_prop_types32.default.bool,
    estimatedRowSize: import_prop_types32.default.number.isRequired,
    gridClassName: import_prop_types32.default.string,
    gridStyle: import_prop_types32.default.object,
    headerClassName: import_prop_types32.default.string,
    headerHeight: import_prop_types32.default.number.isRequired,
    headerRowRenderer: import_prop_types32.default.func,
    headerStyle: import_prop_types32.default.object,
    height: import_prop_types32.default.number.isRequired,
    id: import_prop_types32.default.string,
    noRowsRenderer: import_prop_types32.default.func,
    onColumnClick: import_prop_types32.default.func,
    onHeaderClick: import_prop_types32.default.func,
    onRowClick: import_prop_types32.default.func,
    onRowDoubleClick: import_prop_types32.default.func,
    onRowMouseOut: import_prop_types32.default.func,
    onRowMouseOver: import_prop_types32.default.func,
    onRowRightClick: import_prop_types32.default.func,
    onRowsRendered: import_prop_types32.default.func,
    onScroll: import_prop_types32.default.func.isRequired,
    overscanIndicesGetter: import_prop_types32.default.func.isRequired,
    overscanRowCount: import_prop_types32.default.number.isRequired,
    rowClassName: import_prop_types32.default.oneOfType([import_prop_types32.default.string, import_prop_types32.default.func]),
    rowGetter: import_prop_types32.default.func.isRequired,
    rowHeight: import_prop_types32.default.oneOfType([import_prop_types32.default.number, import_prop_types32.default.func]).isRequired,
    rowCount: import_prop_types32.default.number.isRequired,
    rowRenderer: import_prop_types32.default.func,
    rowStyle: import_prop_types32.default.oneOfType([import_prop_types32.default.object, import_prop_types32.default.func]).isRequired,
    scrollToAlignment: import_prop_types32.default.oneOf(["auto", "end", "start", "center"]).isRequired,
    scrollToIndex: import_prop_types32.default.number.isRequired,
    scrollTop: import_prop_types32.default.number,
    sort: import_prop_types32.default.func,
    sortBy: import_prop_types32.default.string,
    sortDirection: import_prop_types32.default.oneOf([SortDirection_default.ASC, SortDirection_default.DESC]),
    style: import_prop_types32.default.object,
    tabIndex: import_prop_types32.default.number,
    width: import_prop_types32.default.number.isRequired
  } : {};

  // node_modules/react-virtualized/dist/es/WindowScroller/WindowScroller.js
  var import_classCallCheck22 = __toESM(require_classCallCheck());
  var import_createClass21 = __toESM(require_createClass());
  var import_possibleConstructorReturn15 = __toESM(require_possibleConstructorReturn());
  var import_getPrototypeOf15 = __toESM(require_getPrototypeOf());
  var import_assertThisInitialized15 = __toESM(require_assertThisInitialized());
  var import_inherits15 = __toESM(require_inherits());
  var import_defineProperty18 = __toESM(require_defineProperty());
  var React98 = __toESM(require_react());
  var ReactDOM2 = __toESM(require_react_dom());

  // node_modules/react-virtualized/dist/es/WindowScroller/utils/onScroll.js
  var mountedInstances = [];
  var originalBodyPointerEvents = null;
  var disablePointerEventsTimeoutId = null;
  function enablePointerEventsIfDisabled() {
    if (disablePointerEventsTimeoutId) {
      disablePointerEventsTimeoutId = null;
      if (document.body && originalBodyPointerEvents != null) {
        document.body.style.pointerEvents = originalBodyPointerEvents;
      }
      originalBodyPointerEvents = null;
    }
  }
  function enablePointerEventsAfterDelayCallback() {
    enablePointerEventsIfDisabled();
    mountedInstances.forEach(function(instance) {
      return instance.__resetIsScrolling();
    });
  }
  function enablePointerEventsAfterDelay() {
    if (disablePointerEventsTimeoutId) {
      cancelAnimationTimeout(disablePointerEventsTimeoutId);
    }
    var maximumTimeout = 0;
    mountedInstances.forEach(function(instance) {
      maximumTimeout = Math.max(maximumTimeout, instance.props.scrollingResetTimeInterval);
    });
    disablePointerEventsTimeoutId = requestAnimationTimeout(enablePointerEventsAfterDelayCallback, maximumTimeout);
  }
  function onScrollWindow(event) {
    if (event.currentTarget === window && originalBodyPointerEvents == null && document.body) {
      originalBodyPointerEvents = document.body.style.pointerEvents;
      document.body.style.pointerEvents = "none";
    }
    enablePointerEventsAfterDelay();
    mountedInstances.forEach(function(instance) {
      if (instance.props.scrollElement === event.currentTarget) {
        instance.__handleWindowScrollEvent();
      }
    });
  }
  function registerScrollListener(component, element) {
    if (!mountedInstances.some(function(instance) {
      return instance.props.scrollElement === element;
    })) {
      element.addEventListener("scroll", onScrollWindow);
    }
    mountedInstances.push(component);
  }
  function unregisterScrollListener(component, element) {
    mountedInstances = mountedInstances.filter(function(instance) {
      return instance !== component;
    });
    if (!mountedInstances.length) {
      element.removeEventListener("scroll", onScrollWindow);
      if (disablePointerEventsTimeoutId) {
        cancelAnimationTimeout(disablePointerEventsTimeoutId);
        enablePointerEventsIfDisabled();
      }
    }
  }

  // node_modules/react-virtualized/dist/es/WindowScroller/utils/dimensions.js
  var isWindow = function isWindow2(element) {
    return element === window;
  };
  var getBoundingBox = function getBoundingBox2(element) {
    return element.getBoundingClientRect();
  };
  function getDimensions(scrollElement, props) {
    if (!scrollElement) {
      return {
        height: props.serverHeight,
        width: props.serverWidth
      };
    } else if (isWindow(scrollElement)) {
      var _window = window, innerHeight = _window.innerHeight, innerWidth = _window.innerWidth;
      return {
        height: typeof innerHeight === "number" ? innerHeight : 0,
        width: typeof innerWidth === "number" ? innerWidth : 0
      };
    } else {
      return getBoundingBox(scrollElement);
    }
  }
  function getPositionOffset(element, container) {
    if (isWindow(container) && document.documentElement) {
      var containerElement = document.documentElement;
      var elementRect = getBoundingBox(element);
      var containerRect = getBoundingBox(containerElement);
      return {
        top: elementRect.top - containerRect.top,
        left: elementRect.left - containerRect.left
      };
    } else {
      var scrollOffset = getScrollOffset(container);
      var _elementRect = getBoundingBox(element);
      var _containerRect = getBoundingBox(container);
      return {
        top: _elementRect.top + scrollOffset.top - _containerRect.top,
        left: _elementRect.left + scrollOffset.left - _containerRect.left
      };
    }
  }
  function getScrollOffset(element) {
    if (isWindow(element) && document.documentElement) {
      return {
        top: "scrollY" in window ? window.scrollY : document.documentElement.scrollTop,
        left: "scrollX" in window ? window.scrollX : document.documentElement.scrollLeft
      };
    } else {
      return {
        top: element.scrollTop,
        left: element.scrollLeft
      };
    }
  }

  // node_modules/react-virtualized/dist/es/WindowScroller/WindowScroller.js
  var import_prop_types33 = __toESM(require_prop_types());
  var _class7;
  var _temp7;
  function ownKeys9(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread9(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys9(source, true).forEach(function(key) {
          (0, import_defineProperty18.default)(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys9(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  var IS_SCROLLING_TIMEOUT2 = 150;
  var getWindow = function getWindow2() {
    return typeof window !== "undefined" ? window : void 0;
  };
  var WindowScroller = (_temp7 = _class7 = /* @__PURE__ */ function(_React$PureComponent) {
    (0, import_inherits15.default)(WindowScroller2, _React$PureComponent);
    function WindowScroller2() {
      var _getPrototypeOf22;
      var _this;
      (0, import_classCallCheck22.default)(this, WindowScroller2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = (0, import_possibleConstructorReturn15.default)(this, (_getPrototypeOf22 = (0, import_getPrototypeOf15.default)(WindowScroller2)).call.apply(_getPrototypeOf22, [this].concat(args)));
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_window", getWindow());
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_isMounted", false);
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_positionFromTop", 0);
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_positionFromLeft", 0);
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_detectElementResize", void 0);
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_child", void 0);
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "state", _objectSpread9({}, getDimensions(_this.props.scrollElement, _this.props), {
        isScrolling: false,
        scrollLeft: 0,
        scrollTop: 0
      }));
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_registerChild", function(element) {
        if (element && !(element instanceof Element)) {
          console.warn("WindowScroller registerChild expects to be passed Element or null");
        }
        _this._child = element;
        _this.updatePosition();
      });
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_onChildScroll", function(_ref) {
        var scrollTop = _ref.scrollTop;
        if (_this.state.scrollTop === scrollTop) {
          return;
        }
        var scrollElement = _this.props.scrollElement;
        if (scrollElement) {
          if (typeof scrollElement.scrollTo === "function") {
            scrollElement.scrollTo(0, scrollTop + _this._positionFromTop);
          } else {
            scrollElement.scrollTop = scrollTop + _this._positionFromTop;
          }
        }
      });
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_registerResizeListener", function(element) {
        if (element === window) {
          window.addEventListener("resize", _this._onResize, false);
        } else {
          _this._detectElementResize.addResizeListener(element, _this._onResize);
        }
      });
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_unregisterResizeListener", function(element) {
        if (element === window) {
          window.removeEventListener("resize", _this._onResize, false);
        } else if (element) {
          _this._detectElementResize.removeResizeListener(element, _this._onResize);
        }
      });
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "_onResize", function() {
        _this.updatePosition();
      });
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "__handleWindowScrollEvent", function() {
        if (!_this._isMounted) {
          return;
        }
        var onScroll7 = _this.props.onScroll;
        var scrollElement = _this.props.scrollElement;
        if (scrollElement) {
          var scrollOffset = getScrollOffset(scrollElement);
          var scrollLeft = Math.max(0, scrollOffset.left - _this._positionFromLeft);
          var scrollTop = Math.max(0, scrollOffset.top - _this._positionFromTop);
          _this.setState({
            isScrolling: true,
            scrollLeft,
            scrollTop
          });
          onScroll7({
            scrollLeft,
            scrollTop
          });
        }
      });
      (0, import_defineProperty18.default)((0, import_assertThisInitialized15.default)(_this), "__resetIsScrolling", function() {
        _this.setState({
          isScrolling: false
        });
      });
      return _this;
    }
    (0, import_createClass21.default)(WindowScroller2, [{
      key: "updatePosition",
      value: function updatePosition() {
        var scrollElement = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props.scrollElement;
        var onResize3 = this.props.onResize;
        var _this$state = this.state, height = _this$state.height, width = _this$state.width;
        var thisNode = this._child || ReactDOM2.findDOMNode(this);
        if (thisNode instanceof Element && scrollElement) {
          var offset = getPositionOffset(thisNode, scrollElement);
          this._positionFromTop = offset.top;
          this._positionFromLeft = offset.left;
        }
        var dimensions = getDimensions(scrollElement, this.props);
        if (height !== dimensions.height || width !== dimensions.width) {
          this.setState({
            height: dimensions.height,
            width: dimensions.width
          });
          onResize3({
            height: dimensions.height,
            width: dimensions.width
          });
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var scrollElement = this.props.scrollElement;
        this._detectElementResize = createDetectElementResize();
        this.updatePosition(scrollElement);
        if (scrollElement) {
          registerScrollListener(this, scrollElement);
          this._registerResizeListener(scrollElement);
        }
        this._isMounted = true;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        var scrollElement = this.props.scrollElement;
        var prevScrollElement = prevProps.scrollElement;
        if (prevScrollElement !== scrollElement && prevScrollElement != null && scrollElement != null) {
          this.updatePosition(scrollElement);
          unregisterScrollListener(this, prevScrollElement);
          registerScrollListener(this, scrollElement);
          this._unregisterResizeListener(prevScrollElement);
          this._registerResizeListener(scrollElement);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var scrollElement = this.props.scrollElement;
        if (scrollElement) {
          unregisterScrollListener(this, scrollElement);
          this._unregisterResizeListener(scrollElement);
        }
        this._isMounted = false;
      }
    }, {
      key: "render",
      value: function render() {
        var children2 = this.props.children;
        var _this$state2 = this.state, isScrolling = _this$state2.isScrolling, scrollTop = _this$state2.scrollTop, scrollLeft = _this$state2.scrollLeft, height = _this$state2.height, width = _this$state2.width;
        return children2({
          onChildScroll: this._onChildScroll,
          registerChild: this._registerChild,
          height,
          isScrolling,
          scrollLeft,
          scrollTop,
          width
        });
      }
    }]);
    return WindowScroller2;
  }(React98.PureComponent), (0, import_defineProperty18.default)(_class7, "propTypes", false ? null : {
    "children": import_prop_types33.default.func.isRequired,
    "onResize": import_prop_types33.default.func.isRequired,
    "onScroll": import_prop_types33.default.func.isRequired,
    "scrollElement": import_prop_types33.default.oneOfType([import_prop_types33.default.any, function() {
      return (typeof Element === "function" ? import_prop_types33.default.instanceOf(Element) : import_prop_types33.default.any).apply(this, arguments);
    }]),
    "scrollingResetTimeInterval": import_prop_types33.default.number.isRequired,
    "serverHeight": import_prop_types33.default.number.isRequired,
    "serverWidth": import_prop_types33.default.number.isRequired
  }), _temp7);
  (0, import_defineProperty18.default)(WindowScroller, "defaultProps", {
    onResize: function onResize2() {
    },
    onScroll: function onScroll6() {
    },
    scrollingResetTimeInterval: IS_SCROLLING_TIMEOUT2,
    scrollElement: getWindow(),
    serverHeight: 0,
    serverWidth: 0
  });

  // src/components/Users/user.jsx
  function User({ users, fetchMore }) {
    let location = useLocation();
    const onScroll7 = async (tableRef) => {
      if (tableRef) {
        const { scrollTop, scrollHeight, clientHeight, offsetHeight } = tableRef.target;
        console.log({ scrollTop, scrollHeight, clientHeight, offsetHeight });
        if (scrollTop + 1 + clientHeight === scrollHeight) {
          console.log("Reached bottom");
          await fetchMore({
            variables: {
              offset: users.length
            }
          });
        }
      }
    };
    const checkEmpty = (value) => {
      return value ? value : "--";
    };
    const Example = () => /* @__PURE__ */ import_react112.default.createElement(AutoSizer, null, ({ height, width }) => /* @__PURE__ */ import_react112.default.createElement(Table, {
      height,
      rowCount: users.length,
      headerHeight: 50,
      rowHeight: 50,
      width,
      className: "border-b",
      headerClassName: "text-black font-extrabold text-sm px-6 py-4 text-center",
      rowClassName: "border-b hover:bg-gray-200 group",
      rowGetter: ({ index: index2 }) => users[index2]
    }, /* @__PURE__ */ import_react112.default.createElement(Column, {
      className: "text-sm font-medium text-gray-900 px-6 py-4 text-center",
      label: "Name",
      dataKey: "name",
      width,
      cellRenderer: ({ rowData: rowData4 }) => {
        return checkEmpty(rowData4.name);
      }
    }), /* @__PURE__ */ import_react112.default.createElement(Column, {
      className: "text-sm font-medium text-gray-900 px-6 py-4 text-center",
      width,
      label: "Twitter",
      dataKey: "twitter",
      cellRenderer: ({ rowData: rowData4 }) => {
        return checkEmpty(rowData4.twitter);
      }
    }), /* @__PURE__ */ import_react112.default.createElement(Column, {
      className: "text-sm font-medium text-gray-900 px-6 py-4 text-center",
      width,
      label: "Rocket",
      dataKey: "rocket",
      cellRenderer: ({ rowData: rowData4 }) => {
        return checkEmpty(rowData4.rocket);
      }
    }), /* @__PURE__ */ import_react112.default.createElement(Column, {
      width: 200,
      dataKey: "",
      label: "",
      className: "px-8 py-6 w-5 whitespace-nowrap text-sm font-light text-gray-900 invisible group-hover:visible",
      cellRenderer: ({ rowData: rowData4 }) => {
        return /* @__PURE__ */ import_react112.default.createElement(Link, {
          to: {
            pathname: `/users/${rowData4.id}`,
            state: { background: location }
          }
        }, /* @__PURE__ */ import_react112.default.createElement(Icon, {
          source: SvgEditMajor
        }));
      }
    }), /* @__PURE__ */ import_react112.default.createElement(Column, {
      className: "whitespace-nowrap px-8 py-6 w-5 text-sm font-light text-gray-900 invisible group-hover:visible",
      width: 200,
      dataKey: "",
      label: "",
      cellRenderer: ({ rowData: rowData4 }) => {
        return /* @__PURE__ */ import_react112.default.createElement(Link, {
          to: {
            pathname: `/users/delete/${rowData4.id}`,
            state: { background: location }
          }
        }, /* @__PURE__ */ import_react112.default.createElement(Icon, {
          source: SvgDeleteMajor
        }));
      }
    })));
    return /* @__PURE__ */ import_react112.default.createElement("div", {
      className: "h-screen overflow-y-auto",
      onScroll: (e) => onScroll7(e)
    }, /* @__PURE__ */ import_react112.default.createElement(Example, {
      className: "h-screen overflow-y-auto"
    }));
  }
  var user_default = User;

  // node_modules/ts-invariant/node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn
  } = import_tslib.default;

  // node_modules/ts-invariant/lib/invariant.js
  var genericMessage = "Invariant Violation";
  var _a = Object.setPrototypeOf;
  var setPrototypeOf = _a === void 0 ? function(obj, proto2) {
    obj.__proto__ = proto2;
    return obj;
  } : _a;
  var InvariantError = function(_super) {
    __extends(InvariantError2, _super);
    function InvariantError2(message) {
      if (message === void 0) {
        message = genericMessage;
      }
      var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
      _this.framesToPop = 1;
      _this.name = genericMessage;
      setPrototypeOf(_this, InvariantError2.prototype);
      return _this;
    }
    return InvariantError2;
  }(Error);
  function invariant2(condition, message) {
    if (!condition) {
      throw new InvariantError(message);
    }
  }
  var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
  var verbosityLevel = verbosityLevels.indexOf("log");
  function wrapConsoleMethod(name) {
    return function() {
      if (verbosityLevels.indexOf(name) >= verbosityLevel) {
        var method = console[name] || console.log;
        return method.apply(console, arguments);
      }
    };
  }
  (function(invariant4) {
    invariant4.debug = wrapConsoleMethod("debug");
    invariant4.log = wrapConsoleMethod("log");
    invariant4.warn = wrapConsoleMethod("warn");
    invariant4.error = wrapConsoleMethod("error");
  })(invariant2 || (invariant2 = {}));
  function setVerbosity(level) {
    var old = verbosityLevels[verbosityLevel];
    verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
    return old;
  }

  // node_modules/@apollo/client/utilities/globals/maybe.js
  function maybe(thunk) {
    try {
      return thunk();
    } catch (_a5) {
    }
  }

  // node_modules/@apollo/client/utilities/globals/global.js
  var global_default = maybe(function() {
    return globalThis;
  }) || maybe(function() {
    return window;
  }) || maybe(function() {
    return self;
  }) || maybe(function() {
    return global;
  }) || maybe(function() {
    return maybe.constructor("return this")();
  });

  // node_modules/@apollo/client/utilities/globals/DEV.js
  var __ = "__";
  var GLOBAL_KEY = [__, __].join("DEV");
  function getDEV() {
    try {
      return Boolean(__DEV__);
    } catch (_a5) {
      Object.defineProperty(global_default, GLOBAL_KEY, {
        value: maybe(function() {
          return "development";
        }) !== "production",
        enumerable: false,
        configurable: true,
        writable: true
      });
      return global_default[GLOBAL_KEY];
    }
  }
  var DEV_default = getDEV();

  // node_modules/ts-invariant/process/index.js
  function maybe2(thunk) {
    try {
      return thunk();
    } catch (_) {
    }
  }
  var safeGlobal = maybe2(function() {
    return globalThis;
  }) || maybe2(function() {
    return window;
  }) || maybe2(function() {
    return self;
  }) || maybe2(function() {
    return global;
  }) || maybe2(function() {
    return maybe2.constructor("return this")();
  });
  var needToRemove = false;
  function install() {
    if (safeGlobal && !maybe2(function() {
      return "development";
    }) && !maybe2(function() {
      return process;
    })) {
      Object.defineProperty(safeGlobal, "process", {
        value: {
          env: {
            NODE_ENV: "production"
          }
        },
        configurable: true,
        enumerable: false,
        writable: true
      });
      needToRemove = true;
    }
  }
  install();
  function remove() {
    if (needToRemove) {
      delete safeGlobal.process;
      needToRemove = false;
    }
  }

  // node_modules/graphql/jsutils/devAssert.mjs
  function devAssert(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message);
    }
  }

  // node_modules/graphql/jsutils/isObjectLike.mjs
  function isObjectLike(value) {
    return typeof value == "object" && value !== null;
  }

  // node_modules/graphql/jsutils/invariant.mjs
  function invariant3(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message != null ? message : "Unexpected invariant triggered.");
    }
  }

  // node_modules/graphql/language/location.mjs
  var LineRegExp = /\r\n|[\n\r]/g;
  function getLocation(source, position) {
    let lastLineStart = 0;
    let line = 1;
    for (const match of source.body.matchAll(LineRegExp)) {
      typeof match.index === "number" || invariant3(false);
      if (match.index >= position) {
        break;
      }
      lastLineStart = match.index + match[0].length;
      line += 1;
    }
    return {
      line,
      column: position + 1 - lastLineStart
    };
  }

  // node_modules/graphql/language/printLocation.mjs
  function printLocation(location) {
    return printSourceLocation(location.source, getLocation(location.source, location.start));
  }
  function printSourceLocation(source, sourceLocation) {
    const firstLineColumnOffset = source.locationOffset.column - 1;
    const body = "".padStart(firstLineColumnOffset) + source.body;
    const lineIndex = sourceLocation.line - 1;
    const lineOffset = source.locationOffset.line - 1;
    const lineNum = sourceLocation.line + lineOffset;
    const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    const columnNum = sourceLocation.column + columnOffset;
    const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
    const lines = body.split(/\r\n|[\n\r]/g);
    const locationLine = lines[lineIndex];
    if (locationLine.length > 120) {
      const subLineIndex = Math.floor(columnNum / 80);
      const subLineColumnNum = columnNum % 80;
      const subLines = [];
      for (let i = 0; i < locationLine.length; i += 80) {
        subLines.push(locationLine.slice(i, i + 80));
      }
      return locationStr + printPrefixedLines([
        [`${lineNum} |`, subLines[0]],
        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
        ["|", "^".padStart(subLineColumnNum)],
        ["|", subLines[subLineIndex + 1]]
      ]);
    }
    return locationStr + printPrefixedLines([
      [`${lineNum - 1} |`, lines[lineIndex - 1]],
      [`${lineNum} |`, locationLine],
      ["|", "^".padStart(columnNum)],
      [`${lineNum + 1} |`, lines[lineIndex + 1]]
    ]);
  }
  function printPrefixedLines(lines) {
    const existingLines = lines.filter(([_, line]) => line !== void 0);
    const padLen = Math.max(...existingLines.map(([prefix2]) => prefix2.length));
    return existingLines.map(([prefix2, line]) => prefix2.padStart(padLen) + (line ? " " + line : "")).join("\n");
  }

  // node_modules/graphql/error/GraphQLError.mjs
  function toNormalizedOptions(args) {
    const firstArg = args[0];
    if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
      return {
        nodes: firstArg,
        source: args[1],
        positions: args[2],
        path: args[3],
        originalError: args[4],
        extensions: args[5]
      };
    }
    return firstArg;
  }
  var GraphQLError = class extends Error {
    constructor(message, ...rawArgs) {
      var _this$nodes, _nodeLocations$, _ref;
      const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
      super(message);
      this.name = "GraphQLError";
      this.path = path !== null && path !== void 0 ? path : void 0;
      this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
      this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
      const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
      this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
      this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
      this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
      const originalExtensions = isObjectLike(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
      this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
      Object.defineProperties(this, {
        message: {
          writable: true,
          enumerable: true
        },
        name: {
          enumerable: false
        },
        nodes: {
          enumerable: false
        },
        source: {
          enumerable: false
        },
        positions: {
          enumerable: false
        },
        originalError: {
          enumerable: false
        }
      });
      if (originalError !== null && originalError !== void 0 && originalError.stack) {
        Object.defineProperty(this, "stack", {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, GraphQLError);
      } else {
        Object.defineProperty(this, "stack", {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let output = this.message;
      if (this.nodes) {
        for (const node of this.nodes) {
          if (node.loc) {
            output += "\n\n" + printLocation(node.loc);
          }
        }
      } else if (this.source && this.locations) {
        for (const location of this.locations) {
          output += "\n\n" + printSourceLocation(this.source, location);
        }
      }
      return output;
    }
    toJSON() {
      const formattedError = {
        message: this.message
      };
      if (this.locations != null) {
        formattedError.locations = this.locations;
      }
      if (this.path != null) {
        formattedError.path = this.path;
      }
      if (this.extensions != null && Object.keys(this.extensions).length > 0) {
        formattedError.extensions = this.extensions;
      }
      return formattedError;
    }
  };
  function undefinedIfEmpty(array) {
    return array === void 0 || array.length === 0 ? void 0 : array;
  }

  // node_modules/graphql/error/syntaxError.mjs
  function syntaxError(source, position, description) {
    return new GraphQLError(`Syntax Error: ${description}`, {
      source,
      positions: [position]
    });
  }

  // node_modules/graphql/language/ast.mjs
  var Location = class {
    constructor(startToken, endToken, source) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  };
  var Token = class {
    constructor(kind, start, end, line, column, value) {
      this.kind = kind;
      this.start = start;
      this.end = end;
      this.line = line;
      this.column = column;
      this.value = value;
      this.prev = null;
      this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  };
  var QueryDocumentKeys = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"]
  };
  var kindValues = new Set(Object.keys(QueryDocumentKeys));
  function isNode(maybeNode) {
    const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
    return typeof maybeKind === "string" && kindValues.has(maybeKind);
  }
  var OperationTypeNode;
  (function(OperationTypeNode2) {
    OperationTypeNode2["QUERY"] = "query";
    OperationTypeNode2["MUTATION"] = "mutation";
    OperationTypeNode2["SUBSCRIPTION"] = "subscription";
  })(OperationTypeNode || (OperationTypeNode = {}));

  // node_modules/graphql/language/directiveLocation.mjs
  var DirectiveLocation;
  (function(DirectiveLocation2) {
    DirectiveLocation2["QUERY"] = "QUERY";
    DirectiveLocation2["MUTATION"] = "MUTATION";
    DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
    DirectiveLocation2["FIELD"] = "FIELD";
    DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
    DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
    DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
    DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
    DirectiveLocation2["SCHEMA"] = "SCHEMA";
    DirectiveLocation2["SCALAR"] = "SCALAR";
    DirectiveLocation2["OBJECT"] = "OBJECT";
    DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
    DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
    DirectiveLocation2["INTERFACE"] = "INTERFACE";
    DirectiveLocation2["UNION"] = "UNION";
    DirectiveLocation2["ENUM"] = "ENUM";
    DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
    DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
    DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
  })(DirectiveLocation || (DirectiveLocation = {}));

  // node_modules/graphql/language/kinds.mjs
  var Kind;
  (function(Kind2) {
    Kind2["NAME"] = "Name";
    Kind2["DOCUMENT"] = "Document";
    Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
    Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
    Kind2["SELECTION_SET"] = "SelectionSet";
    Kind2["FIELD"] = "Field";
    Kind2["ARGUMENT"] = "Argument";
    Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
    Kind2["INLINE_FRAGMENT"] = "InlineFragment";
    Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
    Kind2["VARIABLE"] = "Variable";
    Kind2["INT"] = "IntValue";
    Kind2["FLOAT"] = "FloatValue";
    Kind2["STRING"] = "StringValue";
    Kind2["BOOLEAN"] = "BooleanValue";
    Kind2["NULL"] = "NullValue";
    Kind2["ENUM"] = "EnumValue";
    Kind2["LIST"] = "ListValue";
    Kind2["OBJECT"] = "ObjectValue";
    Kind2["OBJECT_FIELD"] = "ObjectField";
    Kind2["DIRECTIVE"] = "Directive";
    Kind2["NAMED_TYPE"] = "NamedType";
    Kind2["LIST_TYPE"] = "ListType";
    Kind2["NON_NULL_TYPE"] = "NonNullType";
    Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
    Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
    Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
    Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
    Kind2["FIELD_DEFINITION"] = "FieldDefinition";
    Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
    Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
    Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
    Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
    Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
    Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
    Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
    Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
    Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
    Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
    Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
    Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
    Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
    Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
  })(Kind || (Kind = {}));

  // node_modules/graphql/language/characterClasses.mjs
  function isWhiteSpace(code) {
    return code === 9 || code === 32;
  }
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isLetter(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
  }
  function isNameStart(code) {
    return isLetter(code) || code === 95;
  }
  function isNameContinue(code) {
    return isLetter(code) || isDigit(code) || code === 95;
  }

  // node_modules/graphql/language/blockString.mjs
  function dedentBlockStringLines(lines) {
    var _firstNonEmptyLine2;
    let commonIndent = Number.MAX_SAFE_INTEGER;
    let firstNonEmptyLine = null;
    let lastNonEmptyLine = -1;
    for (let i = 0; i < lines.length; ++i) {
      var _firstNonEmptyLine;
      const line = lines[i];
      const indent2 = leadingWhitespace(line);
      if (indent2 === line.length) {
        continue;
      }
      firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
      lastNonEmptyLine = i;
      if (i !== 0 && indent2 < commonIndent) {
        commonIndent = indent2;
      }
    }
    return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
  }
  function leadingWhitespace(str) {
    let i = 0;
    while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
      ++i;
    }
    return i;
  }
  function printBlockString(value, options) {
    const escapedValue = value.replace(/"""/g, '\\"""');
    const lines = escapedValue.split(/\r\n|[\n\r]/g);
    const isSingleLine = lines.length === 1;
    const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
    const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
    const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
    const hasTrailingSlash = value.endsWith("\\");
    const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
    const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
    let result2 = "";
    const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
    if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
      result2 += "\n";
    }
    result2 += escapedValue;
    if (printAsMultipleLines || forceTrailingNewline) {
      result2 += "\n";
    }
    return '"""' + result2 + '"""';
  }

  // node_modules/graphql/language/tokenKind.mjs
  var TokenKind;
  (function(TokenKind2) {
    TokenKind2["SOF"] = "<SOF>";
    TokenKind2["EOF"] = "<EOF>";
    TokenKind2["BANG"] = "!";
    TokenKind2["DOLLAR"] = "$";
    TokenKind2["AMP"] = "&";
    TokenKind2["PAREN_L"] = "(";
    TokenKind2["PAREN_R"] = ")";
    TokenKind2["SPREAD"] = "...";
    TokenKind2["COLON"] = ":";
    TokenKind2["EQUALS"] = "=";
    TokenKind2["AT"] = "@";
    TokenKind2["BRACKET_L"] = "[";
    TokenKind2["BRACKET_R"] = "]";
    TokenKind2["BRACE_L"] = "{";
    TokenKind2["PIPE"] = "|";
    TokenKind2["BRACE_R"] = "}";
    TokenKind2["NAME"] = "Name";
    TokenKind2["INT"] = "Int";
    TokenKind2["FLOAT"] = "Float";
    TokenKind2["STRING"] = "String";
    TokenKind2["BLOCK_STRING"] = "BlockString";
    TokenKind2["COMMENT"] = "Comment";
  })(TokenKind || (TokenKind = {}));

  // node_modules/graphql/language/lexer.mjs
  var Lexer = class {
    constructor(source) {
      const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
      this.source = source;
      this.lastToken = startOfFileToken;
      this.token = startOfFileToken;
      this.line = 1;
      this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    advance() {
      this.lastToken = this.token;
      const token = this.token = this.lookahead();
      return token;
    }
    lookahead() {
      let token = this.token;
      if (token.kind !== TokenKind.EOF) {
        do {
          if (token.next) {
            token = token.next;
          } else {
            const nextToken = readNextToken(this, token.end);
            token.next = nextToken;
            nextToken.prev = token;
            token = nextToken;
          }
        } while (token.kind === TokenKind.COMMENT);
      }
      return token;
    }
  };
  function isPunctuatorTokenKind(kind) {
    return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
  }
  function isUnicodeScalarValue(code) {
    return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
  }
  function isSupplementaryCodePoint(body, location) {
    return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
  }
  function isLeadingSurrogate(code) {
    return code >= 55296 && code <= 56319;
  }
  function isTrailingSurrogate(code) {
    return code >= 56320 && code <= 57343;
  }
  function printCodePointAt(lexer, location) {
    const code = lexer.source.body.codePointAt(location);
    if (code === void 0) {
      return TokenKind.EOF;
    } else if (code >= 32 && code <= 126) {
      const char = String.fromCodePoint(code);
      return char === '"' ? `'"'` : `"${char}"`;
    }
    return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
  }
  function createToken(lexer, kind, start, end, value) {
    const line = lexer.line;
    const col = 1 + start - lexer.lineStart;
    return new Token(kind, start, end, line, col, value);
  }
  function readNextToken(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      switch (code) {
        case 65279:
        case 9:
        case 32:
        case 44:
          ++position;
          continue;
        case 10:
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 13:
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 35:
          return readComment(lexer, position);
        case 33:
          return createToken(lexer, TokenKind.BANG, position, position + 1);
        case 36:
          return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
        case 38:
          return createToken(lexer, TokenKind.AMP, position, position + 1);
        case 40:
          return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
        case 41:
          return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
        case 46:
          if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
            return createToken(lexer, TokenKind.SPREAD, position, position + 3);
          }
          break;
        case 58:
          return createToken(lexer, TokenKind.COLON, position, position + 1);
        case 61:
          return createToken(lexer, TokenKind.EQUALS, position, position + 1);
        case 64:
          return createToken(lexer, TokenKind.AT, position, position + 1);
        case 91:
          return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
        case 93:
          return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
        case 123:
          return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
        case 124:
          return createToken(lexer, TokenKind.PIPE, position, position + 1);
        case 125:
          return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
        case 34:
          if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            return readBlockString(lexer, position);
          }
          return readString(lexer, position);
      }
      if (isDigit(code) || code === 45) {
        return readNumber(lexer, position, code);
      }
      if (isNameStart(code)) {
        return readName(lexer, position);
      }
      throw syntaxError(lexer.source, position, code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
    }
    return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
  }
  function readComment(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        break;
      }
    }
    return createToken(lexer, TokenKind.COMMENT, start, position, body.slice(start + 1, position));
  }
  function readNumber(lexer, start, firstCode) {
    const body = lexer.source.body;
    let position = start;
    let code = firstCode;
    let isFloat = false;
    if (code === 45) {
      code = body.charCodeAt(++position);
    }
    if (code === 48) {
      code = body.charCodeAt(++position);
      if (isDigit(code)) {
        throw syntaxError(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
      }
    } else {
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46) {
      isFloat = true;
      code = body.charCodeAt(++position);
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = body.charCodeAt(++position);
      if (code === 43 || code === 45) {
        code = body.charCodeAt(++position);
      }
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46 || isNameStart(code)) {
      throw syntaxError(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
    }
    return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, body.slice(start, position));
  }
  function readDigits(lexer, start, firstCode) {
    if (!isDigit(firstCode)) {
      throw syntaxError(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
    }
    const body = lexer.source.body;
    let position = start + 1;
    while (isDigit(body.charCodeAt(position))) {
      ++position;
    }
    return position;
  }
  function readString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    let chunkStart = position;
    let value = "";
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34) {
        value += body.slice(chunkStart, position);
        return createToken(lexer, TokenKind.STRING, start, position + 1, value);
      }
      if (code === 92) {
        value += body.slice(chunkStart, position);
        const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
        value += escape.value;
        position += escape.size;
        chunkStart = position;
        continue;
      }
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readEscapedUnicodeVariableWidth(lexer, position) {
    const body = lexer.source.body;
    let point = 0;
    let size2 = 3;
    while (size2 < 12) {
      const code = body.charCodeAt(position + size2++);
      if (code === 125) {
        if (size2 < 5 || !isUnicodeScalarValue(point)) {
          break;
        }
        return {
          value: String.fromCodePoint(point),
          size: size2
        };
      }
      point = point << 4 | readHexDigit(code);
      if (point < 0) {
        break;
      }
    }
    throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size2)}".`);
  }
  function readEscapedUnicodeFixedWidth(lexer, position) {
    const body = lexer.source.body;
    const code = read16BitHexCode(body, position + 2);
    if (isUnicodeScalarValue(code)) {
      return {
        value: String.fromCodePoint(code),
        size: 6
      };
    }
    if (isLeadingSurrogate(code)) {
      if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
        const trailingCode = read16BitHexCode(body, position + 8);
        if (isTrailingSurrogate(trailingCode)) {
          return {
            value: String.fromCodePoint(code, trailingCode),
            size: 12
          };
        }
      }
    }
    throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
  }
  function read16BitHexCode(body, position) {
    return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
  }
  function readHexDigit(code) {
    return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
  }
  function readEscapedCharacter(lexer, position) {
    const body = lexer.source.body;
    const code = body.charCodeAt(position + 1);
    switch (code) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: "\n",
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "	",
          size: 2
        };
    }
    throw syntaxError(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
  }
  function readBlockString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let lineStart = lexer.lineStart;
    let position = start + 3;
    let chunkStart = position;
    let currentLine = "";
    const blockLines = [];
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        const token = createToken(lexer, TokenKind.BLOCK_STRING, start, position + 3, dedentBlockStringLines(blockLines).join("\n"));
        lexer.line += blockLines.length - 1;
        lexer.lineStart = lineStart;
        return token;
      }
      if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
        currentLine += body.slice(chunkStart, position);
        chunkStart = position + 1;
        position += 4;
        continue;
      }
      if (code === 10 || code === 13) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        if (code === 13 && body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        currentLine = "";
        chunkStart = position;
        lineStart = position;
        continue;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readName(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (isNameContinue(code)) {
        ++position;
      } else {
        break;
      }
    }
    return createToken(lexer, TokenKind.NAME, start, position, body.slice(start, position));
  }

  // node_modules/graphql/jsutils/inspect.mjs
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
  function inspect(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function isJSONable(value) {
    return typeof value.toJSON === "function";
  }
  function formatObject(object, seenValues) {
    const entries = Object.entries(object);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object) + "]";
    }
    const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array, seenValues) {
    if (array.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array.length);
    const remaining = array.length - len;
    const items = [];
    for (let i = 0; i < len; ++i) {
      items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  }
  function getObjectTag(object) {
    const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
      const name = object.constructor.name;
      if (typeof name === "string" && name !== "") {
        return name;
      }
    }
    return tag;
  }

  // node_modules/graphql/jsutils/instanceOf.mjs
  var instanceOf = false ? function instanceOf2(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf3(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
      if (className === valueClassName) {
        const stringifiedValue = inspect(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  };

  // node_modules/graphql/language/source.mjs
  var Source = class {
    constructor(body, name = "GraphQL request", locationOffset = {
      line: 1,
      column: 1
    }) {
      typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
      this.body = body;
      this.name = name;
      this.locationOffset = locationOffset;
      this.locationOffset.line > 0 || devAssert(false, "line in locationOffset is 1-indexed and must be positive.");
      this.locationOffset.column > 0 || devAssert(false, "column in locationOffset is 1-indexed and must be positive.");
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  };
  function isSource(source) {
    return instanceOf(source, Source);
  }

  // node_modules/graphql/language/parser.mjs
  function parse(source, options) {
    const parser2 = new Parser(source, options);
    return parser2.parseDocument();
  }
  var Parser = class {
    constructor(source, options) {
      const sourceObj = isSource(source) ? source : new Source(source);
      this._lexer = new Lexer(sourceObj);
      this._options = options;
    }
    parseName() {
      const token = this.expectToken(TokenKind.NAME);
      return this.node(token, {
        kind: Kind.NAME,
        value: token.value
      });
    }
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: Kind.DOCUMENT,
        definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)
      });
    }
    parseDefinition() {
      if (this.peek(TokenKind.BRACE_L)) {
        return this.parseOperationDefinition();
      }
      const hasDescription = this.peekDescription();
      const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        if (hasDescription) {
          throw syntaxError(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
        }
        switch (keywordToken.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    parseOperationDefinition() {
      const start = this._lexer.token;
      if (this.peek(TokenKind.BRACE_L)) {
        return this.node(start, {
          kind: Kind.OPERATION_DEFINITION,
          operation: OperationTypeNode.QUERY,
          name: void 0,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      }
      const operation = this.parseOperationType();
      let name;
      if (this.peek(TokenKind.NAME)) {
        name = this.parseName();
      }
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation,
        name,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    parseOperationType() {
      const operationToken = this.expectToken(TokenKind.NAME);
      switch (operationToken.value) {
        case "query":
          return OperationTypeNode.QUERY;
        case "mutation":
          return OperationTypeNode.MUTATION;
        case "subscription":
          return OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(operationToken);
    }
    parseVariableDefinitions() {
      return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
    }
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
        directives: this.parseConstDirectives()
      });
    }
    parseVariable() {
      const start = this._lexer.token;
      this.expectToken(TokenKind.DOLLAR);
      return this.node(start, {
        kind: Kind.VARIABLE,
        name: this.parseName()
      });
    }
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: Kind.SELECTION_SET,
        selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)
      });
    }
    parseSelection() {
      return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    parseField() {
      const start = this._lexer.token;
      const nameOrAlias = this.parseName();
      let alias;
      let name;
      if (this.expectOptionalToken(TokenKind.COLON)) {
        alias = nameOrAlias;
        name = this.parseName();
      } else {
        name = nameOrAlias;
      }
      return this.node(start, {
        kind: Kind.FIELD,
        alias,
        name,
        arguments: this.parseArguments(false),
        directives: this.parseDirectives(false),
        selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
      });
    }
    parseArguments(isConst) {
      const item = isConst ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
    }
    parseArgument(isConst = false) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start, {
        kind: Kind.ARGUMENT,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseConstArgument() {
      return this.parseArgument(true);
    }
    parseFragment() {
      const start = this._lexer.token;
      this.expectToken(TokenKind.SPREAD);
      const hasTypeCondition = this.expectOptionalKeyword("on");
      if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
        return this.node(start, {
          kind: Kind.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(false)
        });
      }
      return this.node(start, {
        kind: Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    parseFragmentDefinition() {
      var _this$_options;
      const start = this._lexer.token;
      this.expectKeyword("fragment");
      if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.allowLegacyFragmentVariables) === true) {
        return this.node(start, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    parseFragmentName() {
      if (this._lexer.token.value === "on") {
        throw this.unexpected();
      }
      return this.parseName();
    }
    parseValueLiteral(isConst) {
      const token = this._lexer.token;
      switch (token.kind) {
        case TokenKind.BRACKET_L:
          return this.parseList(isConst);
        case TokenKind.BRACE_L:
          return this.parseObject(isConst);
        case TokenKind.INT:
          this._lexer.advance();
          return this.node(token, {
            kind: Kind.INT,
            value: token.value
          });
        case TokenKind.FLOAT:
          this._lexer.advance();
          return this.node(token, {
            kind: Kind.FLOAT,
            value: token.value
          });
        case TokenKind.STRING:
        case TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case TokenKind.NAME:
          this._lexer.advance();
          switch (token.value) {
            case "true":
              return this.node(token, {
                kind: Kind.BOOLEAN,
                value: true
              });
            case "false":
              return this.node(token, {
                kind: Kind.BOOLEAN,
                value: false
              });
            case "null":
              return this.node(token, {
                kind: Kind.NULL
              });
            default:
              return this.node(token, {
                kind: Kind.ENUM,
                value: token.value
              });
          }
        case TokenKind.DOLLAR:
          if (isConst) {
            this.expectToken(TokenKind.DOLLAR);
            if (this._lexer.token.kind === TokenKind.NAME) {
              const varName = this._lexer.token.value;
              throw syntaxError(this._lexer.source, token.start, `Unexpected variable "$${varName}" in constant value.`);
            } else {
              throw this.unexpected(token);
            }
          }
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(true);
    }
    parseStringLiteral() {
      const token = this._lexer.token;
      this._lexer.advance();
      return this.node(token, {
        kind: Kind.STRING,
        value: token.value,
        block: token.kind === TokenKind.BLOCK_STRING
      });
    }
    parseList(isConst) {
      const item = () => this.parseValueLiteral(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.LIST,
        values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
      });
    }
    parseObject(isConst) {
      const item = () => this.parseObjectField(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.OBJECT,
        fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
      });
    }
    parseObjectField(isConst) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start, {
        kind: Kind.OBJECT_FIELD,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseDirectives(isConst) {
      const directives = [];
      while (this.peek(TokenKind.AT)) {
        directives.push(this.parseDirective(isConst));
      }
      return directives;
    }
    parseConstDirectives() {
      return this.parseDirectives(true);
    }
    parseDirective(isConst) {
      const start = this._lexer.token;
      this.expectToken(TokenKind.AT);
      return this.node(start, {
        kind: Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(isConst)
      });
    }
    parseTypeReference() {
      const start = this._lexer.token;
      let type;
      if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
        const innerType = this.parseTypeReference();
        this.expectToken(TokenKind.BRACKET_R);
        type = this.node(start, {
          kind: Kind.LIST_TYPE,
          type: innerType
        });
      } else {
        type = this.parseNamedType();
      }
      if (this.expectOptionalToken(TokenKind.BANG)) {
        return this.node(start, {
          kind: Kind.NON_NULL_TYPE,
          type
        });
      }
      return type;
    }
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    peekDescription() {
      return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
    }
    parseDescription() {
      if (this.peekDescription()) {
        return this.parseStringLiteral();
      }
    }
    parseSchemaDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
      return this.node(start, {
        kind: Kind.SCHEMA_DEFINITION,
        description,
        directives,
        operationTypes
      });
    }
    parseOperationTypeDefinition() {
      const start = this._lexer.token;
      const operation = this.parseOperationType();
      this.expectToken(TokenKind.COLON);
      const type = this.parseNamedType();
      return this.node(start, {
        kind: Kind.OPERATION_TYPE_DEFINITION,
        operation,
        type
      });
    }
    parseScalarTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.SCALAR_TYPE_DEFINITION,
        description,
        name,
        directives
      });
    }
    parseObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: Kind.OBJECT_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
    }
    parseFieldsDefinition() {
      return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
    }
    parseFieldDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      this.expectToken(TokenKind.COLON);
      const type = this.parseTypeReference();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.FIELD_DEFINITION,
        description,
        name,
        arguments: args,
        type,
        directives
      });
    }
    parseArgumentDefs() {
      return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
    }
    parseInputValueDef() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      const type = this.parseTypeReference();
      let defaultValue;
      if (this.expectOptionalToken(TokenKind.EQUALS)) {
        defaultValue = this.parseConstValueLiteral();
      }
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.INPUT_VALUE_DEFINITION,
        description,
        name,
        type,
        defaultValue,
        directives
      });
    }
    parseInterfaceTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseUnionTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types = this.parseUnionMemberTypes();
      return this.node(start, {
        kind: Kind.UNION_TYPE_DEFINITION,
        description,
        name,
        directives,
        types
      });
    }
    parseUnionMemberTypes() {
      return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
    }
    parseEnumTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values2 = this.parseEnumValuesDefinition();
      return this.node(start, {
        kind: Kind.ENUM_TYPE_DEFINITION,
        description,
        name,
        directives,
        values: values2
      });
    }
    parseEnumValuesDefinition() {
      return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
    }
    parseEnumValueDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseEnumValueName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.ENUM_VALUE_DEFINITION,
        description,
        name,
        directives
      });
    }
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
        throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
      }
      return this.parseName();
    }
    parseInputObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      return this.node(start, {
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description,
        name,
        directives,
        fields
      });
    }
    parseInputFieldsDefinition() {
      return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
    }
    parseTypeSystemExtension() {
      const keywordToken = this._lexer.lookahead();
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    parseSchemaExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
      if (directives.length === 0 && operationTypes.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.SCHEMA_EXTENSION,
        directives,
        operationTypes
      });
    }
    parseScalarTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      if (directives.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.SCALAR_TYPE_EXTENSION,
        name,
        directives
      });
    }
    parseObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.OBJECT_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseInterfaceTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    parseUnionTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types = this.parseUnionMemberTypes();
      if (directives.length === 0 && types.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.UNION_TYPE_EXTENSION,
        name,
        directives,
        types
      });
    }
    parseEnumTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values2 = this.parseEnumValuesDefinition();
      if (directives.length === 0 && values2.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.ENUM_TYPE_EXTENSION,
        name,
        directives,
        values: values2
      });
    }
    parseInputObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      if (directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name,
        directives,
        fields
      });
    }
    parseDirectiveDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("directive");
      this.expectToken(TokenKind.AT);
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      const repeatable = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const locations = this.parseDirectiveLocations();
      return this.node(start, {
        kind: Kind.DIRECTIVE_DEFINITION,
        description,
        name,
        arguments: args,
        repeatable,
        locations
      });
    }
    parseDirectiveLocations() {
      return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
    }
    parseDirectiveLocation() {
      const start = this._lexer.token;
      const name = this.parseName();
      if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
        return name;
      }
      throw this.unexpected(start);
    }
    node(startToken, node) {
      var _this$_options2;
      if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.noLocation) !== true) {
        node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);
      }
      return node;
    }
    peek(kind) {
      return this._lexer.token.kind === kind;
    }
    expectToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this._lexer.advance();
        return token;
      }
      throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
    }
    expectOptionalToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this._lexer.advance();
        return true;
      }
      return false;
    }
    expectKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this._lexer.advance();
      } else {
        throw syntaxError(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
      }
    }
    expectOptionalKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this._lexer.advance();
        return true;
      }
      return false;
    }
    unexpected(atToken) {
      const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
      return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
    }
    any(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      while (!this.expectOptionalToken(closeKind)) {
        nodes.push(parseFn.call(this));
      }
      return nodes;
    }
    optionalMany(openKind, parseFn, closeKind) {
      if (this.expectOptionalToken(openKind)) {
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      return [];
    }
    many(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    delimitedMany(delimiterKind, parseFn) {
      this.expectOptionalToken(delimiterKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (this.expectOptionalToken(delimiterKind));
      return nodes;
    }
  };
  function getTokenDesc(token) {
    const value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
  }
  function getTokenKindDesc(kind) {
    return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
  }

  // node_modules/graphql/language/printString.mjs
  function printString(str) {
    return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
  }
  var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
  function escapedReplacer(str) {
    return escapeSequences[str.charCodeAt(0)];
  }
  var escapeSequences = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    '\\"',
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
  ];

  // node_modules/graphql/language/visitor.mjs
  var BREAK = Object.freeze({});
  function visit(root2, visitor, visitorKeys = QueryDocumentKeys) {
    const enterLeaveMap = /* @__PURE__ */ new Map();
    for (const kind of Object.values(Kind)) {
      enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
    }
    let stack = void 0;
    let inArray = Array.isArray(root2);
    let keys = [root2];
    let index2 = -1;
    let edits = [];
    let node = root2;
    let key = void 0;
    let parent = void 0;
    const path = [];
    const ancestors = [];
    do {
      index2++;
      const isLeaving = index2 === keys.length;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? void 0 : path[path.length - 1];
        node = parent;
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node = node.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === null) {
                node.splice(arrayKey, 1);
                editOffset++;
              } else {
                node[arrayKey] = editValue;
              }
            }
          } else {
            node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
            for (const [editKey, editValue] of edits) {
              node[editKey] = editValue;
            }
          }
        }
        index2 = stack.index;
        keys = stack.keys;
        edits = stack.edits;
        inArray = stack.inArray;
        stack = stack.prev;
      } else if (parent) {
        key = inArray ? index2 : keys[index2];
        node = parent[key];
        if (node === null || node === void 0) {
          continue;
        }
        path.push(key);
      }
      let result2;
      if (!Array.isArray(node)) {
        var _enterLeaveMap$get, _enterLeaveMap$get2;
        isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
        const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
        result2 = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
        if (result2 === BREAK) {
          break;
        }
        if (result2 === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result2 !== void 0) {
          edits.push([key, result2]);
          if (!isLeaving) {
            if (isNode(result2)) {
              node = result2;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
      if (result2 === void 0 && isEdited) {
        edits.push([key, node]);
      }
      if (isLeaving) {
        path.pop();
      } else {
        var _node$kind;
        stack = {
          inArray,
          index: index2,
          keys,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node);
        keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
        index2 = -1;
        edits = [];
        if (parent) {
          ancestors.push(parent);
        }
        parent = node;
      }
    } while (stack !== void 0);
    if (edits.length !== 0) {
      return edits[edits.length - 1][1];
    }
    return root2;
  }
  function getEnterLeaveForKind(visitor, kind) {
    const kindVisitor = visitor[kind];
    if (typeof kindVisitor === "object") {
      return kindVisitor;
    } else if (typeof kindVisitor === "function") {
      return {
        enter: kindVisitor,
        leave: void 0
      };
    }
    return {
      enter: visitor.enter,
      leave: visitor.leave
    };
  }

  // node_modules/graphql/language/printer.mjs
  function print(ast) {
    return visit(ast, printDocASTReducer);
  }
  var MAX_LINE_LENGTH = 80;
  var printDocASTReducer = {
    Name: {
      leave: (node) => node.value
    },
    Variable: {
      leave: (node) => "$" + node.name
    },
    Document: {
      leave: (node) => join(node.definitions, "\n\n")
    },
    OperationDefinition: {
      leave(node) {
        const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
        const prefix2 = join([
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ], " ");
        return (prefix2 === "query" ? "" : prefix2 + " ") + node.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
    },
    SelectionSet: {
      leave: ({ selections }) => block(selections)
    },
    Field: {
      leave({ alias, name, arguments: args, directives, selectionSet }) {
        const prefix2 = wrap("", alias, ": ") + name;
        let argsLine = prefix2 + wrap("(", join(args, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix2 + wrap("(\n", indent(join(args, "\n")), "\n)");
        }
        return join([argsLine, join(directives, " "), selectionSet], " ");
      }
    },
    Argument: {
      leave: ({ name, value }) => name + ": " + value
    },
    FragmentSpread: {
      leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition, directives, selectionSet }) => join([
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ], " ")
    },
    FragmentDefinition: {
      leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    },
    IntValue: {
      leave: ({ value }) => value
    },
    FloatValue: {
      leave: ({ value }) => value
    },
    StringValue: {
      leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
    },
    BooleanValue: {
      leave: ({ value }) => value ? "true" : "false"
    },
    NullValue: {
      leave: () => "null"
    },
    EnumValue: {
      leave: ({ value }) => value
    },
    ListValue: {
      leave: ({ values: values2 }) => "[" + join(values2, ", ") + "]"
    },
    ObjectValue: {
      leave: ({ fields }) => "{" + join(fields, ", ") + "}"
    },
    ObjectField: {
      leave: ({ name, value }) => name + ": " + value
    },
    Directive: {
      leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
    },
    NamedType: {
      leave: ({ name }) => name
    },
    ListType: {
      leave: ({ type }) => "[" + type + "]"
    },
    NonNullType: {
      leave: ({ type }) => type + "!"
    },
    SchemaDefinition: {
      leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation, type }) => operation + ": " + type
    },
    ScalarTypeDefinition: {
      leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    FieldDefinition: {
      leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
    },
    InputValueDefinition: {
      leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
    },
    InterfaceTypeDefinition: {
      leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    UnionTypeDefinition: {
      leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
    },
    EnumTypeDefinition: {
      leave: ({ description, name, directives, values: values2 }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values2)], " ")
    },
    EnumValueDefinition: {
      leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
    },
    DirectiveDefinition: {
      leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
    },
    SchemaExtension: {
      leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
    },
    ScalarTypeExtension: {
      leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join([
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    InterfaceTypeExtension: {
      leave: ({ name, interfaces, directives, fields }) => join([
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ], " ")
    },
    UnionTypeExtension: {
      leave: ({ name, directives, types }) => join([
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ], " ")
    },
    EnumTypeExtension: {
      leave: ({ name, directives, values: values2 }) => join(["extend enum", name, join(directives, " "), block(values2)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
    }
  };
  function join(maybeArray, separator = "") {
    var _maybeArray$filter$jo;
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
  }
  function block(array) {
    return wrap("{\n", indent(join(array, "\n")), "\n}");
  }
  function wrap(start, maybeString, end = "") {
    return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
  }
  function indent(str) {
    return wrap("  ", str.replace(/\n/g, "\n  "));
  }
  function hasMultilineItems(maybeArray) {
    var _maybeArray$some;
    return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
  }

  // node_modules/@apollo/client/utilities/globals/fix-graphql.js
  function removeTemporaryGlobals() {
    return typeof Source === "function" ? remove() : remove();
  }

  // node_modules/@apollo/client/utilities/globals/index.js
  function checkDEV() {
    __DEV__ ? invariant2(typeof DEV_default === "boolean", DEV_default) : invariant2(typeof DEV_default === "boolean", 36);
  }
  removeTemporaryGlobals();
  checkDEV();

  // node_modules/@apollo/client/node_modules/tslib/modules/index.js
  var import_tslib3 = __toESM(require_tslib2(), 1);
  var {
    __extends: __extends2,
    __assign: __assign2,
    __rest: __rest2,
    __decorate: __decorate2,
    __param: __param2,
    __metadata: __metadata2,
    __awaiter: __awaiter2,
    __generator: __generator2,
    __exportStar: __exportStar2,
    __createBinding: __createBinding2,
    __values: __values2,
    __read: __read2,
    __spread: __spread2,
    __spreadArrays: __spreadArrays2,
    __spreadArray: __spreadArray2,
    __await: __await2,
    __asyncGenerator: __asyncGenerator2,
    __asyncDelegator: __asyncDelegator2,
    __asyncValues: __asyncValues2,
    __makeTemplateObject: __makeTemplateObject2,
    __importStar: __importStar2,
    __importDefault: __importDefault2,
    __classPrivateFieldGet: __classPrivateFieldGet2,
    __classPrivateFieldSet: __classPrivateFieldSet2,
    __classPrivateFieldIn: __classPrivateFieldIn2
  } = import_tslib3.default;

  // node_modules/@apollo/client/utilities/graphql/directives.js
  function shouldInclude(_a5, variables) {
    var directives = _a5.directives;
    if (!directives || !directives.length) {
      return true;
    }
    return getInclusionDirectives(directives).every(function(_a6) {
      var directive = _a6.directive, ifArgument = _a6.ifArgument;
      var evaledValue = false;
      if (ifArgument.value.kind === "Variable") {
        evaledValue = variables && variables[ifArgument.value.name.value];
        __DEV__ ? invariant2(evaledValue !== void 0, "Invalid variable referenced in @".concat(directive.name.value, " directive.")) : invariant2(evaledValue !== void 0, 37);
      } else {
        evaledValue = ifArgument.value.value;
      }
      return directive.name.value === "skip" ? !evaledValue : evaledValue;
    });
  }
  function getDirectiveNames(root2) {
    var names = [];
    visit(root2, {
      Directive: function(node) {
        names.push(node.name.value);
      }
    });
    return names;
  }
  function hasDirectives(names, root2) {
    return getDirectiveNames(root2).some(function(name) {
      return names.indexOf(name) > -1;
    });
  }
  function hasClientExports(document2) {
    return document2 && hasDirectives(["client"], document2) && hasDirectives(["export"], document2);
  }
  function isInclusionDirective(_a5) {
    var value = _a5.name.value;
    return value === "skip" || value === "include";
  }
  function getInclusionDirectives(directives) {
    var result2 = [];
    if (directives && directives.length) {
      directives.forEach(function(directive) {
        if (!isInclusionDirective(directive))
          return;
        var directiveArguments = directive.arguments;
        var directiveName = directive.name.value;
        __DEV__ ? invariant2(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @".concat(directiveName, " directive.")) : invariant2(directiveArguments && directiveArguments.length === 1, 38);
        var ifArgument = directiveArguments[0];
        __DEV__ ? invariant2(ifArgument.name && ifArgument.name.value === "if", "Invalid argument for the @".concat(directiveName, " directive.")) : invariant2(ifArgument.name && ifArgument.name.value === "if", 39);
        var ifValue = ifArgument.value;
        __DEV__ ? invariant2(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), "Argument for the @".concat(directiveName, " directive must be a variable or a boolean value.")) : invariant2(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 40);
        result2.push({ directive, ifArgument });
      });
    }
    return result2;
  }

  // node_modules/@apollo/client/utilities/graphql/fragments.js
  function createFragmentMap(fragments) {
    if (fragments === void 0) {
      fragments = [];
    }
    var symTable = {};
    fragments.forEach(function(fragment) {
      symTable[fragment.name.value] = fragment;
    });
    return symTable;
  }

  // node_modules/@apollo/client/utilities/common/objects.js
  function isNonNullObject(obj) {
    return obj !== null && typeof obj === "object";
  }

  // node_modules/@apollo/client/utilities/graphql/storeUtils.js
  function isDocumentNode(value) {
    return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
  }
  function isStringValue(value) {
    return value.kind === "StringValue";
  }
  function isBooleanValue(value) {
    return value.kind === "BooleanValue";
  }
  function isIntValue(value) {
    return value.kind === "IntValue";
  }
  function isFloatValue(value) {
    return value.kind === "FloatValue";
  }
  function isVariable(value) {
    return value.kind === "Variable";
  }
  function isObjectValue(value) {
    return value.kind === "ObjectValue";
  }
  function isListValue(value) {
    return value.kind === "ListValue";
  }
  function isEnumValue(value) {
    return value.kind === "EnumValue";
  }
  function isNullValue(value) {
    return value.kind === "NullValue";
  }
  function valueToObjectRepresentation(argObj, name, value, variables) {
    if (isIntValue(value) || isFloatValue(value)) {
      argObj[name.value] = Number(value.value);
    } else if (isBooleanValue(value) || isStringValue(value)) {
      argObj[name.value] = value.value;
    } else if (isObjectValue(value)) {
      var nestedArgObj_1 = {};
      value.fields.map(function(obj) {
        return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
      });
      argObj[name.value] = nestedArgObj_1;
    } else if (isVariable(value)) {
      var variableValue = (variables || {})[value.name.value];
      argObj[name.value] = variableValue;
    } else if (isListValue(value)) {
      argObj[name.value] = value.values.map(function(listValue) {
        var nestedArgArrayObj = {};
        valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
        return nestedArgArrayObj[name.value];
      });
    } else if (isEnumValue(value)) {
      argObj[name.value] = value.value;
    } else if (isNullValue(value)) {
      argObj[name.value] = null;
    } else {
      throw __DEV__ ? new InvariantError('The inline argument "'.concat(name.value, '" of kind "').concat(value.kind, '"') + "is not supported. Use variables instead of inline arguments to overcome this limitation.") : new InvariantError(52);
    }
  }
  var KNOWN_DIRECTIVES = [
    "connection",
    "include",
    "skip",
    "client",
    "rest",
    "export"
  ];
  var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
    if (args && directives && directives["connection"] && directives["connection"]["key"]) {
      if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
        var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
        filterKeys.sort();
        var filteredArgs_1 = {};
        filterKeys.forEach(function(key) {
          filteredArgs_1[key] = args[key];
        });
        return "".concat(directives["connection"]["key"], "(").concat(stringify(filteredArgs_1), ")");
      } else {
        return directives["connection"]["key"];
      }
    }
    var completeFieldName = fieldName;
    if (args) {
      var stringifiedArgs = stringify(args);
      completeFieldName += "(".concat(stringifiedArgs, ")");
    }
    if (directives) {
      Object.keys(directives).forEach(function(key) {
        if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
          return;
        if (directives[key] && Object.keys(directives[key]).length) {
          completeFieldName += "@".concat(key, "(").concat(stringify(directives[key]), ")");
        } else {
          completeFieldName += "@".concat(key);
        }
      });
    }
    return completeFieldName;
  }, {
    setStringify: function(s) {
      var previous = stringify;
      stringify = s;
      return previous;
    }
  });
  var stringify = function defaultStringify(value) {
    return JSON.stringify(value, stringifyReplacer);
  };
  function stringifyReplacer(_key, value) {
    if (isNonNullObject(value) && !Array.isArray(value)) {
      value = Object.keys(value).sort().reduce(function(copy2, key) {
        copy2[key] = value[key];
        return copy2;
      }, {});
    }
    return value;
  }
  function argumentsObjectFromField(field, variables) {
    if (field.arguments && field.arguments.length) {
      var argObj_1 = {};
      field.arguments.forEach(function(_a5) {
        var name = _a5.name, value = _a5.value;
        return valueToObjectRepresentation(argObj_1, name, value, variables);
      });
      return argObj_1;
    }
    return null;
  }
  function resultKeyNameFromField(field) {
    return field.alias ? field.alias.value : field.name.value;
  }
  function isField(selection) {
    return selection.kind === "Field";
  }
  function isInlineFragment(selection) {
    return selection.kind === "InlineFragment";
  }

  // node_modules/@apollo/client/utilities/graphql/getFromAST.js
  function checkDocument(doc) {
    __DEV__ ? invariant2(doc && doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : invariant2(doc && doc.kind === "Document", 44);
    var operations = doc.definitions.filter(function(d) {
      return d.kind !== "FragmentDefinition";
    }).map(function(definition) {
      if (definition.kind !== "OperationDefinition") {
        throw __DEV__ ? new InvariantError('Schema type definitions not allowed in queries. Found: "'.concat(definition.kind, '"')) : new InvariantError(45);
      }
      return definition;
    });
    __DEV__ ? invariant2(operations.length <= 1, "Ambiguous GraphQL document: contains ".concat(operations.length, " operations")) : invariant2(operations.length <= 1, 46);
    return doc;
  }
  function getOperationDefinition(doc) {
    checkDocument(doc);
    return doc.definitions.filter(function(definition) {
      return definition.kind === "OperationDefinition";
    })[0];
  }
  function getOperationName(doc) {
    return doc.definitions.filter(function(definition) {
      return definition.kind === "OperationDefinition" && definition.name;
    }).map(function(x) {
      return x.name.value;
    })[0] || null;
  }
  function getFragmentDefinitions(doc) {
    return doc.definitions.filter(function(definition) {
      return definition.kind === "FragmentDefinition";
    });
  }
  function getQueryDefinition(doc) {
    var queryDef = getOperationDefinition(doc);
    __DEV__ ? invariant2(queryDef && queryDef.operation === "query", "Must contain a query definition.") : invariant2(queryDef && queryDef.operation === "query", 47);
    return queryDef;
  }
  function getFragmentDefinition(doc) {
    __DEV__ ? invariant2(doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : invariant2(doc.kind === "Document", 48);
    __DEV__ ? invariant2(doc.definitions.length <= 1, "Fragment must have exactly one definition.") : invariant2(doc.definitions.length <= 1, 49);
    var fragmentDef = doc.definitions[0];
    __DEV__ ? invariant2(fragmentDef.kind === "FragmentDefinition", "Must be a fragment definition.") : invariant2(fragmentDef.kind === "FragmentDefinition", 50);
    return fragmentDef;
  }
  function getMainDefinition(queryDoc) {
    checkDocument(queryDoc);
    var fragmentDefinition;
    for (var _i = 0, _a5 = queryDoc.definitions; _i < _a5.length; _i++) {
      var definition = _a5[_i];
      if (definition.kind === "OperationDefinition") {
        var operation = definition.operation;
        if (operation === "query" || operation === "mutation" || operation === "subscription") {
          return definition;
        }
      }
      if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
        fragmentDefinition = definition;
      }
    }
    if (fragmentDefinition) {
      return fragmentDefinition;
    }
    throw __DEV__ ? new InvariantError("Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.") : new InvariantError(51);
  }
  function getDefaultValues(definition) {
    var defaultValues = /* @__PURE__ */ Object.create(null);
    var defs = definition && definition.variableDefinitions;
    if (defs && defs.length) {
      defs.forEach(function(def) {
        if (def.defaultValue) {
          valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
        }
      });
    }
    return defaultValues;
  }

  // node_modules/@apollo/client/utilities/common/filterInPlace.js
  function filterInPlace(array, test, context2) {
    var target = 0;
    array.forEach(function(elem, i) {
      if (test.call(this, elem, i, array)) {
        array[target++] = elem;
      }
    }, context2);
    array.length = target;
    return array;
  }

  // node_modules/@apollo/client/utilities/graphql/transform.js
  var TYPENAME_FIELD = {
    kind: "Field",
    name: {
      kind: "Name",
      value: "__typename"
    }
  };
  function isEmpty(op, fragments) {
    return op.selectionSet.selections.every(function(selection) {
      return selection.kind === "FragmentSpread" && isEmpty(fragments[selection.name.value], fragments);
    });
  }
  function nullIfDocIsEmpty(doc) {
    return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
  }
  function getDirectiveMatcher(directives) {
    return function directiveMatcher(directive) {
      return directives.some(function(dir) {
        return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);
      });
    };
  }
  function removeDirectivesFromDocument(directives, doc) {
    var variablesInUse = /* @__PURE__ */ Object.create(null);
    var variablesToRemove = [];
    var fragmentSpreadsInUse = /* @__PURE__ */ Object.create(null);
    var fragmentSpreadsToRemove = [];
    var modifiedDoc = nullIfDocIsEmpty(visit(doc, {
      Variable: {
        enter: function(node, _key, parent) {
          if (parent.kind !== "VariableDefinition") {
            variablesInUse[node.name.value] = true;
          }
        }
      },
      Field: {
        enter: function(node) {
          if (directives && node.directives) {
            var shouldRemoveField = directives.some(function(directive) {
              return directive.remove;
            });
            if (shouldRemoveField && node.directives && node.directives.some(getDirectiveMatcher(directives))) {
              if (node.arguments) {
                node.arguments.forEach(function(arg) {
                  if (arg.value.kind === "Variable") {
                    variablesToRemove.push({
                      name: arg.value.name.value
                    });
                  }
                });
              }
              if (node.selectionSet) {
                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function(frag) {
                  fragmentSpreadsToRemove.push({
                    name: frag.name.value
                  });
                });
              }
              return null;
            }
          }
        }
      },
      FragmentSpread: {
        enter: function(node) {
          fragmentSpreadsInUse[node.name.value] = true;
        }
      },
      Directive: {
        enter: function(node) {
          if (getDirectiveMatcher(directives)(node)) {
            return null;
          }
        }
      }
    }));
    if (modifiedDoc && filterInPlace(variablesToRemove, function(v) {
      return !!v.name && !variablesInUse[v.name];
    }).length) {
      modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
    }
    if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function(fs) {
      return !!fs.name && !fragmentSpreadsInUse[fs.name];
    }).length) {
      modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
    }
    return modifiedDoc;
  }
  var addTypenameToDocument = Object.assign(function(doc) {
    return visit(doc, {
      SelectionSet: {
        enter: function(node, _key, parent) {
          if (parent && parent.kind === "OperationDefinition") {
            return;
          }
          var selections = node.selections;
          if (!selections) {
            return;
          }
          var skip = selections.some(function(selection) {
            return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
          });
          if (skip) {
            return;
          }
          var field = parent;
          if (isField(field) && field.directives && field.directives.some(function(d) {
            return d.name.value === "export";
          })) {
            return;
          }
          return __assign2(__assign2({}, node), { selections: __spreadArray2(__spreadArray2([], selections, true), [TYPENAME_FIELD], false) });
        }
      }
    });
  }, {
    added: function(field) {
      return field === TYPENAME_FIELD;
    }
  });
  var connectionRemoveConfig = {
    test: function(directive) {
      var willRemove = directive.name.value === "connection";
      if (willRemove) {
        if (!directive.arguments || !directive.arguments.some(function(arg) {
          return arg.name.value === "key";
        })) {
          __DEV__ && invariant2.warn("Removing an @connection directive even though it does not have a key. You may want to use the key parameter to specify a store key.");
        }
      }
      return willRemove;
    }
  };
  function removeConnectionDirectiveFromDocument(doc) {
    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
  }
  function getArgumentMatcher(config) {
    return function argumentMatcher(argument) {
      return config.some(function(aConfig) {
        return argument.value && argument.value.kind === "Variable" && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
      });
    };
  }
  function removeArgumentsFromDocument(config, doc) {
    var argMatcher = getArgumentMatcher(config);
    return nullIfDocIsEmpty(visit(doc, {
      OperationDefinition: {
        enter: function(node) {
          return __assign2(__assign2({}, node), { variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
            return !config.some(function(arg) {
              return arg.name === varDef.variable.name.value;
            });
          }) : [] });
        }
      },
      Field: {
        enter: function(node) {
          var shouldRemoveField = config.some(function(argConfig) {
            return argConfig.remove;
          });
          if (shouldRemoveField) {
            var argMatchCount_1 = 0;
            if (node.arguments) {
              node.arguments.forEach(function(arg) {
                if (argMatcher(arg)) {
                  argMatchCount_1 += 1;
                }
              });
            }
            if (argMatchCount_1 === 1) {
              return null;
            }
          }
        }
      },
      Argument: {
        enter: function(node) {
          if (argMatcher(node)) {
            return null;
          }
        }
      }
    }));
  }
  function removeFragmentSpreadFromDocument(config, doc) {
    function enter(node) {
      if (config.some(function(def) {
        return def.name === node.name.value;
      })) {
        return null;
      }
    }
    return nullIfDocIsEmpty(visit(doc, {
      FragmentSpread: { enter },
      FragmentDefinition: { enter }
    }));
  }
  function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
    var allFragments = [];
    selectionSet.selections.forEach(function(selection) {
      if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {
        getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function(frag) {
          return allFragments.push(frag);
        });
      } else if (selection.kind === "FragmentSpread") {
        allFragments.push(selection);
      }
    });
    return allFragments;
  }
  function buildQueryFromSelectionSet(document2) {
    var definition = getMainDefinition(document2);
    var definitionOperation = definition.operation;
    if (definitionOperation === "query") {
      return document2;
    }
    var modifiedDoc = visit(document2, {
      OperationDefinition: {
        enter: function(node) {
          return __assign2(__assign2({}, node), { operation: "query" });
        }
      }
    });
    return modifiedDoc;
  }
  function removeClientSetsFromDocument(document2) {
    checkDocument(document2);
    var modifiedDoc = removeDirectivesFromDocument([
      {
        test: function(directive) {
          return directive.name.value === "client";
        },
        remove: true
      }
    ], document2);
    if (modifiedDoc) {
      modifiedDoc = visit(modifiedDoc, {
        FragmentDefinition: {
          enter: function(node) {
            if (node.selectionSet) {
              var isTypenameOnly = node.selectionSet.selections.every(function(selection) {
                return isField(selection) && selection.name.value === "__typename";
              });
              if (isTypenameOnly) {
                return null;
              }
            }
          }
        }
      });
    }
    return modifiedDoc;
  }

  // node_modules/@apollo/client/utilities/common/mergeDeep.js
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function mergeDeep() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    return mergeDeepArray(sources);
  }
  function mergeDeepArray(sources) {
    var target = sources[0] || {};
    var count = sources.length;
    if (count > 1) {
      var merger = new DeepMerger();
      for (var i = 1; i < count; ++i) {
        target = merger.merge(target, sources[i]);
      }
    }
    return target;
  }
  var defaultReconciler = function(target, source, property) {
    return this.merge(target[property], source[property]);
  };
  var DeepMerger = function() {
    function DeepMerger2(reconciler) {
      if (reconciler === void 0) {
        reconciler = defaultReconciler;
      }
      this.reconciler = reconciler;
      this.isObject = isNonNullObject;
      this.pastCopies = /* @__PURE__ */ new Set();
    }
    DeepMerger2.prototype.merge = function(target, source) {
      var _this = this;
      var context2 = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        context2[_i - 2] = arguments[_i];
      }
      if (isNonNullObject(source) && isNonNullObject(target)) {
        Object.keys(source).forEach(function(sourceKey) {
          if (hasOwnProperty.call(target, sourceKey)) {
            var targetValue = target[sourceKey];
            if (source[sourceKey] !== targetValue) {
              var result2 = _this.reconciler.apply(_this, __spreadArray2([target, source, sourceKey], context2, false));
              if (result2 !== targetValue) {
                target = _this.shallowCopyForMerge(target);
                target[sourceKey] = result2;
              }
            }
          } else {
            target = _this.shallowCopyForMerge(target);
            target[sourceKey] = source[sourceKey];
          }
        });
        return target;
      }
      return source;
    };
    DeepMerger2.prototype.shallowCopyForMerge = function(value) {
      if (isNonNullObject(value)) {
        if (!this.pastCopies.has(value)) {
          if (Array.isArray(value)) {
            value = value.slice(0);
          } else {
            value = __assign2({ __proto__: Object.getPrototypeOf(value) }, value);
          }
          this.pastCopies.add(value);
        }
      }
      return value;
    };
    return DeepMerger2;
  }();

  // node_modules/zen-observable-ts/module.js
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it)
      return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass22(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  var hasSymbols = function() {
    return typeof Symbol === "function";
  };
  var hasSymbol = function(name) {
    return hasSymbols() && Boolean(Symbol[name]);
  };
  var getSymbol = function(name) {
    return hasSymbol(name) ? Symbol[name] : "@@" + name;
  };
  if (hasSymbols() && !hasSymbol("observable")) {
    Symbol.observable = Symbol("observable");
  }
  var SymbolIterator = getSymbol("iterator");
  var SymbolObservable = getSymbol("observable");
  var SymbolSpecies = getSymbol("species");
  function getMethod(obj, key) {
    var value = obj[key];
    if (value == null)
      return void 0;
    if (typeof value !== "function")
      throw new TypeError(value + " is not a function");
    return value;
  }
  function getSpecies(obj) {
    var ctor = obj.constructor;
    if (ctor !== void 0) {
      ctor = ctor[SymbolSpecies];
      if (ctor === null) {
        ctor = void 0;
      }
    }
    return ctor !== void 0 ? ctor : Observable;
  }
  function isObservable(x) {
    return x instanceof Observable;
  }
  function hostReportError(e) {
    if (hostReportError.log) {
      hostReportError.log(e);
    } else {
      setTimeout(function() {
        throw e;
      });
    }
  }
  function enqueue(fn) {
    Promise.resolve().then(function() {
      try {
        fn();
      } catch (e) {
        hostReportError(e);
      }
    });
  }
  function cleanupSubscription(subscription) {
    var cleanup = subscription._cleanup;
    if (cleanup === void 0)
      return;
    subscription._cleanup = void 0;
    if (!cleanup) {
      return;
    }
    try {
      if (typeof cleanup === "function") {
        cleanup();
      } else {
        var unsubscribe = getMethod(cleanup, "unsubscribe");
        if (unsubscribe) {
          unsubscribe.call(cleanup);
        }
      }
    } catch (e) {
      hostReportError(e);
    }
  }
  function closeSubscription(subscription) {
    subscription._observer = void 0;
    subscription._queue = void 0;
    subscription._state = "closed";
  }
  function flushSubscription(subscription) {
    var queue = subscription._queue;
    if (!queue) {
      return;
    }
    subscription._queue = void 0;
    subscription._state = "ready";
    for (var i = 0; i < queue.length; ++i) {
      notifySubscription(subscription, queue[i].type, queue[i].value);
      if (subscription._state === "closed")
        break;
    }
  }
  function notifySubscription(subscription, type, value) {
    subscription._state = "running";
    var observer = subscription._observer;
    try {
      var m = getMethod(observer, type);
      switch (type) {
        case "next":
          if (m)
            m.call(observer, value);
          break;
        case "error":
          closeSubscription(subscription);
          if (m)
            m.call(observer, value);
          else
            throw value;
          break;
        case "complete":
          closeSubscription(subscription);
          if (m)
            m.call(observer);
          break;
      }
    } catch (e) {
      hostReportError(e);
    }
    if (subscription._state === "closed")
      cleanupSubscription(subscription);
    else if (subscription._state === "running")
      subscription._state = "ready";
  }
  function onNotify(subscription, type, value) {
    if (subscription._state === "closed")
      return;
    if (subscription._state === "buffering") {
      subscription._queue.push({
        type,
        value
      });
      return;
    }
    if (subscription._state !== "ready") {
      subscription._state = "buffering";
      subscription._queue = [{
        type,
        value
      }];
      enqueue(function() {
        return flushSubscription(subscription);
      });
      return;
    }
    notifySubscription(subscription, type, value);
  }
  var Subscription = /* @__PURE__ */ function() {
    function Subscription2(observer, subscriber) {
      this._cleanup = void 0;
      this._observer = observer;
      this._queue = void 0;
      this._state = "initializing";
      var subscriptionObserver = new SubscriptionObserver(this);
      try {
        this._cleanup = subscriber.call(void 0, subscriptionObserver);
      } catch (e) {
        subscriptionObserver.error(e);
      }
      if (this._state === "initializing")
        this._state = "ready";
    }
    var _proto = Subscription2.prototype;
    _proto.unsubscribe = function unsubscribe() {
      if (this._state !== "closed") {
        closeSubscription(this);
        cleanupSubscription(this);
      }
    };
    _createClass22(Subscription2, [{
      key: "closed",
      get: function() {
        return this._state === "closed";
      }
    }]);
    return Subscription2;
  }();
  var SubscriptionObserver = /* @__PURE__ */ function() {
    function SubscriptionObserver2(subscription) {
      this._subscription = subscription;
    }
    var _proto2 = SubscriptionObserver2.prototype;
    _proto2.next = function next(value) {
      onNotify(this._subscription, "next", value);
    };
    _proto2.error = function error(value) {
      onNotify(this._subscription, "error", value);
    };
    _proto2.complete = function complete() {
      onNotify(this._subscription, "complete");
    };
    _createClass22(SubscriptionObserver2, [{
      key: "closed",
      get: function() {
        return this._subscription._state === "closed";
      }
    }]);
    return SubscriptionObserver2;
  }();
  var Observable = /* @__PURE__ */ function() {
    function Observable2(subscriber) {
      if (!(this instanceof Observable2))
        throw new TypeError("Observable cannot be called as a function");
      if (typeof subscriber !== "function")
        throw new TypeError("Observable initializer must be a function");
      this._subscriber = subscriber;
    }
    var _proto3 = Observable2.prototype;
    _proto3.subscribe = function subscribe(observer) {
      if (typeof observer !== "object" || observer === null) {
        observer = {
          next: observer,
          error: arguments[1],
          complete: arguments[2]
        };
      }
      return new Subscription(observer, this._subscriber);
    };
    _proto3.forEach = function forEach2(fn) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        if (typeof fn !== "function") {
          reject(new TypeError(fn + " is not a function"));
          return;
        }
        function done() {
          subscription.unsubscribe();
          resolve();
        }
        var subscription = _this.subscribe({
          next: function(value) {
            try {
              fn(value, done);
            } catch (e) {
              reject(e);
              subscription.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
      });
    };
    _proto3.map = function map(fn) {
      var _this2 = this;
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      var C = getSpecies(this);
      return new C(function(observer) {
        return _this2.subscribe({
          next: function(value) {
            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error: function(e) {
            observer.error(e);
          },
          complete: function() {
            observer.complete();
          }
        });
      });
    };
    _proto3.filter = function filter(fn) {
      var _this3 = this;
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      var C = getSpecies(this);
      return new C(function(observer) {
        return _this3.subscribe({
          next: function(value) {
            try {
              if (!fn(value))
                return;
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error: function(e) {
            observer.error(e);
          },
          complete: function() {
            observer.complete();
          }
        });
      });
    };
    _proto3.reduce = function reduce(fn) {
      var _this4 = this;
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      var C = getSpecies(this);
      var hasSeed = arguments.length > 1;
      var hasValue = false;
      var seed = arguments[1];
      var acc = seed;
      return new C(function(observer) {
        return _this4.subscribe({
          next: function(value) {
            var first = !hasValue;
            hasValue = true;
            if (!first || hasSeed) {
              try {
                acc = fn(acc, value);
              } catch (e) {
                return observer.error(e);
              }
            } else {
              acc = value;
            }
          },
          error: function(e) {
            observer.error(e);
          },
          complete: function() {
            if (!hasValue && !hasSeed)
              return observer.error(new TypeError("Cannot reduce an empty sequence"));
            observer.next(acc);
            observer.complete();
          }
        });
      });
    };
    _proto3.concat = function concat() {
      var _this5 = this;
      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      var C = getSpecies(this);
      return new C(function(observer) {
        var subscription;
        var index2 = 0;
        function startNext(next) {
          subscription = next.subscribe({
            next: function(v) {
              observer.next(v);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              if (index2 === sources.length) {
                subscription = void 0;
                observer.complete();
              } else {
                startNext(C.from(sources[index2++]));
              }
            }
          });
        }
        startNext(_this5);
        return function() {
          if (subscription) {
            subscription.unsubscribe();
            subscription = void 0;
          }
        };
      });
    };
    _proto3.flatMap = function flatMap(fn) {
      var _this6 = this;
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      var C = getSpecies(this);
      return new C(function(observer) {
        var subscriptions = [];
        var outer = _this6.subscribe({
          next: function(value) {
            if (fn) {
              try {
                value = fn(value);
              } catch (e) {
                return observer.error(e);
              }
            }
            var inner = C.from(value).subscribe({
              next: function(value2) {
                observer.next(value2);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                var i = subscriptions.indexOf(inner);
                if (i >= 0)
                  subscriptions.splice(i, 1);
                completeIfDone();
              }
            });
            subscriptions.push(inner);
          },
          error: function(e) {
            observer.error(e);
          },
          complete: function() {
            completeIfDone();
          }
        });
        function completeIfDone() {
          if (outer.closed && subscriptions.length === 0)
            observer.complete();
        }
        return function() {
          subscriptions.forEach(function(s) {
            return s.unsubscribe();
          });
          outer.unsubscribe();
        };
      });
    };
    _proto3[SymbolObservable] = function() {
      return this;
    };
    Observable2.from = function from(x) {
      var C = typeof this === "function" ? this : Observable2;
      if (x == null)
        throw new TypeError(x + " is not an object");
      var method = getMethod(x, SymbolObservable);
      if (method) {
        var observable = method.call(x);
        if (Object(observable) !== observable)
          throw new TypeError(observable + " is not an object");
        if (isObservable(observable) && observable.constructor === C)
          return observable;
        return new C(function(observer) {
          return observable.subscribe(observer);
        });
      }
      if (hasSymbol("iterator")) {
        method = getMethod(x, SymbolIterator);
        if (method) {
          return new C(function(observer) {
            enqueue(function() {
              if (observer.closed)
                return;
              for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done; ) {
                var item = _step.value;
                observer.next(item);
                if (observer.closed)
                  return;
              }
              observer.complete();
            });
          });
        }
      }
      if (Array.isArray(x)) {
        return new C(function(observer) {
          enqueue(function() {
            if (observer.closed)
              return;
            for (var i = 0; i < x.length; ++i) {
              observer.next(x[i]);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
      throw new TypeError(x + " is not observable");
    };
    Observable2.of = function of() {
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }
      var C = typeof this === "function" ? this : Observable2;
      return new C(function(observer) {
        enqueue(function() {
          if (observer.closed)
            return;
          for (var i = 0; i < items.length; ++i) {
            observer.next(items[i]);
            if (observer.closed)
              return;
          }
          observer.complete();
        });
      });
    };
    _createClass22(Observable2, null, [{
      key: SymbolSpecies,
      get: function() {
        return this;
      }
    }]);
    return Observable2;
  }();
  if (hasSymbols()) {
    Object.defineProperty(Observable, Symbol("extensions"), {
      value: {
        symbol: SymbolObservable,
        hostReportError
      },
      configurable: true
    });
  }

  // node_modules/symbol-observable/es/ponyfill.js
  function symbolObservablePonyfill(root2) {
    var result2;
    var Symbol2 = root2.Symbol;
    if (typeof Symbol2 === "function") {
      if (Symbol2.observable) {
        result2 = Symbol2.observable;
      } else {
        if (typeof Symbol2.for === "function") {
          result2 = Symbol2.for("https://github.com/benlesh/symbol-observable");
        } else {
          result2 = Symbol2("https://github.com/benlesh/symbol-observable");
        }
        try {
          Symbol2.observable = result2;
        } catch (err) {
        }
      }
    } else {
      result2 = "@@observable";
    }
    return result2;
  }

  // node_modules/symbol-observable/es/index.js
  var root;
  if (typeof self !== "undefined") {
    root = self;
  } else if (typeof window !== "undefined") {
    root = window;
  } else if (typeof global !== "undefined") {
    root = global;
  } else if (typeof module !== "undefined") {
    root = module;
  } else {
    root = Function("return this")();
  }
  var result = symbolObservablePonyfill(root);

  // node_modules/@apollo/client/utilities/observables/Observable.js
  var prototype = Observable.prototype;
  var fakeObsSymbol = "@@observable";
  if (!prototype[fakeObsSymbol]) {
    prototype[fakeObsSymbol] = function() {
      return this;
    };
  }

  // node_modules/@apollo/client/utilities/common/cloneDeep.js
  var toString = Object.prototype.toString;
  function cloneDeep(value) {
    return cloneDeepHelper(value);
  }
  function cloneDeepHelper(val, seen) {
    switch (toString.call(val)) {
      case "[object Array]": {
        seen = seen || /* @__PURE__ */ new Map();
        if (seen.has(val))
          return seen.get(val);
        var copy_1 = val.slice(0);
        seen.set(val, copy_1);
        copy_1.forEach(function(child, i) {
          copy_1[i] = cloneDeepHelper(child, seen);
        });
        return copy_1;
      }
      case "[object Object]": {
        seen = seen || /* @__PURE__ */ new Map();
        if (seen.has(val))
          return seen.get(val);
        var copy_2 = Object.create(Object.getPrototypeOf(val));
        seen.set(val, copy_2);
        Object.keys(val).forEach(function(key) {
          copy_2[key] = cloneDeepHelper(val[key], seen);
        });
        return copy_2;
      }
      default:
        return val;
    }
  }

  // node_modules/@apollo/client/utilities/common/maybeDeepFreeze.js
  function deepFreeze(value) {
    var workSet = /* @__PURE__ */ new Set([value]);
    workSet.forEach(function(obj) {
      if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
        Object.getOwnPropertyNames(obj).forEach(function(name) {
          if (isNonNullObject(obj[name]))
            workSet.add(obj[name]);
        });
      }
    });
    return value;
  }
  function shallowFreeze(obj) {
    if (__DEV__ && !Object.isFrozen(obj)) {
      try {
        Object.freeze(obj);
      } catch (e) {
        if (e instanceof TypeError)
          return null;
        throw e;
      }
    }
    return obj;
  }
  function maybeDeepFreeze(obj) {
    if (__DEV__) {
      deepFreeze(obj);
    }
    return obj;
  }

  // node_modules/@apollo/client/utilities/observables/iteration.js
  function iterateObserversSafely(observers, method, argument) {
    var observersWithMethod = [];
    observers.forEach(function(obs) {
      return obs[method] && observersWithMethod.push(obs);
    });
    observersWithMethod.forEach(function(obs) {
      return obs[method](argument);
    });
  }

  // node_modules/@apollo/client/utilities/observables/asyncMap.js
  function asyncMap(observable, mapFn, catchFn) {
    return new Observable(function(observer) {
      var next = observer.next, error = observer.error, complete = observer.complete;
      var activeCallbackCount = 0;
      var completed = false;
      var promiseQueue = {
        then: function(callback) {
          return new Promise(function(resolve) {
            return resolve(callback());
          });
        }
      };
      function makeCallback(examiner, delegate) {
        if (examiner) {
          return function(arg) {
            ++activeCallbackCount;
            var both = function() {
              return examiner(arg);
            };
            promiseQueue = promiseQueue.then(both, both).then(function(result2) {
              --activeCallbackCount;
              next && next.call(observer, result2);
              if (completed) {
                handler.complete();
              }
            }, function(error2) {
              --activeCallbackCount;
              throw error2;
            }).catch(function(caught) {
              error && error.call(observer, caught);
            });
          };
        } else {
          return function(arg) {
            return delegate && delegate.call(observer, arg);
          };
        }
      }
      var handler = {
        next: makeCallback(mapFn, next),
        error: makeCallback(catchFn, error),
        complete: function() {
          completed = true;
          if (!activeCallbackCount) {
            complete && complete.call(observer);
          }
        }
      };
      var sub = observable.subscribe(handler);
      return function() {
        return sub.unsubscribe();
      };
    });
  }

  // node_modules/@apollo/client/utilities/common/canUse.js
  var canUseWeakMap = typeof WeakMap === "function" && maybe(function() {
    return navigator.product;
  }) !== "ReactNative";
  var canUseWeakSet = typeof WeakSet === "function";
  var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
  var canUseDOM2 = typeof maybe(function() {
    return window.document.createElement;
  }) === "function";
  var usingJSDOM = maybe(function() {
    return navigator.userAgent.indexOf("jsdom") >= 0;
  }) || false;
  var canUseLayoutEffect = canUseDOM2 && !usingJSDOM;

  // node_modules/@apollo/client/utilities/observables/subclassing.js
  function fixObservableSubclass(subclass) {
    function set(key) {
      Object.defineProperty(subclass, key, { value: Observable });
    }
    if (canUseSymbol && Symbol.species) {
      set(Symbol.species);
    }
    set("@@species");
    return subclass;
  }

  // node_modules/@apollo/client/utilities/observables/Concast.js
  function isPromiseLike(value) {
    return value && typeof value.then === "function";
  }
  var Concast = function(_super) {
    __extends2(Concast2, _super);
    function Concast2(sources) {
      var _this = _super.call(this, function(observer) {
        _this.addObserver(observer);
        return function() {
          return _this.removeObserver(observer);
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.addCount = 0;
      _this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      _this.handlers = {
        next: function(result2) {
          if (_this.sub !== null) {
            _this.latest = ["next", result2];
            iterateObserversSafely(_this.observers, "next", result2);
          }
        },
        error: function(error) {
          var sub = _this.sub;
          if (sub !== null) {
            if (sub)
              setTimeout(function() {
                return sub.unsubscribe();
              });
            _this.sub = null;
            _this.latest = ["error", error];
            _this.reject(error);
            iterateObserversSafely(_this.observers, "error", error);
          }
        },
        complete: function() {
          var sub = _this.sub;
          if (sub !== null) {
            var value = _this.sources.shift();
            if (!value) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              if (_this.latest && _this.latest[0] === "next") {
                _this.resolve(_this.latest[1]);
              } else {
                _this.resolve();
              }
              iterateObserversSafely(_this.observers, "complete");
            } else if (isPromiseLike(value)) {
              value.then(function(obs) {
                return _this.sub = obs.subscribe(_this.handlers);
              });
            } else {
              _this.sub = value.subscribe(_this.handlers);
            }
          }
        }
      };
      _this.cancel = function(reason) {
        _this.reject(reason);
        _this.sources = [];
        _this.handlers.complete();
      };
      _this.promise.catch(function(_) {
      });
      if (typeof sources === "function") {
        sources = [new Observable(sources)];
      }
      if (isPromiseLike(sources)) {
        sources.then(function(iterable) {
          return _this.start(iterable);
        }, _this.handlers.error);
      } else {
        _this.start(sources);
      }
      return _this;
    }
    Concast2.prototype.start = function(sources) {
      if (this.sub !== void 0)
        return;
      this.sources = Array.from(sources);
      this.handlers.complete();
    };
    Concast2.prototype.deliverLastMessage = function(observer) {
      if (this.latest) {
        var nextOrError = this.latest[0];
        var method = observer[nextOrError];
        if (method) {
          method.call(observer, this.latest[1]);
        }
        if (this.sub === null && nextOrError === "next" && observer.complete) {
          observer.complete();
        }
      }
    };
    Concast2.prototype.addObserver = function(observer) {
      if (!this.observers.has(observer)) {
        this.deliverLastMessage(observer);
        this.observers.add(observer);
        ++this.addCount;
      }
    };
    Concast2.prototype.removeObserver = function(observer, quietly) {
      if (this.observers.delete(observer) && --this.addCount < 1 && !quietly) {
        this.handlers.complete();
      }
    };
    Concast2.prototype.cleanup = function(callback) {
      var _this = this;
      var called = false;
      var once = function() {
        if (!called) {
          called = true;
          _this.observers.delete(observer);
          callback();
        }
      };
      var observer = {
        next: once,
        error: once,
        complete: once
      };
      var count = this.addCount;
      this.addObserver(observer);
      this.addCount = count;
    };
    return Concast2;
  }(Observable);
  fixObservableSubclass(Concast);

  // node_modules/@apollo/client/utilities/common/arrays.js
  function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
  }

  // node_modules/@apollo/client/utilities/common/errorHandling.js
  function graphQLResultHasError(result2) {
    return result2.errors && result2.errors.length > 0 || false;
  }

  // node_modules/@apollo/client/utilities/common/compact.js
  function compact() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      objects[_i] = arguments[_i];
    }
    var result2 = /* @__PURE__ */ Object.create(null);
    objects.forEach(function(obj) {
      if (!obj)
        return;
      Object.keys(obj).forEach(function(key) {
        var value = obj[key];
        if (value !== void 0) {
          result2[key] = value;
        }
      });
    });
    return result2;
  }

  // node_modules/@apollo/client/utilities/common/makeUniqueId.js
  var prefixCounts = /* @__PURE__ */ new Map();
  function makeUniqueId(prefix2) {
    var count = prefixCounts.get(prefix2) || 1;
    prefixCounts.set(prefix2, count + 1);
    return "".concat(prefix2, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
  }

  // node_modules/@apollo/client/utilities/common/mergeOptions.js
  function mergeOptions(defaults, options) {
    return compact(defaults, options, options.variables && {
      variables: __assign2(__assign2({}, defaults && defaults.variables), options.variables)
    });
  }

  // node_modules/@apollo/client/link/utils/fromError.js
  function fromError(errorValue) {
    return new Observable(function(observer) {
      observer.error(errorValue);
    });
  }

  // node_modules/@apollo/client/link/utils/throwServerError.js
  var throwServerError = function(response, result2, message) {
    var error = new Error(message);
    error.name = "ServerError";
    error.response = response;
    error.statusCode = response.status;
    error.result = result2;
    throw error;
  };

  // node_modules/@apollo/client/link/utils/validateOperation.js
  function validateOperation(operation) {
    var OPERATION_FIELDS = [
      "query",
      "operationName",
      "variables",
      "extensions",
      "context"
    ];
    for (var _i = 0, _a5 = Object.keys(operation); _i < _a5.length; _i++) {
      var key = _a5[_i];
      if (OPERATION_FIELDS.indexOf(key) < 0) {
        throw __DEV__ ? new InvariantError("illegal argument: ".concat(key)) : new InvariantError(24);
      }
    }
    return operation;
  }

  // node_modules/@apollo/client/link/utils/createOperation.js
  function createOperation(starting, operation) {
    var context2 = __assign2({}, starting);
    var setContext = function(next) {
      if (typeof next === "function") {
        context2 = __assign2(__assign2({}, context2), next(context2));
      } else {
        context2 = __assign2(__assign2({}, context2), next);
      }
    };
    var getContext = function() {
      return __assign2({}, context2);
    };
    Object.defineProperty(operation, "setContext", {
      enumerable: false,
      value: setContext
    });
    Object.defineProperty(operation, "getContext", {
      enumerable: false,
      value: getContext
    });
    return operation;
  }

  // node_modules/@apollo/client/link/utils/transformOperation.js
  function transformOperation(operation) {
    var transformedOperation = {
      variables: operation.variables || {},
      extensions: operation.extensions || {},
      operationName: operation.operationName,
      query: operation.query
    };
    if (!transformedOperation.operationName) {
      transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
    }
    return transformedOperation;
  }

  // node_modules/@apollo/client/link/core/ApolloLink.js
  function passthrough(op, forward) {
    return forward ? forward(op) : Observable.of();
  }
  function toLink(handler) {
    return typeof handler === "function" ? new ApolloLink(handler) : handler;
  }
  function isTerminating(link) {
    return link.request.length <= 1;
  }
  var LinkError = function(_super) {
    __extends2(LinkError2, _super);
    function LinkError2(message, link) {
      var _this = _super.call(this, message) || this;
      _this.link = link;
      return _this;
    }
    return LinkError2;
  }(Error);
  var ApolloLink = function() {
    function ApolloLink2(request2) {
      if (request2)
        this.request = request2;
    }
    ApolloLink2.empty = function() {
      return new ApolloLink2(function() {
        return Observable.of();
      });
    };
    ApolloLink2.from = function(links) {
      if (links.length === 0)
        return ApolloLink2.empty();
      return links.map(toLink).reduce(function(x, y) {
        return x.concat(y);
      });
    };
    ApolloLink2.split = function(test, left, right) {
      var leftLink = toLink(left);
      var rightLink = toLink(right || new ApolloLink2(passthrough));
      if (isTerminating(leftLink) && isTerminating(rightLink)) {
        return new ApolloLink2(function(operation) {
          return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
        });
      } else {
        return new ApolloLink2(function(operation, forward) {
          return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
        });
      }
    };
    ApolloLink2.execute = function(link, operation) {
      return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
    };
    ApolloLink2.concat = function(first, second) {
      var firstLink = toLink(first);
      if (isTerminating(firstLink)) {
        __DEV__ && invariant2.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
        return firstLink;
      }
      var nextLink = toLink(second);
      if (isTerminating(nextLink)) {
        return new ApolloLink2(function(operation) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op) || Observable.of();
          }) || Observable.of();
        });
      } else {
        return new ApolloLink2(function(operation, forward) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op, forward) || Observable.of();
          }) || Observable.of();
        });
      }
    };
    ApolloLink2.prototype.split = function(test, left, right) {
      return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
    };
    ApolloLink2.prototype.concat = function(next) {
      return ApolloLink2.concat(this, next);
    };
    ApolloLink2.prototype.request = function(operation, forward) {
      throw __DEV__ ? new InvariantError("request is not implemented") : new InvariantError(19);
    };
    ApolloLink2.prototype.onError = function(error, observer) {
      if (observer && observer.error) {
        observer.error(error);
        return false;
      }
      throw error;
    };
    ApolloLink2.prototype.setOnError = function(fn) {
      this.onError = fn;
      return this;
    };
    return ApolloLink2;
  }();

  // node_modules/@apollo/client/link/core/execute.js
  var execute = ApolloLink.execute;

  // node_modules/@apollo/client/version.js
  var version = "3.6.9";

  // node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  function parseAndCheckHttpResponse(operations) {
    return function(response) {
      return response.text().then(function(bodyText) {
        try {
          return JSON.parse(bodyText);
        } catch (err) {
          var parseError = err;
          parseError.name = "ServerParseError";
          parseError.response = response;
          parseError.statusCode = response.status;
          parseError.bodyText = bodyText;
          throw parseError;
        }
      }).then(function(result2) {
        if (response.status >= 300) {
          throwServerError(response, result2, "Response not successful: Received status code ".concat(response.status));
        }
        if (!Array.isArray(result2) && !hasOwnProperty2.call(result2, "data") && !hasOwnProperty2.call(result2, "errors")) {
          throwServerError(response, result2, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
            return op.operationName;
          }) : operations.operationName, "'."));
        }
        return result2;
      });
    };
  }

  // node_modules/@apollo/client/link/http/serializeFetchParameter.js
  var serializeFetchParameter = function(p, label) {
    var serialized;
    try {
      serialized = JSON.stringify(p);
    } catch (e) {
      var parseError = __DEV__ ? new InvariantError("Network request failed. ".concat(label, " is not serializable: ").concat(e.message)) : new InvariantError(21);
      parseError.parseError = e;
      throw parseError;
    }
    return serialized;
  };

  // node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js
  var defaultHttpOptions = {
    includeQuery: true,
    includeExtensions: false
  };
  var defaultHeaders = {
    accept: "*/*",
    "content-type": "application/json"
  };
  var defaultOptions = {
    method: "POST"
  };
  var fallbackHttpConfig = {
    http: defaultHttpOptions,
    headers: defaultHeaders,
    options: defaultOptions
  };
  var defaultPrinter = function(ast, printer) {
    return printer(ast);
  };
  function selectHttpOptionsAndBodyInternal(operation, printer) {
    var configs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      configs[_i - 2] = arguments[_i];
    }
    var options = {};
    var http = {};
    configs.forEach(function(config) {
      options = __assign2(__assign2(__assign2({}, options), config.options), { headers: __assign2(__assign2({}, options.headers), headersToLowerCase(config.headers)) });
      if (config.credentials) {
        options.credentials = config.credentials;
      }
      http = __assign2(__assign2({}, http), config.http);
    });
    var operationName2 = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
    var body = { operationName: operationName2, variables };
    if (http.includeExtensions)
      body.extensions = extensions;
    if (http.includeQuery)
      body.query = printer(query, print);
    return {
      options,
      body
    };
  }
  function headersToLowerCase(headers) {
    if (headers) {
      var normalized_1 = /* @__PURE__ */ Object.create(null);
      Object.keys(Object(headers)).forEach(function(name) {
        normalized_1[name.toLowerCase()] = headers[name];
      });
      return normalized_1;
    }
    return headers;
  }

  // node_modules/@apollo/client/link/http/checkFetcher.js
  var checkFetcher = function(fetcher) {
    if (!fetcher && typeof fetch === "undefined") {
      throw __DEV__ ? new InvariantError(`
"fetch" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:

import fetch from 'cross-fetch';
import { ApolloClient, HttpLink } from '@apollo/client';
const client = new ApolloClient({
  link: new HttpLink({ uri: '/graphql', fetch })
});
    `) : new InvariantError(20);
    }
  };

  // node_modules/@apollo/client/link/http/createSignalIfSupported.js
  var createSignalIfSupported = function() {
    if (typeof AbortController === "undefined")
      return { controller: false, signal: false };
    var controller = new AbortController();
    var signal = controller.signal;
    return { controller, signal };
  };

  // node_modules/@apollo/client/link/http/selectURI.js
  var selectURI = function(operation, fallbackURI) {
    var context2 = operation.getContext();
    var contextURI = context2.uri;
    if (contextURI) {
      return contextURI;
    } else if (typeof fallbackURI === "function") {
      return fallbackURI(operation);
    } else {
      return fallbackURI || "/graphql";
    }
  };

  // node_modules/@apollo/client/link/http/rewriteURIForGET.js
  function rewriteURIForGET(chosenURI, body) {
    var queryParams = [];
    var addQueryParam = function(key, value) {
      queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
    };
    if ("query" in body) {
      addQueryParam("query", body.query);
    }
    if (body.operationName) {
      addQueryParam("operationName", body.operationName);
    }
    if (body.variables) {
      var serializedVariables = void 0;
      try {
        serializedVariables = serializeFetchParameter(body.variables, "Variables map");
      } catch (parseError) {
        return { parseError };
      }
      addQueryParam("variables", serializedVariables);
    }
    if (body.extensions) {
      var serializedExtensions = void 0;
      try {
        serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
      } catch (parseError) {
        return { parseError };
      }
      addQueryParam("extensions", serializedExtensions);
    }
    var fragment = "", preFragment = chosenURI;
    var fragmentStart = chosenURI.indexOf("#");
    if (fragmentStart !== -1) {
      fragment = chosenURI.substr(fragmentStart);
      preFragment = chosenURI.substr(0, fragmentStart);
    }
    var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
    var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
    return { newURI };
  }

  // node_modules/@apollo/client/link/http/createHttpLink.js
  var backupFetch = maybe(function() {
    return fetch;
  });
  var createHttpLink = function(linkOptions) {
    if (linkOptions === void 0) {
      linkOptions = {};
    }
    var _a5 = linkOptions.uri, uri = _a5 === void 0 ? "/graphql" : _a5, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print2 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest2(linkOptions, ["uri", "fetch", "print", "includeExtensions", "useGETForQueries", "includeUnusedVariables"]);
    if (__DEV__) {
      checkFetcher(preferredFetch || backupFetch);
    }
    var linkConfig = {
      http: { includeExtensions },
      options: requestOptions.fetchOptions,
      credentials: requestOptions.credentials,
      headers: requestOptions.headers
    };
    return new ApolloLink(function(operation) {
      var chosenURI = selectURI(operation, uri);
      var context2 = operation.getContext();
      var clientAwarenessHeaders = {};
      if (context2.clientAwareness) {
        var _a6 = context2.clientAwareness, name_1 = _a6.name, version2 = _a6.version;
        if (name_1) {
          clientAwarenessHeaders["apollographql-client-name"] = name_1;
        }
        if (version2) {
          clientAwarenessHeaders["apollographql-client-version"] = version2;
        }
      }
      var contextHeaders = __assign2(__assign2({}, clientAwarenessHeaders), context2.headers);
      var contextConfig = {
        http: context2.http,
        options: context2.fetchOptions,
        credentials: context2.credentials,
        headers: contextHeaders
      };
      var _b2 = selectHttpOptionsAndBodyInternal(operation, print2, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
      if (body.variables && !includeUnusedVariables) {
        var unusedNames_1 = new Set(Object.keys(body.variables));
        visit(operation.query, {
          Variable: function(node, _key, parent) {
            if (parent && parent.kind !== "VariableDefinition") {
              unusedNames_1.delete(node.name.value);
            }
          }
        });
        if (unusedNames_1.size) {
          body.variables = __assign2({}, body.variables);
          unusedNames_1.forEach(function(name) {
            delete body.variables[name];
          });
        }
      }
      var controller;
      if (!options.signal) {
        var _c2 = createSignalIfSupported(), _controller = _c2.controller, signal = _c2.signal;
        controller = _controller;
        if (controller)
          options.signal = signal;
      }
      var definitionIsMutation = function(d) {
        return d.kind === "OperationDefinition" && d.operation === "mutation";
      };
      if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
        options.method = "GET";
      }
      if (options.method === "GET") {
        var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
        if (parseError) {
          return fromError(parseError);
        }
        chosenURI = newURI;
      } else {
        try {
          options.body = serializeFetchParameter(body, "Payload");
        } catch (parseError2) {
          return fromError(parseError2);
        }
      }
      return new Observable(function(observer) {
        var currentFetch = preferredFetch || maybe(function() {
          return fetch;
        }) || backupFetch;
        currentFetch(chosenURI, options).then(function(response) {
          operation.setContext({ response });
          return response;
        }).then(parseAndCheckHttpResponse(operation)).then(function(result2) {
          observer.next(result2);
          observer.complete();
          return result2;
        }).catch(function(err) {
          if (err.name === "AbortError")
            return;
          if (err.result && err.result.errors && err.result.data) {
            observer.next(err.result);
          }
          observer.error(err);
        });
        return function() {
          if (controller)
            controller.abort();
        };
      });
    });
  };

  // node_modules/@apollo/client/link/http/HttpLink.js
  var HttpLink = function(_super) {
    __extends2(HttpLink2, _super);
    function HttpLink2(options) {
      if (options === void 0) {
        options = {};
      }
      var _this = _super.call(this, createHttpLink(options).request) || this;
      _this.options = options;
      return _this;
    }
    return HttpLink2;
  }(ApolloLink);

  // node_modules/@wry/equality/lib/equality.esm.js
  var _a2 = Object.prototype;
  var toString2 = _a2.toString;
  var hasOwnProperty3 = _a2.hasOwnProperty;
  var fnToStr = Function.prototype.toString;
  var previousComparisons = /* @__PURE__ */ new Map();
  function equal(a, b) {
    try {
      return check(a, b);
    } finally {
      previousComparisons.clear();
    }
  }
  function check(a, b) {
    if (a === b) {
      return true;
    }
    var aTag = toString2.call(a);
    var bTag = toString2.call(b);
    if (aTag !== bTag) {
      return false;
    }
    switch (aTag) {
      case "[object Array]":
        if (a.length !== b.length)
          return false;
      case "[object Object]": {
        if (previouslyCompared(a, b))
          return true;
        var aKeys = definedKeys(a);
        var bKeys = definedKeys(b);
        var keyCount = aKeys.length;
        if (keyCount !== bKeys.length)
          return false;
        for (var k = 0; k < keyCount; ++k) {
          if (!hasOwnProperty3.call(b, aKeys[k])) {
            return false;
          }
        }
        for (var k = 0; k < keyCount; ++k) {
          var key = aKeys[k];
          if (!check(a[key], b[key])) {
            return false;
          }
        }
        return true;
      }
      case "[object Error]":
        return a.name === b.name && a.message === b.message;
      case "[object Number]":
        if (a !== a)
          return b !== b;
      case "[object Boolean]":
      case "[object Date]":
        return +a === +b;
      case "[object RegExp]":
      case "[object String]":
        return a == "" + b;
      case "[object Map]":
      case "[object Set]": {
        if (a.size !== b.size)
          return false;
        if (previouslyCompared(a, b))
          return true;
        var aIterator = a.entries();
        var isMap = aTag === "[object Map]";
        while (true) {
          var info = aIterator.next();
          if (info.done)
            break;
          var _a5 = info.value, aKey = _a5[0], aValue = _a5[1];
          if (!b.has(aKey)) {
            return false;
          }
          if (isMap && !check(aValue, b.get(aKey))) {
            return false;
          }
        }
        return true;
      }
      case "[object Uint16Array]":
      case "[object Uint8Array]":
      case "[object Uint32Array]":
      case "[object Int32Array]":
      case "[object Int8Array]":
      case "[object Int16Array]":
      case "[object ArrayBuffer]":
        a = new Uint8Array(a);
        b = new Uint8Array(b);
      case "[object DataView]": {
        var len = a.byteLength;
        if (len === b.byteLength) {
          while (len-- && a[len] === b[len]) {
          }
        }
        return len === -1;
      }
      case "[object AsyncFunction]":
      case "[object GeneratorFunction]":
      case "[object AsyncGeneratorFunction]":
      case "[object Function]": {
        var aCode = fnToStr.call(a);
        if (aCode !== fnToStr.call(b)) {
          return false;
        }
        return !endsWith(aCode, nativeCodeSuffix);
      }
    }
    return false;
  }
  function definedKeys(obj) {
    return Object.keys(obj).filter(isDefinedKey, obj);
  }
  function isDefinedKey(key) {
    return this[key] !== void 0;
  }
  var nativeCodeSuffix = "{ [native code] }";
  function endsWith(full, suffix) {
    var fromIndex = full.length - suffix.length;
    return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
  }
  function previouslyCompared(a, b) {
    var bSet = previousComparisons.get(a);
    if (bSet) {
      if (bSet.has(b))
        return true;
    } else {
      previousComparisons.set(a, bSet = /* @__PURE__ */ new Set());
    }
    bSet.add(b);
    return false;
  }

  // node_modules/@wry/trie/lib/trie.esm.js
  var defaultMakeData = function() {
    return /* @__PURE__ */ Object.create(null);
  };
  var _a3 = Array.prototype;
  var forEach = _a3.forEach;
  var slice = _a3.slice;
  var Trie = function() {
    function Trie2(weakness, makeData) {
      if (weakness === void 0) {
        weakness = true;
      }
      if (makeData === void 0) {
        makeData = defaultMakeData;
      }
      this.weakness = weakness;
      this.makeData = makeData;
    }
    Trie2.prototype.lookup = function() {
      var array = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
      }
      return this.lookupArray(array);
    };
    Trie2.prototype.lookupArray = function(array) {
      var node = this;
      forEach.call(array, function(key) {
        return node = node.getChildTrie(key);
      });
      return node.data || (node.data = this.makeData(slice.call(array)));
    };
    Trie2.prototype.getChildTrie = function(key) {
      var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
      var child = map.get(key);
      if (!child)
        map.set(key, child = new Trie2(this.weakness, this.makeData));
      return child;
    };
    return Trie2;
  }();
  function isObjRef(value) {
    switch (typeof value) {
      case "object":
        if (value === null)
          break;
      case "function":
        return true;
    }
    return false;
  }

  // node_modules/@wry/context/lib/context.esm.js
  var currentContext = null;
  var MISSING_VALUE = {};
  var idCounter = 1;
  var makeSlotClass = function() {
    return function() {
      function Slot2() {
        this.id = [
          "slot",
          idCounter++,
          Date.now(),
          Math.random().toString(36).slice(2)
        ].join(":");
      }
      Slot2.prototype.hasValue = function() {
        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
          if (this.id in context_1.slots) {
            var value = context_1.slots[this.id];
            if (value === MISSING_VALUE)
              break;
            if (context_1 !== currentContext) {
              currentContext.slots[this.id] = value;
            }
            return true;
          }
        }
        if (currentContext) {
          currentContext.slots[this.id] = MISSING_VALUE;
        }
        return false;
      };
      Slot2.prototype.getValue = function() {
        if (this.hasValue()) {
          return currentContext.slots[this.id];
        }
      };
      Slot2.prototype.withValue = function(value, callback, args, thisArg) {
        var _a5;
        var slots = (_a5 = {
          __proto__: null
        }, _a5[this.id] = value, _a5);
        var parent = currentContext;
        currentContext = { parent, slots };
        try {
          return callback.apply(thisArg, args);
        } finally {
          currentContext = parent;
        }
      };
      Slot2.bind = function(callback) {
        var context2 = currentContext;
        return function() {
          var saved = currentContext;
          try {
            currentContext = context2;
            return callback.apply(this, arguments);
          } finally {
            currentContext = saved;
          }
        };
      };
      Slot2.noContext = function(callback, args, thisArg) {
        if (currentContext) {
          var saved = currentContext;
          try {
            currentContext = null;
            return callback.apply(thisArg, args);
          } finally {
            currentContext = saved;
          }
        } else {
          return callback.apply(thisArg, args);
        }
      };
      return Slot2;
    }();
  };
  var globalKey = "@wry/context:Slot";
  var host = Array;
  var Slot = host[globalKey] || function() {
    var Slot2 = makeSlotClass();
    try {
      Object.defineProperty(host, globalKey, {
        value: host[globalKey] = Slot2,
        enumerable: false,
        writable: false,
        configurable: false
      });
    } finally {
      return Slot2;
    }
  }();
  var bind = Slot.bind;
  var noContext = Slot.noContext;

  // node_modules/optimism/lib/bundle.esm.js
  function defaultDispose() {
  }
  var Cache = function() {
    function Cache2(max, dispose) {
      if (max === void 0) {
        max = Infinity;
      }
      if (dispose === void 0) {
        dispose = defaultDispose;
      }
      this.max = max;
      this.dispose = dispose;
      this.map = /* @__PURE__ */ new Map();
      this.newest = null;
      this.oldest = null;
    }
    Cache2.prototype.has = function(key) {
      return this.map.has(key);
    };
    Cache2.prototype.get = function(key) {
      var node = this.getNode(key);
      return node && node.value;
    };
    Cache2.prototype.getNode = function(key) {
      var node = this.map.get(key);
      if (node && node !== this.newest) {
        var older = node.older, newer = node.newer;
        if (newer) {
          newer.older = older;
        }
        if (older) {
          older.newer = newer;
        }
        node.older = this.newest;
        node.older.newer = node;
        node.newer = null;
        this.newest = node;
        if (node === this.oldest) {
          this.oldest = newer;
        }
      }
      return node;
    };
    Cache2.prototype.set = function(key, value) {
      var node = this.getNode(key);
      if (node) {
        return node.value = value;
      }
      node = {
        key,
        value,
        newer: null,
        older: this.newest
      };
      if (this.newest) {
        this.newest.newer = node;
      }
      this.newest = node;
      this.oldest = this.oldest || node;
      this.map.set(key, node);
      return node.value;
    };
    Cache2.prototype.clean = function() {
      while (this.oldest && this.map.size > this.max) {
        this.delete(this.oldest.key);
      }
    };
    Cache2.prototype.delete = function(key) {
      var node = this.map.get(key);
      if (node) {
        if (node === this.newest) {
          this.newest = node.older;
        }
        if (node === this.oldest) {
          this.oldest = node.newer;
        }
        if (node.newer) {
          node.newer.older = node.older;
        }
        if (node.older) {
          node.older.newer = node.newer;
        }
        this.map.delete(key);
        this.dispose(node.value, key);
        return true;
      }
      return false;
    };
    return Cache2;
  }();
  var parentEntrySlot = new Slot();
  var _a4;
  var toArray = (_a4 = Array.from, _a4 === void 0 ? function(collection) {
    var array = [];
    collection.forEach(function(item) {
      return array.push(item);
    });
    return array;
  } : _a4);
  function maybeUnsubscribe(entryOrDep) {
    var unsubscribe = entryOrDep.unsubscribe;
    if (typeof unsubscribe === "function") {
      entryOrDep.unsubscribe = void 0;
      unsubscribe();
    }
  }
  var emptySetPool = [];
  var POOL_TARGET_SIZE = 100;
  function assert(condition, optionalMessage) {
    if (!condition) {
      throw new Error(optionalMessage || "assertion failure");
    }
  }
  function valueIs(a, b) {
    var len = a.length;
    return len > 0 && len === b.length && a[len - 1] === b[len - 1];
  }
  function valueGet(value) {
    switch (value.length) {
      case 0:
        throw new Error("unknown value");
      case 1:
        return value[0];
      case 2:
        throw value[1];
    }
  }
  function valueCopy(value) {
    return value.slice(0);
  }
  var Entry = function() {
    function Entry2(fn) {
      this.fn = fn;
      this.parents = /* @__PURE__ */ new Set();
      this.childValues = /* @__PURE__ */ new Map();
      this.dirtyChildren = null;
      this.dirty = true;
      this.recomputing = false;
      this.value = [];
      this.deps = null;
      ++Entry2.count;
    }
    Entry2.prototype.peek = function() {
      if (this.value.length === 1 && !mightBeDirty(this)) {
        rememberParent(this);
        return this.value[0];
      }
    };
    Entry2.prototype.recompute = function(args) {
      assert(!this.recomputing, "already recomputing");
      rememberParent(this);
      return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
    };
    Entry2.prototype.setDirty = function() {
      if (this.dirty)
        return;
      this.dirty = true;
      this.value.length = 0;
      reportDirty(this);
      maybeUnsubscribe(this);
    };
    Entry2.prototype.dispose = function() {
      var _this = this;
      this.setDirty();
      forgetChildren(this);
      eachParent(this, function(parent, child) {
        parent.setDirty();
        forgetChild(parent, _this);
      });
    };
    Entry2.prototype.forget = function() {
      this.dispose();
    };
    Entry2.prototype.dependOn = function(dep2) {
      dep2.add(this);
      if (!this.deps) {
        this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
      }
      this.deps.add(dep2);
    };
    Entry2.prototype.forgetDeps = function() {
      var _this = this;
      if (this.deps) {
        toArray(this.deps).forEach(function(dep2) {
          return dep2.delete(_this);
        });
        this.deps.clear();
        emptySetPool.push(this.deps);
        this.deps = null;
      }
    };
    Entry2.count = 0;
    return Entry2;
  }();
  function rememberParent(child) {
    var parent = parentEntrySlot.getValue();
    if (parent) {
      child.parents.add(parent);
      if (!parent.childValues.has(child)) {
        parent.childValues.set(child, []);
      }
      if (mightBeDirty(child)) {
        reportDirtyChild(parent, child);
      } else {
        reportCleanChild(parent, child);
      }
      return parent;
    }
  }
  function reallyRecompute(entry, args) {
    forgetChildren(entry);
    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
    if (maybeSubscribe(entry, args)) {
      setClean(entry);
    }
    return valueGet(entry.value);
  }
  function recomputeNewValue(entry, args) {
    entry.recomputing = true;
    entry.value.length = 0;
    try {
      entry.value[0] = entry.fn.apply(null, args);
    } catch (e) {
      entry.value[1] = e;
    }
    entry.recomputing = false;
  }
  function mightBeDirty(entry) {
    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
  }
  function setClean(entry) {
    entry.dirty = false;
    if (mightBeDirty(entry)) {
      return;
    }
    reportClean(entry);
  }
  function reportDirty(child) {
    eachParent(child, reportDirtyChild);
  }
  function reportClean(child) {
    eachParent(child, reportCleanChild);
  }
  function eachParent(child, callback) {
    var parentCount = child.parents.size;
    if (parentCount) {
      var parents = toArray(child.parents);
      for (var i = 0; i < parentCount; ++i) {
        callback(parents[i], child);
      }
    }
  }
  function reportDirtyChild(parent, child) {
    assert(parent.childValues.has(child));
    assert(mightBeDirty(child));
    var parentWasClean = !mightBeDirty(parent);
    if (!parent.dirtyChildren) {
      parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
    } else if (parent.dirtyChildren.has(child)) {
      return;
    }
    parent.dirtyChildren.add(child);
    if (parentWasClean) {
      reportDirty(parent);
    }
  }
  function reportCleanChild(parent, child) {
    assert(parent.childValues.has(child));
    assert(!mightBeDirty(child));
    var childValue = parent.childValues.get(child);
    if (childValue.length === 0) {
      parent.childValues.set(child, valueCopy(child.value));
    } else if (!valueIs(childValue, child.value)) {
      parent.setDirty();
    }
    removeDirtyChild(parent, child);
    if (mightBeDirty(parent)) {
      return;
    }
    reportClean(parent);
  }
  function removeDirtyChild(parent, child) {
    var dc = parent.dirtyChildren;
    if (dc) {
      dc.delete(child);
      if (dc.size === 0) {
        if (emptySetPool.length < POOL_TARGET_SIZE) {
          emptySetPool.push(dc);
        }
        parent.dirtyChildren = null;
      }
    }
  }
  function forgetChildren(parent) {
    if (parent.childValues.size > 0) {
      parent.childValues.forEach(function(_value, child) {
        forgetChild(parent, child);
      });
    }
    parent.forgetDeps();
    assert(parent.dirtyChildren === null);
  }
  function forgetChild(parent, child) {
    child.parents.delete(parent);
    parent.childValues.delete(child);
    removeDirtyChild(parent, child);
  }
  function maybeSubscribe(entry, args) {
    if (typeof entry.subscribe === "function") {
      try {
        maybeUnsubscribe(entry);
        entry.unsubscribe = entry.subscribe.apply(null, args);
      } catch (e) {
        entry.setDirty();
        return false;
      }
    }
    return true;
  }
  function makeDefaultMakeCacheKeyFunction() {
    var keyTrie = new Trie(typeof WeakMap === "function");
    return function() {
      return keyTrie.lookupArray(arguments);
    };
  }
  var defaultMakeCacheKey = makeDefaultMakeCacheKeyFunction();

  // node_modules/@apollo/client/cache/inmemory/helpers.js
  var isArray = function(a) {
    return Array.isArray(a);
  };

  // node_modules/@apollo/client/cache/inmemory/object-canon.js
  function shallowCopy(value) {
    if (isNonNullObject(value)) {
      return isArray(value) ? value.slice(0) : __assign2({ __proto__: Object.getPrototypeOf(value) }, value);
    }
    return value;
  }
  var ObjectCanon = function() {
    function ObjectCanon2() {
      this.known = new (canUseWeakSet ? WeakSet : Set)();
      this.pool = new Trie(canUseWeakMap);
      this.passes = /* @__PURE__ */ new WeakMap();
      this.keysByJSON = /* @__PURE__ */ new Map();
      this.empty = this.admit({});
    }
    ObjectCanon2.prototype.isKnown = function(value) {
      return isNonNullObject(value) && this.known.has(value);
    };
    ObjectCanon2.prototype.pass = function(value) {
      if (isNonNullObject(value)) {
        var copy2 = shallowCopy(value);
        this.passes.set(copy2, value);
        return copy2;
      }
      return value;
    };
    ObjectCanon2.prototype.admit = function(value) {
      var _this = this;
      if (isNonNullObject(value)) {
        var original = this.passes.get(value);
        if (original)
          return original;
        var proto2 = Object.getPrototypeOf(value);
        switch (proto2) {
          case Array.prototype: {
            if (this.known.has(value))
              return value;
            var array = value.map(this.admit, this);
            var node = this.pool.lookupArray(array);
            if (!node.array) {
              this.known.add(node.array = array);
              if (__DEV__) {
                Object.freeze(array);
              }
            }
            return node.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(value))
              return value;
            var proto_1 = Object.getPrototypeOf(value);
            var array_1 = [proto_1];
            var keys = this.sortedKeys(value);
            array_1.push(keys.json);
            var firstValueIndex_1 = array_1.length;
            keys.sorted.forEach(function(key) {
              array_1.push(_this.admit(value[key]));
            });
            var node = this.pool.lookupArray(array_1);
            if (!node.object) {
              var obj_1 = node.object = Object.create(proto_1);
              this.known.add(obj_1);
              keys.sorted.forEach(function(key, i) {
                obj_1[key] = array_1[firstValueIndex_1 + i];
              });
              if (__DEV__) {
                Object.freeze(obj_1);
              }
            }
            return node.object;
          }
        }
      }
      return value;
    };
    ObjectCanon2.prototype.sortedKeys = function(obj) {
      var keys = Object.keys(obj);
      var node = this.pool.lookupArray(keys);
      if (!node.keys) {
        keys.sort();
        var json = JSON.stringify(keys);
        if (!(node.keys = this.keysByJSON.get(json))) {
          this.keysByJSON.set(json, node.keys = { sorted: keys, json });
        }
      }
      return node.keys;
    };
    return ObjectCanon2;
  }();
  var canonicalStringify = Object.assign(function(value) {
    if (isNonNullObject(value)) {
      if (stringifyCanon === void 0) {
        resetCanonicalStringify();
      }
      var canonical = stringifyCanon.admit(value);
      var json = stringifyCache.get(canonical);
      if (json === void 0) {
        stringifyCache.set(canonical, json = JSON.stringify(canonical));
      }
      return json;
    }
    return JSON.stringify(value);
  }, {
    reset: resetCanonicalStringify
  });
  var stringifyCanon;
  var stringifyCache;
  function resetCanonicalStringify() {
    stringifyCanon = new ObjectCanon();
    stringifyCache = new (canUseWeakMap ? WeakMap : Map)();
  }

  // node_modules/@apollo/client/cache/inmemory/reactiveVars.js
  var cacheSlot = new Slot();

  // node_modules/@apollo/client/errors/index.js
  function isApolloError(err) {
    return err.hasOwnProperty("graphQLErrors");
  }
  var generateErrorMessage = function(err) {
    var message = "";
    if (isNonEmptyArray(err.graphQLErrors) || isNonEmptyArray(err.clientErrors)) {
      var errors = (err.graphQLErrors || []).concat(err.clientErrors || []);
      errors.forEach(function(error) {
        var errorMessage = error ? error.message : "Error message not found.";
        message += "".concat(errorMessage, "\n");
      });
    }
    if (err.networkError) {
      message += "".concat(err.networkError.message, "\n");
    }
    message = message.replace(/\n$/, "");
    return message;
  };
  var ApolloError = function(_super) {
    __extends2(ApolloError2, _super);
    function ApolloError2(_a5) {
      var graphQLErrors = _a5.graphQLErrors, clientErrors = _a5.clientErrors, networkError = _a5.networkError, errorMessage = _a5.errorMessage, extraInfo = _a5.extraInfo;
      var _this = _super.call(this, errorMessage) || this;
      _this.graphQLErrors = graphQLErrors || [];
      _this.clientErrors = clientErrors || [];
      _this.networkError = networkError || null;
      _this.message = errorMessage || generateErrorMessage(_this);
      _this.extraInfo = extraInfo;
      _this.__proto__ = ApolloError2.prototype;
      return _this;
    }
    return ApolloError2;
  }(Error);

  // node_modules/@apollo/client/core/networkStatus.js
  var NetworkStatus;
  (function(NetworkStatus2) {
    NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
    NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
    NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
    NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
    NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
    NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
    NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
  })(NetworkStatus || (NetworkStatus = {}));
  function isNetworkRequestInFlight(networkStatus) {
    return networkStatus ? networkStatus < 7 : false;
  }

  // node_modules/@apollo/client/core/ObservableQuery.js
  var assign = Object.assign;
  var hasOwnProperty4 = Object.hasOwnProperty;
  var ObservableQuery = function(_super) {
    __extends2(ObservableQuery2, _super);
    function ObservableQuery2(_a5) {
      var queryManager = _a5.queryManager, queryInfo = _a5.queryInfo, options = _a5.options;
      var _this = _super.call(this, function(observer) {
        try {
          var subObserver = observer._subscription._observer;
          if (subObserver && !subObserver.error) {
            subObserver.error = defaultSubscriptionObserverErrorCallback;
          }
        } catch (_a6) {
        }
        var first = !_this.observers.size;
        _this.observers.add(observer);
        var last = _this.last;
        if (last && last.error) {
          observer.error && observer.error(last.error);
        } else if (last && last.result) {
          observer.next && observer.next(last.result);
        }
        if (first) {
          _this.reobserve().catch(function() {
          });
        }
        return function() {
          if (_this.observers.delete(observer) && !_this.observers.size) {
            _this.tearDownQuery();
          }
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.subscriptions = /* @__PURE__ */ new Set();
      _this.queryInfo = queryInfo;
      _this.queryManager = queryManager;
      _this.isTornDown = false;
      var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
      var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
      _this.options = __assign2(__assign2({}, options), { initialFetchPolicy, fetchPolicy });
      _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
      var opDef = getOperationDefinition(_this.query);
      _this.queryName = opDef && opDef.name && opDef.name.value;
      return _this;
    }
    Object.defineProperty(ObservableQuery2.prototype, "query", {
      get: function() {
        return this.queryManager.transform(this.options.query).document;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservableQuery2.prototype, "variables", {
      get: function() {
        return this.options.variables;
      },
      enumerable: false,
      configurable: true
    });
    ObservableQuery2.prototype.result = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var observer = {
          next: function(result2) {
            resolve(result2);
            _this.observers.delete(observer);
            if (!_this.observers.size) {
              _this.queryManager.removeQuery(_this.queryId);
            }
            setTimeout(function() {
              subscription.unsubscribe();
            }, 0);
          },
          error: reject
        };
        var subscription = _this.subscribe(observer);
      });
    };
    ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
      if (saveAsLastResult === void 0) {
        saveAsLastResult = true;
      }
      var lastResult = this.getLastResult(true);
      var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
      var result2 = __assign2(__assign2({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
      var _a5 = this.options.fetchPolicy, fetchPolicy = _a5 === void 0 ? "cache-first" : _a5;
      if (fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby" || this.queryManager.transform(this.options.query).hasForcedResolvers) {
      } else {
        var diff = this.queryInfo.getDiff();
        if (diff.complete || this.options.returnPartialData) {
          result2.data = diff.result;
        }
        if (equal(result2.data, {})) {
          result2.data = void 0;
        }
        if (diff.complete) {
          delete result2.partial;
          if (diff.complete && result2.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
            result2.networkStatus = NetworkStatus.ready;
            result2.loading = false;
          }
        } else {
          result2.partial = true;
        }
        if (__DEV__ && !diff.complete && !this.options.partialRefetch && !result2.loading && !result2.data && !result2.error) {
          logMissingFieldErrors(diff.missing);
        }
      }
      if (saveAsLastResult) {
        this.updateLastResult(result2);
      }
      return result2;
    };
    ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult) {
      return !this.last || !equal(this.last.result, newResult);
    };
    ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
      var last = this.last;
      if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {
        return last[key];
      }
    };
    ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
      return this.getLast("result", variablesMustMatch);
    };
    ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
      return this.getLast("error", variablesMustMatch);
    };
    ObservableQuery2.prototype.resetLastResults = function() {
      delete this.last;
      this.isTornDown = false;
    };
    ObservableQuery2.prototype.resetQueryStoreErrors = function() {
      this.queryManager.resetErrors(this.queryId);
    };
    ObservableQuery2.prototype.refetch = function(variables) {
      var _a5;
      var reobserveOptions = {
        pollInterval: 0
      };
      var fetchPolicy = this.options.fetchPolicy;
      if (fetchPolicy === "cache-and-network") {
        reobserveOptions.fetchPolicy = fetchPolicy;
      } else if (fetchPolicy === "no-cache") {
        reobserveOptions.fetchPolicy = "no-cache";
      } else {
        reobserveOptions.fetchPolicy = "network-only";
      }
      if (__DEV__ && variables && hasOwnProperty4.call(variables, "variables")) {
        var queryDef = getQueryDefinition(this.query);
        var vars = queryDef.variableDefinitions;
        if (!vars || !vars.some(function(v) {
          return v.variable.name.value === "variables";
        })) {
          __DEV__ && invariant2.warn("Called refetch(".concat(JSON.stringify(variables), ") for query ").concat(((_a5 = queryDef.name) === null || _a5 === void 0 ? void 0 : _a5.value) || JSON.stringify(queryDef), ", which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?"));
        }
      }
      if (variables && !equal(this.options.variables, variables)) {
        reobserveOptions.variables = this.options.variables = __assign2(__assign2({}, this.options.variables), variables);
      }
      this.queryInfo.resetLastWrite();
      return this.reobserve(reobserveOptions, NetworkStatus.refetch);
    };
    ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
      var _this = this;
      var combinedOptions = __assign2(__assign2({}, fetchMoreOptions.query ? fetchMoreOptions : __assign2(__assign2(__assign2(__assign2({}, this.options), { query: this.query }), fetchMoreOptions), { variables: __assign2(__assign2({}, this.options.variables), fetchMoreOptions.variables) })), { fetchPolicy: "no-cache" });
      var qid = this.queryManager.generateQueryId();
      var queryInfo = this.queryInfo;
      var originalNetworkStatus = queryInfo.networkStatus;
      queryInfo.networkStatus = NetworkStatus.fetchMore;
      if (combinedOptions.notifyOnNetworkStatusChange) {
        this.observe();
      }
      var updatedQuerySet = /* @__PURE__ */ new Set();
      return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
        _this.queryManager.removeQuery(qid);
        if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
          queryInfo.networkStatus = originalNetworkStatus;
        }
        _this.queryManager.cache.batch({
          update: function(cache4) {
            var updateQuery = fetchMoreOptions.updateQuery;
            if (updateQuery) {
              cache4.updateQuery({
                query: _this.query,
                variables: _this.variables,
                returnPartialData: true,
                optimistic: false
              }, function(previous) {
                return updateQuery(previous, {
                  fetchMoreResult: fetchMoreResult.data,
                  variables: combinedOptions.variables
                });
              });
            } else {
              cache4.writeQuery({
                query: combinedOptions.query,
                variables: combinedOptions.variables,
                data: fetchMoreResult.data
              });
            }
          },
          onWatchUpdated: function(watch) {
            updatedQuerySet.add(watch.query);
          }
        });
        return fetchMoreResult;
      }).finally(function() {
        if (!updatedQuerySet.has(_this.query)) {
          reobserveCacheFirst(_this);
        }
      });
    };
    ObservableQuery2.prototype.subscribeToMore = function(options) {
      var _this = this;
      var subscription = this.queryManager.startGraphQLSubscription({
        query: options.document,
        variables: options.variables,
        context: options.context
      }).subscribe({
        next: function(subscriptionData) {
          var updateQuery = options.updateQuery;
          if (updateQuery) {
            _this.updateQuery(function(previous, _a5) {
              var variables = _a5.variables;
              return updateQuery(previous, {
                subscriptionData,
                variables
              });
            });
          }
        },
        error: function(err) {
          if (options.onError) {
            options.onError(err);
            return;
          }
          __DEV__ && invariant2.error("Unhandled GraphQL subscription error", err);
        }
      });
      this.subscriptions.add(subscription);
      return function() {
        if (_this.subscriptions.delete(subscription)) {
          subscription.unsubscribe();
        }
      };
    };
    ObservableQuery2.prototype.setOptions = function(newOptions) {
      return this.reobserve(newOptions);
    };
    ObservableQuery2.prototype.setVariables = function(variables) {
      if (equal(this.variables, variables)) {
        return this.observers.size ? this.result() : Promise.resolve();
      }
      this.options.variables = variables;
      if (!this.observers.size) {
        return Promise.resolve();
      }
      return this.reobserve({
        fetchPolicy: this.options.initialFetchPolicy,
        variables
      }, NetworkStatus.setVariables);
    };
    ObservableQuery2.prototype.updateQuery = function(mapFn) {
      var queryManager = this.queryManager;
      var result2 = queryManager.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: true,
        optimistic: false
      }).result;
      var newResult = mapFn(result2, {
        variables: this.variables
      });
      if (newResult) {
        queryManager.cache.writeQuery({
          query: this.options.query,
          data: newResult,
          variables: this.variables
        });
        queryManager.broadcastQueries();
      }
    };
    ObservableQuery2.prototype.startPolling = function(pollInterval) {
      this.options.pollInterval = pollInterval;
      this.updatePolling();
    };
    ObservableQuery2.prototype.stopPolling = function() {
      this.options.pollInterval = 0;
      this.updatePolling();
    };
    ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
      if (options.nextFetchPolicy) {
        var _a5 = options.fetchPolicy, fetchPolicy = _a5 === void 0 ? "cache-first" : _a5, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
        if (fetchPolicy === "standby") {
        } else if (typeof options.nextFetchPolicy === "function") {
          options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
            reason,
            options,
            observable: this,
            initialFetchPolicy
          });
        } else if (reason === "variables-changed") {
          options.fetchPolicy = initialFetchPolicy;
        } else {
          options.fetchPolicy = options.nextFetchPolicy;
        }
      }
      return options.fetchPolicy;
    };
    ObservableQuery2.prototype.fetch = function(options, newNetworkStatus) {
      this.queryManager.setObservableQuery(this);
      return this.queryManager.fetchQueryObservable(this.queryId, options, newNetworkStatus);
    };
    ObservableQuery2.prototype.updatePolling = function() {
      var _this = this;
      if (this.queryManager.ssrMode) {
        return;
      }
      var _a5 = this, pollingInfo = _a5.pollingInfo, pollInterval = _a5.options.pollInterval;
      if (!pollInterval) {
        if (pollingInfo) {
          clearTimeout(pollingInfo.timeout);
          delete this.pollingInfo;
        }
        return;
      }
      if (pollingInfo && pollingInfo.interval === pollInterval) {
        return;
      }
      __DEV__ ? invariant2(pollInterval, "Attempted to start a polling query without a polling interval.") : invariant2(pollInterval, 10);
      var info = pollingInfo || (this.pollingInfo = {});
      info.interval = pollInterval;
      var maybeFetch = function() {
        if (_this.pollingInfo) {
          if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {
            _this.reobserve({
              fetchPolicy: "network-only"
            }, NetworkStatus.poll).then(poll, poll);
          } else {
            poll();
          }
        }
        ;
      };
      var poll = function() {
        var info2 = _this.pollingInfo;
        if (info2) {
          clearTimeout(info2.timeout);
          info2.timeout = setTimeout(maybeFetch, info2.interval);
        }
      };
      poll();
    };
    ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
      if (variables === void 0) {
        variables = this.variables;
      }
      this.last = __assign2(__assign2({}, this.last), { result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables });
      if (!isNonEmptyArray(newResult.errors)) {
        delete this.last.error;
      }
      return this.last;
    };
    ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
      var _this = this;
      this.isTornDown = false;
      var useDisposableConcast = newNetworkStatus === NetworkStatus.refetch || newNetworkStatus === NetworkStatus.fetchMore || newNetworkStatus === NetworkStatus.poll;
      var oldVariables = this.options.variables;
      var oldFetchPolicy = this.options.fetchPolicy;
      var mergedOptions = compact(this.options, newOptions || {});
      var options = useDisposableConcast ? mergedOptions : assign(this.options, mergedOptions);
      if (!useDisposableConcast) {
        this.updatePolling();
        if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && options.fetchPolicy !== "standby" && options.fetchPolicy === oldFetchPolicy) {
          this.applyNextFetchPolicy("variables-changed", options);
          if (newNetworkStatus === void 0) {
            newNetworkStatus = NetworkStatus.setVariables;
          }
        }
      }
      var variables = options.variables && __assign2({}, options.variables);
      var concast = this.fetch(options, newNetworkStatus);
      var observer = {
        next: function(result2) {
          _this.reportResult(result2, variables);
        },
        error: function(error) {
          _this.reportError(error, variables);
        }
      };
      if (!useDisposableConcast) {
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
        }
        this.concast = concast;
        this.observer = observer;
      }
      concast.addObserver(observer);
      return concast.promise;
    };
    ObservableQuery2.prototype.observe = function() {
      this.reportResult(this.getCurrentResult(false), this.variables);
    };
    ObservableQuery2.prototype.reportResult = function(result2, variables) {
      var lastError = this.getLastError();
      if (lastError || this.isDifferentFromLastResult(result2)) {
        if (lastError || !result2.partial || this.options.returnPartialData) {
          this.updateLastResult(result2, variables);
        }
        iterateObserversSafely(this.observers, "next", result2);
      }
    };
    ObservableQuery2.prototype.reportError = function(error, variables) {
      var errorResult = __assign2(__assign2({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
      this.updateLastResult(errorResult, variables);
      iterateObserversSafely(this.observers, "error", this.last.error = error);
    };
    ObservableQuery2.prototype.hasObservers = function() {
      return this.observers.size > 0;
    };
    ObservableQuery2.prototype.tearDownQuery = function() {
      if (this.isTornDown)
        return;
      if (this.concast && this.observer) {
        this.concast.removeObserver(this.observer);
        delete this.concast;
        delete this.observer;
      }
      this.stopPolling();
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      this.subscriptions.clear();
      this.queryManager.stopQuery(this.queryId);
      this.observers.clear();
      this.isTornDown = true;
    };
    return ObservableQuery2;
  }(Observable);
  fixObservableSubclass(ObservableQuery);
  function reobserveCacheFirst(obsQuery) {
    var _a5 = obsQuery.options, fetchPolicy = _a5.fetchPolicy, nextFetchPolicy = _a5.nextFetchPolicy;
    if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
      return obsQuery.reobserve({
        fetchPolicy: "cache-first",
        nextFetchPolicy: function() {
          this.nextFetchPolicy = nextFetchPolicy;
          if (typeof nextFetchPolicy === "function") {
            return nextFetchPolicy.apply(this, arguments);
          }
          return fetchPolicy;
        }
      });
    }
    return obsQuery.reobserve();
  }
  function defaultSubscriptionObserverErrorCallback(error) {
    __DEV__ && invariant2.error("Unhandled error", error.message, error.stack);
  }
  function logMissingFieldErrors(missing) {
    if (__DEV__ && missing) {
      __DEV__ && invariant2.debug("Missing cache result fields: ".concat(JSON.stringify(missing)), missing);
    }
  }

  // node_modules/@apollo/client/core/LocalState.js
  var LocalState = function() {
    function LocalState2(_a5) {
      var cache4 = _a5.cache, client = _a5.client, resolvers = _a5.resolvers, fragmentMatcher = _a5.fragmentMatcher;
      this.cache = cache4;
      if (client) {
        this.client = client;
      }
      if (resolvers) {
        this.addResolvers(resolvers);
      }
      if (fragmentMatcher) {
        this.setFragmentMatcher(fragmentMatcher);
      }
    }
    LocalState2.prototype.addResolvers = function(resolvers) {
      var _this = this;
      this.resolvers = this.resolvers || {};
      if (Array.isArray(resolvers)) {
        resolvers.forEach(function(resolverGroup) {
          _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
        });
      } else {
        this.resolvers = mergeDeep(this.resolvers, resolvers);
      }
    };
    LocalState2.prototype.setResolvers = function(resolvers) {
      this.resolvers = {};
      this.addResolvers(resolvers);
    };
    LocalState2.prototype.getResolvers = function() {
      return this.resolvers || {};
    };
    LocalState2.prototype.runResolvers = function(_a5) {
      var document2 = _a5.document, remoteResult = _a5.remoteResult, context2 = _a5.context, variables = _a5.variables, _b = _a5.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_c) {
          if (document2) {
            return [2, this.resolveDocument(document2, remoteResult.data, context2, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
              return __assign2(__assign2({}, remoteResult), { data: localResult.result });
            })];
          }
          return [2, remoteResult];
        });
      });
    };
    LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
      this.fragmentMatcher = fragmentMatcher;
    };
    LocalState2.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    };
    LocalState2.prototype.clientQuery = function(document2) {
      if (hasDirectives(["client"], document2)) {
        if (this.resolvers) {
          return document2;
        }
      }
      return null;
    };
    LocalState2.prototype.serverQuery = function(document2) {
      return removeClientSetsFromDocument(document2);
    };
    LocalState2.prototype.prepareContext = function(context2) {
      var cache4 = this.cache;
      return __assign2(__assign2({}, context2), { cache: cache4, getCacheKey: function(obj) {
        return cache4.identify(obj);
      } });
    };
    LocalState2.prototype.addExportedVariables = function(document2, variables, context2) {
      if (variables === void 0) {
        variables = {};
      }
      if (context2 === void 0) {
        context2 = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a5) {
          if (document2) {
            return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context2), variables).then(function(data) {
              return __assign2(__assign2({}, variables), data.exportedVariables);
            })];
          }
          return [2, __assign2({}, variables)];
        });
      });
    };
    LocalState2.prototype.shouldForceResolvers = function(document2) {
      var forceResolvers = false;
      visit(document2, {
        Directive: {
          enter: function(node) {
            if (node.name.value === "client" && node.arguments) {
              forceResolvers = node.arguments.some(function(arg) {
                return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
              });
              if (forceResolvers) {
                return BREAK;
              }
            }
          }
        }
      });
      return forceResolvers;
    };
    LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
      return this.cache.diff({
        query: buildQueryFromSelectionSet(document2),
        variables,
        returnPartialData: true,
        optimistic: false
      }).result;
    };
    LocalState2.prototype.resolveDocument = function(document2, rootValue, context2, variables, fragmentMatcher, onlyRunForcedResolvers) {
      if (context2 === void 0) {
        context2 = {};
      }
      if (variables === void 0) {
        variables = {};
      }
      if (fragmentMatcher === void 0) {
        fragmentMatcher = function() {
          return true;
        };
      }
      if (onlyRunForcedResolvers === void 0) {
        onlyRunForcedResolvers = false;
      }
      return __awaiter2(this, void 0, void 0, function() {
        var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a5, cache4, client, execContext;
        return __generator2(this, function(_b) {
          mainDefinition = getMainDefinition(document2);
          fragments = getFragmentDefinitions(document2);
          fragmentMap = createFragmentMap(fragments);
          definitionOperation = mainDefinition.operation;
          defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
          _a5 = this, cache4 = _a5.cache, client = _a5.client;
          execContext = {
            fragmentMap,
            context: __assign2(__assign2({}, context2), { cache: cache4, client }),
            variables,
            fragmentMatcher,
            defaultOperationType,
            exportedVariables: {},
            onlyRunForcedResolvers
          };
          return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function(result2) {
            return {
              result: result2,
              exportedVariables: execContext.exportedVariables
            };
          })];
        });
      });
    };
    LocalState2.prototype.resolveSelectionSet = function(selectionSet, rootValue, execContext) {
      return __awaiter2(this, void 0, void 0, function() {
        var fragmentMap, context2, variables, resultsToMerge, execute2;
        var _this = this;
        return __generator2(this, function(_a5) {
          fragmentMap = execContext.fragmentMap, context2 = execContext.context, variables = execContext.variables;
          resultsToMerge = [rootValue];
          execute2 = function(selection) {
            return __awaiter2(_this, void 0, void 0, function() {
              var fragment, typeCondition;
              return __generator2(this, function(_a6) {
                if (!shouldInclude(selection, variables)) {
                  return [2];
                }
                if (isField(selection)) {
                  return [2, this.resolveField(selection, rootValue, execContext).then(function(fieldResult) {
                    var _a7;
                    if (typeof fieldResult !== "undefined") {
                      resultsToMerge.push((_a7 = {}, _a7[resultKeyNameFromField(selection)] = fieldResult, _a7));
                    }
                  })];
                }
                if (isInlineFragment(selection)) {
                  fragment = selection;
                } else {
                  fragment = fragmentMap[selection.name.value];
                  __DEV__ ? invariant2(fragment, "No fragment named ".concat(selection.name.value)) : invariant2(fragment, 9);
                }
                if (fragment && fragment.typeCondition) {
                  typeCondition = fragment.typeCondition.name.value;
                  if (execContext.fragmentMatcher(rootValue, typeCondition, context2)) {
                    return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function(fragmentResult) {
                      resultsToMerge.push(fragmentResult);
                    })];
                  }
                }
                return [2];
              });
            });
          };
          return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
            return mergeDeepArray(resultsToMerge);
          })];
        });
      });
    };
    LocalState2.prototype.resolveField = function(field, rootValue, execContext) {
      return __awaiter2(this, void 0, void 0, function() {
        var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
        var _this = this;
        return __generator2(this, function(_a5) {
          variables = execContext.variables;
          fieldName = field.name.value;
          aliasedFieldName = resultKeyNameFromField(field);
          aliasUsed = fieldName !== aliasedFieldName;
          defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
          resultPromise = Promise.resolve(defaultResult);
          if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
            resolverType = rootValue.__typename || execContext.defaultOperationType;
            resolverMap = this.resolvers && this.resolvers[resolverType];
            if (resolverMap) {
              resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
              if (resolve) {
                resultPromise = Promise.resolve(cacheSlot.withValue(this.cache, resolve, [
                  rootValue,
                  argumentsObjectFromField(field, variables),
                  execContext.context,
                  { field, fragmentMap: execContext.fragmentMap }
                ]));
              }
            }
          }
          return [2, resultPromise.then(function(result2) {
            if (result2 === void 0) {
              result2 = defaultResult;
            }
            if (field.directives) {
              field.directives.forEach(function(directive) {
                if (directive.name.value === "export" && directive.arguments) {
                  directive.arguments.forEach(function(arg) {
                    if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                      execContext.exportedVariables[arg.value.value] = result2;
                    }
                  });
                }
              });
            }
            if (!field.selectionSet) {
              return result2;
            }
            if (result2 == null) {
              return result2;
            }
            if (Array.isArray(result2)) {
              return _this.resolveSubSelectedArray(field, result2, execContext);
            }
            if (field.selectionSet) {
              return _this.resolveSelectionSet(field.selectionSet, result2, execContext);
            }
          })];
        });
      });
    };
    LocalState2.prototype.resolveSubSelectedArray = function(field, result2, execContext) {
      var _this = this;
      return Promise.all(result2.map(function(item) {
        if (item === null) {
          return null;
        }
        if (Array.isArray(item)) {
          return _this.resolveSubSelectedArray(field, item, execContext);
        }
        if (field.selectionSet) {
          return _this.resolveSelectionSet(field.selectionSet, item, execContext);
        }
      }));
    };
    return LocalState2;
  }();

  // node_modules/@apollo/client/core/QueryInfo.js
  var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
  function wrapDestructiveCacheMethod(cache4, methodName) {
    var original = cache4[methodName];
    if (typeof original === "function") {
      cache4[methodName] = function() {
        destructiveMethodCounts.set(cache4, (destructiveMethodCounts.get(cache4) + 1) % 1e15);
        return original.apply(this, arguments);
      };
    }
  }
  function cancelNotifyTimeout(info) {
    if (info["notifyTimeout"]) {
      clearTimeout(info["notifyTimeout"]);
      info["notifyTimeout"] = void 0;
    }
  }
  var QueryInfo = function() {
    function QueryInfo2(queryManager, queryId) {
      if (queryId === void 0) {
        queryId = queryManager.generateQueryId();
      }
      this.queryId = queryId;
      this.listeners = /* @__PURE__ */ new Set();
      this.document = null;
      this.lastRequestId = 1;
      this.subscriptions = /* @__PURE__ */ new Set();
      this.stopped = false;
      this.dirty = false;
      this.observableQuery = null;
      var cache4 = this.cache = queryManager.cache;
      if (!destructiveMethodCounts.has(cache4)) {
        destructiveMethodCounts.set(cache4, 0);
        wrapDestructiveCacheMethod(cache4, "evict");
        wrapDestructiveCacheMethod(cache4, "modify");
        wrapDestructiveCacheMethod(cache4, "reset");
      }
    }
    QueryInfo2.prototype.init = function(query) {
      var networkStatus = query.networkStatus || NetworkStatus.loading;
      if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {
        networkStatus = NetworkStatus.setVariables;
      }
      if (!equal(query.variables, this.variables)) {
        this.lastDiff = void 0;
      }
      Object.assign(this, {
        document: query.document,
        variables: query.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus
      });
      if (query.observableQuery) {
        this.setObservableQuery(query.observableQuery);
      }
      if (query.lastRequestId) {
        this.lastRequestId = query.lastRequestId;
      }
      return this;
    };
    QueryInfo2.prototype.reset = function() {
      cancelNotifyTimeout(this);
      this.lastDiff = void 0;
      this.dirty = false;
    };
    QueryInfo2.prototype.getDiff = function(variables) {
      if (variables === void 0) {
        variables = this.variables;
      }
      var options = this.getDiffOptions(variables);
      if (this.lastDiff && equal(options, this.lastDiff.options)) {
        return this.lastDiff.diff;
      }
      this.updateWatch(this.variables = variables);
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return { complete: false };
      }
      var diff = this.cache.diff(options);
      this.updateLastDiff(diff, options);
      return diff;
    };
    QueryInfo2.prototype.updateLastDiff = function(diff, options) {
      this.lastDiff = diff ? {
        diff,
        options: options || this.getDiffOptions()
      } : void 0;
    };
    QueryInfo2.prototype.getDiffOptions = function(variables) {
      var _a5;
      if (variables === void 0) {
        variables = this.variables;
      }
      return {
        query: this.document,
        variables,
        returnPartialData: true,
        optimistic: true,
        canonizeResults: (_a5 = this.observableQuery) === null || _a5 === void 0 ? void 0 : _a5.options.canonizeResults
      };
    };
    QueryInfo2.prototype.setDiff = function(diff) {
      var _this = this;
      var oldDiff = this.lastDiff && this.lastDiff.diff;
      this.updateLastDiff(diff);
      if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {
        this.dirty = true;
        if (!this.notifyTimeout) {
          this.notifyTimeout = setTimeout(function() {
            return _this.notify();
          }, 0);
        }
      }
    };
    QueryInfo2.prototype.setObservableQuery = function(oq) {
      var _this = this;
      if (oq === this.observableQuery)
        return;
      if (this.oqListener) {
        this.listeners.delete(this.oqListener);
      }
      this.observableQuery = oq;
      if (oq) {
        oq["queryInfo"] = this;
        this.listeners.add(this.oqListener = function() {
          var diff = _this.getDiff();
          if (diff.fromOptimisticTransaction) {
            oq["observe"]();
          } else {
            reobserveCacheFirst(oq);
          }
        });
      } else {
        delete this.oqListener;
      }
    };
    QueryInfo2.prototype.notify = function() {
      var _this = this;
      cancelNotifyTimeout(this);
      if (this.shouldNotify()) {
        this.listeners.forEach(function(listener) {
          return listener(_this);
        });
      }
      this.dirty = false;
    };
    QueryInfo2.prototype.shouldNotify = function() {
      if (!this.dirty || !this.listeners.size) {
        return false;
      }
      if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
        var fetchPolicy = this.observableQuery.options.fetchPolicy;
        if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
          return false;
        }
      }
      return true;
    };
    QueryInfo2.prototype.stop = function() {
      if (!this.stopped) {
        this.stopped = true;
        this.reset();
        this.cancel();
        this.cancel = QueryInfo2.prototype.cancel;
        this.subscriptions.forEach(function(sub) {
          return sub.unsubscribe();
        });
        var oq = this.observableQuery;
        if (oq)
          oq.stopPolling();
      }
    };
    QueryInfo2.prototype.cancel = function() {
    };
    QueryInfo2.prototype.updateWatch = function(variables) {
      var _this = this;
      if (variables === void 0) {
        variables = this.variables;
      }
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return;
      }
      var watchOptions = __assign2(__assign2({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
        return _this.setDiff(diff);
      } });
      if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {
        this.cancel();
        this.cancel = this.cache.watch(this.lastWatch = watchOptions);
      }
    };
    QueryInfo2.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    };
    QueryInfo2.prototype.shouldWrite = function(result2, variables) {
      var lastWrite = this.lastWrite;
      return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result2.data, lastWrite.result.data));
    };
    QueryInfo2.prototype.markResult = function(result2, options, cacheWriteBehavior) {
      var _this = this;
      this.graphQLErrors = isNonEmptyArray(result2.errors) ? result2.errors : [];
      this.reset();
      if (options.fetchPolicy === "no-cache") {
        this.updateLastDiff({ result: result2.data, complete: true }, this.getDiffOptions(options.variables));
      } else if (cacheWriteBehavior !== 0) {
        if (shouldWriteResult(result2, options.errorPolicy)) {
          this.cache.performTransaction(function(cache4) {
            if (_this.shouldWrite(result2, options.variables)) {
              cache4.writeQuery({
                query: _this.document,
                data: result2.data,
                variables: options.variables,
                overwrite: cacheWriteBehavior === 1
              });
              _this.lastWrite = {
                result: result2,
                variables: options.variables,
                dmCount: destructiveMethodCounts.get(_this.cache)
              };
            } else {
              if (_this.lastDiff && _this.lastDiff.diff.complete) {
                result2.data = _this.lastDiff.diff.result;
                return;
              }
            }
            var diffOptions = _this.getDiffOptions(options.variables);
            var diff = cache4.diff(diffOptions);
            if (!_this.stopped) {
              _this.updateWatch(options.variables);
            }
            _this.updateLastDiff(diff, diffOptions);
            if (diff.complete) {
              result2.data = diff.result;
            }
          });
        } else {
          this.lastWrite = void 0;
        }
      }
    };
    QueryInfo2.prototype.markReady = function() {
      this.networkError = null;
      return this.networkStatus = NetworkStatus.ready;
    };
    QueryInfo2.prototype.markError = function(error) {
      this.networkStatus = NetworkStatus.error;
      this.lastWrite = void 0;
      this.reset();
      if (error.graphQLErrors) {
        this.graphQLErrors = error.graphQLErrors;
      }
      if (error.networkError) {
        this.networkError = error.networkError;
      }
      return error;
    };
    return QueryInfo2;
  }();
  function shouldWriteResult(result2, errorPolicy) {
    if (errorPolicy === void 0) {
      errorPolicy = "none";
    }
    var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
    var writeWithErrors = !graphQLResultHasError(result2);
    if (!writeWithErrors && ignoreErrors && result2.data) {
      writeWithErrors = true;
    }
    return writeWithErrors;
  }

  // node_modules/@apollo/client/core/QueryManager.js
  var hasOwnProperty5 = Object.prototype.hasOwnProperty;
  var QueryManager = function() {
    function QueryManager2(_a5) {
      var cache4 = _a5.cache, link = _a5.link, defaultOptions2 = _a5.defaultOptions, _b = _a5.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a5.onBroadcast, _c = _a5.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a5.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a5.localState, assumeImmutableResults = _a5.assumeImmutableResults;
      this.clientAwareness = {};
      this.queries = /* @__PURE__ */ new Map();
      this.fetchCancelFns = /* @__PURE__ */ new Map();
      this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
      this.queryIdCounter = 1;
      this.requestIdCounter = 1;
      this.mutationIdCounter = 1;
      this.inFlightLinkObservables = /* @__PURE__ */ new Map();
      this.cache = cache4;
      this.link = link;
      this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
      this.queryDeduplication = queryDeduplication;
      this.clientAwareness = clientAwareness;
      this.localState = localState || new LocalState({ cache: cache4 });
      this.ssrMode = ssrMode;
      this.assumeImmutableResults = !!assumeImmutableResults;
      if (this.onBroadcast = onBroadcast) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
    }
    QueryManager2.prototype.stop = function() {
      var _this = this;
      this.queries.forEach(function(_info, queryId) {
        _this.stopQueryNoBroadcast(queryId);
      });
      this.cancelPendingFetches(__DEV__ ? new InvariantError("QueryManager stopped while query was in flight") : new InvariantError(11));
    };
    QueryManager2.prototype.cancelPendingFetches = function(error) {
      this.fetchCancelFns.forEach(function(cancel2) {
        return cancel2(error);
      });
      this.fetchCancelFns.clear();
    };
    QueryManager2.prototype.mutate = function(_a5) {
      var _b, _c;
      var mutation = _a5.mutation, variables = _a5.variables, optimisticResponse = _a5.optimisticResponse, updateQueries = _a5.updateQueries, _d = _a5.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e = _a5.awaitRefetchQueries, awaitRefetchQueries = _e === void 0 ? false : _e, updateWithProxyFn = _a5.update, onQueryUpdated = _a5.onQueryUpdated, _f = _a5.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "network-only" : _f, _g = _a5.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || "none" : _g, keepRootFields = _a5.keepRootFields, context2 = _a5.context;
      return __awaiter2(this, void 0, void 0, function() {
        var mutationId, mutationStoreValue, self2;
        return __generator2(this, function(_h) {
          switch (_h.label) {
            case 0:
              __DEV__ ? invariant2(mutation, "mutation option is required. You must specify your GraphQL document in the mutation option.") : invariant2(mutation, 12);
              __DEV__ ? invariant2(fetchPolicy === "network-only" || fetchPolicy === "no-cache", "Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.") : invariant2(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 13);
              mutationId = this.generateMutationId();
              mutation = this.transform(mutation).document;
              variables = this.getVariables(mutation, variables);
              if (!this.transform(mutation).hasClientExports)
                return [3, 2];
              return [4, this.localState.addExportedVariables(mutation, variables, context2)];
            case 1:
              variables = _h.sent();
              _h.label = 2;
            case 2:
              mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                mutation,
                variables,
                loading: true,
                error: null
              });
              if (optimisticResponse) {
                this.markMutationOptimistic(optimisticResponse, {
                  mutationId,
                  document: mutation,
                  variables,
                  fetchPolicy,
                  errorPolicy,
                  context: context2,
                  updateQueries,
                  update: updateWithProxyFn,
                  keepRootFields
                });
              }
              this.broadcastQueries();
              self2 = this;
              return [2, new Promise(function(resolve, reject) {
                return asyncMap(self2.getObservableFromLink(mutation, __assign2(__assign2({}, context2), { optimisticResponse }), variables, false), function(result2) {
                  if (graphQLResultHasError(result2) && errorPolicy === "none") {
                    throw new ApolloError({
                      graphQLErrors: result2.errors
                    });
                  }
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = null;
                  }
                  var storeResult = __assign2({}, result2);
                  if (typeof refetchQueries === "function") {
                    refetchQueries = refetchQueries(storeResult);
                  }
                  if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                    delete storeResult.errors;
                  }
                  return self2.markMutationResult({
                    mutationId,
                    result: storeResult,
                    document: mutation,
                    variables,
                    fetchPolicy,
                    errorPolicy,
                    context: context2,
                    update: updateWithProxyFn,
                    updateQueries,
                    awaitRefetchQueries,
                    refetchQueries,
                    removeOptimistic: optimisticResponse ? mutationId : void 0,
                    onQueryUpdated,
                    keepRootFields
                  });
                }).subscribe({
                  next: function(storeResult) {
                    self2.broadcastQueries();
                    resolve(storeResult);
                  },
                  error: function(err) {
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = err;
                    }
                    if (optimisticResponse) {
                      self2.cache.removeOptimistic(mutationId);
                    }
                    self2.broadcastQueries();
                    reject(err instanceof ApolloError ? err : new ApolloError({
                      networkError: err
                    }));
                  }
                });
              })];
          }
        });
      });
    };
    QueryManager2.prototype.markMutationResult = function(mutation, cache4) {
      var _this = this;
      if (cache4 === void 0) {
        cache4 = this.cache;
      }
      var result2 = mutation.result;
      var cacheWrites = [];
      var skipCache = mutation.fetchPolicy === "no-cache";
      if (!skipCache && shouldWriteResult(result2, mutation.errorPolicy)) {
        cacheWrites.push({
          result: result2.data,
          dataId: "ROOT_MUTATION",
          query: mutation.document,
          variables: mutation.variables
        });
        var updateQueries_1 = mutation.updateQueries;
        if (updateQueries_1) {
          this.queries.forEach(function(_a5, queryId) {
            var observableQuery = _a5.observableQuery;
            var queryName = observableQuery && observableQuery.queryName;
            if (!queryName || !hasOwnProperty5.call(updateQueries_1, queryName)) {
              return;
            }
            var updater = updateQueries_1[queryName];
            var _b = _this.queries.get(queryId), document2 = _b.document, variables = _b.variables;
            var _c = cache4.diff({
              query: document2,
              variables,
              returnPartialData: true,
              optimistic: false
            }), currentQueryResult = _c.result, complete = _c.complete;
            if (complete && currentQueryResult) {
              var nextQueryResult = updater(currentQueryResult, {
                mutationResult: result2,
                queryName: document2 && getOperationName(document2) || void 0,
                queryVariables: variables
              });
              if (nextQueryResult) {
                cacheWrites.push({
                  result: nextQueryResult,
                  dataId: "ROOT_QUERY",
                  query: document2,
                  variables
                });
              }
            }
          });
        }
      }
      if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
        var results_1 = [];
        this.refetchQueries({
          updateCache: function(cache5) {
            if (!skipCache) {
              cacheWrites.forEach(function(write) {
                return cache5.write(write);
              });
            }
            var update = mutation.update;
            if (update) {
              if (!skipCache) {
                var diff = cache5.diff({
                  id: "ROOT_MUTATION",
                  query: _this.transform(mutation.document).asQuery,
                  variables: mutation.variables,
                  optimistic: false,
                  returnPartialData: true
                });
                if (diff.complete) {
                  result2 = __assign2(__assign2({}, result2), { data: diff.result });
                }
              }
              update(cache5, result2, {
                context: mutation.context,
                variables: mutation.variables
              });
            }
            if (!skipCache && !mutation.keepRootFields) {
              cache5.modify({
                id: "ROOT_MUTATION",
                fields: function(value, _a5) {
                  var fieldName = _a5.fieldName, DELETE = _a5.DELETE;
                  return fieldName === "__typename" ? value : DELETE;
                }
              });
            }
          },
          include: mutation.refetchQueries,
          optimistic: false,
          removeOptimistic: mutation.removeOptimistic,
          onQueryUpdated: mutation.onQueryUpdated || null
        }).forEach(function(result3) {
          return results_1.push(result3);
        });
        if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
          return Promise.all(results_1).then(function() {
            return result2;
          });
        }
      }
      return Promise.resolve(result2);
    };
    QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
      var _this = this;
      var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables) : optimisticResponse;
      return this.cache.recordOptimisticTransaction(function(cache4) {
        try {
          _this.markMutationResult(__assign2(__assign2({}, mutation), { result: { data } }), cache4);
        } catch (error) {
          __DEV__ && invariant2.error(error);
        }
      }, mutation.mutationId);
    };
    QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
      return this.fetchQueryObservable(queryId, options, networkStatus).promise;
    };
    QueryManager2.prototype.getQueryStore = function() {
      var store = /* @__PURE__ */ Object.create(null);
      this.queries.forEach(function(info, queryId) {
        store[queryId] = {
          variables: info.variables,
          networkStatus: info.networkStatus,
          networkError: info.networkError,
          graphQLErrors: info.graphQLErrors
        };
      });
      return store;
    };
    QueryManager2.prototype.resetErrors = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo) {
        queryInfo.networkError = void 0;
        queryInfo.graphQLErrors = [];
      }
    };
    QueryManager2.prototype.transform = function(document2) {
      var transformCache = this.transformCache;
      if (!transformCache.has(document2)) {
        var transformed = this.cache.transformDocument(document2);
        var forLink = removeConnectionDirectiveFromDocument(this.cache.transformForLink(transformed));
        var clientQuery = this.localState.clientQuery(transformed);
        var serverQuery = forLink && this.localState.serverQuery(forLink);
        var cacheEntry_1 = {
          document: transformed,
          hasClientExports: hasClientExports(transformed),
          hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
          clientQuery,
          serverQuery,
          defaultVars: getDefaultValues(getOperationDefinition(transformed)),
          asQuery: __assign2(__assign2({}, transformed), { definitions: transformed.definitions.map(function(def) {
            if (def.kind === "OperationDefinition" && def.operation !== "query") {
              return __assign2(__assign2({}, def), { operation: "query" });
            }
            return def;
          }) })
        };
        var add = function(doc) {
          if (doc && !transformCache.has(doc)) {
            transformCache.set(doc, cacheEntry_1);
          }
        };
        add(document2);
        add(transformed);
        add(clientQuery);
        add(serverQuery);
      }
      return transformCache.get(document2);
    };
    QueryManager2.prototype.getVariables = function(document2, variables) {
      return __assign2(__assign2({}, this.transform(document2).defaultVars), variables);
    };
    QueryManager2.prototype.watchQuery = function(options) {
      options = __assign2(__assign2({}, options), { variables: this.getVariables(options.query, options.variables) });
      if (typeof options.notifyOnNetworkStatusChange === "undefined") {
        options.notifyOnNetworkStatusChange = false;
      }
      var queryInfo = new QueryInfo(this);
      var observable = new ObservableQuery({
        queryManager: this,
        queryInfo,
        options
      });
      this.queries.set(observable.queryId, queryInfo);
      queryInfo.init({
        document: observable.query,
        observableQuery: observable,
        variables: observable.variables
      });
      return observable;
    };
    QueryManager2.prototype.query = function(options, queryId) {
      var _this = this;
      if (queryId === void 0) {
        queryId = this.generateQueryId();
      }
      __DEV__ ? invariant2(options.query, "query option is required. You must specify your GraphQL document in the query option.") : invariant2(options.query, 14);
      __DEV__ ? invariant2(options.query.kind === "Document", 'You must wrap the query string in a "gql" tag.') : invariant2(options.query.kind === "Document", 15);
      __DEV__ ? invariant2(!options.returnPartialData, "returnPartialData option only supported on watchQuery.") : invariant2(!options.returnPartialData, 16);
      __DEV__ ? invariant2(!options.pollInterval, "pollInterval option only supported on watchQuery.") : invariant2(!options.pollInterval, 17);
      return this.fetchQuery(queryId, options).finally(function() {
        return _this.stopQuery(queryId);
      });
    };
    QueryManager2.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    };
    QueryManager2.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    };
    QueryManager2.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    };
    QueryManager2.prototype.stopQueryInStore = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo)
        queryInfo.stop();
    };
    QueryManager2.prototype.clearStore = function(options) {
      if (options === void 0) {
        options = {
          discardWatches: true
        };
      }
      this.cancelPendingFetches(__DEV__ ? new InvariantError("Store reset while query was in flight (not completed in link chain)") : new InvariantError(18));
      this.queries.forEach(function(queryInfo) {
        if (queryInfo.observableQuery) {
          queryInfo.networkStatus = NetworkStatus.loading;
        } else {
          queryInfo.stop();
        }
      });
      if (this.mutationStore) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
      return this.cache.reset(options);
    };
    QueryManager2.prototype.getObservableQueries = function(include) {
      var _this = this;
      if (include === void 0) {
        include = "active";
      }
      var queries = /* @__PURE__ */ new Map();
      var queryNamesAndDocs = /* @__PURE__ */ new Map();
      var legacyQueryOptions = /* @__PURE__ */ new Set();
      if (Array.isArray(include)) {
        include.forEach(function(desc) {
          if (typeof desc === "string") {
            queryNamesAndDocs.set(desc, false);
          } else if (isDocumentNode(desc)) {
            queryNamesAndDocs.set(_this.transform(desc).document, false);
          } else if (isNonNullObject(desc) && desc.query) {
            legacyQueryOptions.add(desc);
          }
        });
      }
      this.queries.forEach(function(_a5, queryId) {
        var oq = _a5.observableQuery, document2 = _a5.document;
        if (oq) {
          if (include === "all") {
            queries.set(queryId, oq);
            return;
          }
          var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
          if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
            return;
          }
          if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document2 && queryNamesAndDocs.has(document2)) {
            queries.set(queryId, oq);
            if (queryName)
              queryNamesAndDocs.set(queryName, true);
            if (document2)
              queryNamesAndDocs.set(document2, true);
          }
        }
      });
      if (legacyQueryOptions.size) {
        legacyQueryOptions.forEach(function(options) {
          var queryId = makeUniqueId("legacyOneTimeQuery");
          var queryInfo = _this.getQuery(queryId).init({
            document: options.query,
            variables: options.variables
          });
          var oq = new ObservableQuery({
            queryManager: _this,
            queryInfo,
            options: __assign2(__assign2({}, options), { fetchPolicy: "network-only" })
          });
          invariant2(oq.queryId === queryId);
          queryInfo.setObservableQuery(oq);
          queries.set(queryId, oq);
        });
      }
      if (__DEV__ && queryNamesAndDocs.size) {
        queryNamesAndDocs.forEach(function(included, nameOrDoc) {
          if (!included) {
            __DEV__ && invariant2.warn("Unknown query ".concat(typeof nameOrDoc === "string" ? "named " : "").concat(JSON.stringify(nameOrDoc, null, 2), " requested in refetchQueries options.include array"));
          }
        });
      }
      return queries;
    };
    QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
      var _this = this;
      if (includeStandby === void 0) {
        includeStandby = false;
      }
      var observableQueryPromises = [];
      this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
        var fetchPolicy = observableQuery.options.fetchPolicy;
        observableQuery.resetLastResults();
        if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
          observableQueryPromises.push(observableQuery.refetch());
        }
        _this.getQuery(queryId).setDiff(null);
      });
      this.broadcastQueries();
      return Promise.all(observableQueryPromises);
    };
    QueryManager2.prototype.setObservableQuery = function(observableQuery) {
      this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
    };
    QueryManager2.prototype.startGraphQLSubscription = function(_a5) {
      var _this = this;
      var query = _a5.query, fetchPolicy = _a5.fetchPolicy, errorPolicy = _a5.errorPolicy, variables = _a5.variables, _b = _a5.context, context2 = _b === void 0 ? {} : _b;
      query = this.transform(query).document;
      variables = this.getVariables(query, variables);
      var makeObservable = function(variables2) {
        return _this.getObservableFromLink(query, context2, variables2).map(function(result2) {
          if (fetchPolicy !== "no-cache") {
            if (shouldWriteResult(result2, errorPolicy)) {
              _this.cache.write({
                query,
                result: result2.data,
                dataId: "ROOT_SUBSCRIPTION",
                variables: variables2
              });
            }
            _this.broadcastQueries();
          }
          if (graphQLResultHasError(result2)) {
            throw new ApolloError({
              graphQLErrors: result2.errors
            });
          }
          return result2;
        });
      };
      if (this.transform(query).hasClientExports) {
        var observablePromise_1 = this.localState.addExportedVariables(query, variables, context2).then(makeObservable);
        return new Observable(function(observer) {
          var sub = null;
          observablePromise_1.then(function(observable) {
            return sub = observable.subscribe(observer);
          }, observer.error);
          return function() {
            return sub && sub.unsubscribe();
          };
        });
      }
      return makeObservable(variables);
    };
    QueryManager2.prototype.stopQuery = function(queryId) {
      this.stopQueryNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.removeQuery(queryId);
    };
    QueryManager2.prototype.removeQuery = function(queryId) {
      this.fetchCancelFns.delete(queryId);
      if (this.queries.has(queryId)) {
        this.getQuery(queryId).stop();
        this.queries.delete(queryId);
      }
    };
    QueryManager2.prototype.broadcastQueries = function() {
      if (this.onBroadcast)
        this.onBroadcast();
      this.queries.forEach(function(info) {
        return info.notify();
      });
    };
    QueryManager2.prototype.getLocalState = function() {
      return this.localState;
    };
    QueryManager2.prototype.getObservableFromLink = function(query, context2, variables, deduplication) {
      var _this = this;
      var _a5;
      if (deduplication === void 0) {
        deduplication = (_a5 = context2 === null || context2 === void 0 ? void 0 : context2.queryDeduplication) !== null && _a5 !== void 0 ? _a5 : this.queryDeduplication;
      }
      var observable;
      var serverQuery = this.transform(query).serverQuery;
      if (serverQuery) {
        var _b = this, inFlightLinkObservables_1 = _b.inFlightLinkObservables, link = _b.link;
        var operation = {
          query: serverQuery,
          variables,
          operationName: getOperationName(serverQuery) || void 0,
          context: this.prepareContext(__assign2(__assign2({}, context2), { forceFetch: !deduplication }))
        };
        context2 = operation.context;
        if (deduplication) {
          var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || /* @__PURE__ */ new Map();
          inFlightLinkObservables_1.set(serverQuery, byVariables_1);
          var varJson_1 = canonicalStringify(variables);
          observable = byVariables_1.get(varJson_1);
          if (!observable) {
            var concast = new Concast([
              execute(link, operation)
            ]);
            byVariables_1.set(varJson_1, observable = concast);
            concast.cleanup(function() {
              if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {
                inFlightLinkObservables_1.delete(serverQuery);
              }
            });
          }
        } else {
          observable = new Concast([
            execute(link, operation)
          ]);
        }
      } else {
        observable = new Concast([
          Observable.of({ data: {} })
        ]);
        context2 = this.prepareContext(context2);
      }
      var clientQuery = this.transform(query).clientQuery;
      if (clientQuery) {
        observable = asyncMap(observable, function(result2) {
          return _this.localState.runResolvers({
            document: clientQuery,
            remoteResult: result2,
            context: context2,
            variables
          });
        });
      }
      return observable;
    };
    QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
      var requestId = queryInfo.lastRequestId = this.generateRequestId();
      return asyncMap(this.getObservableFromLink(queryInfo.document, options.context, options.variables), function(result2) {
        var hasErrors = isNonEmptyArray(result2.errors);
        if (requestId >= queryInfo.lastRequestId) {
          if (hasErrors && options.errorPolicy === "none") {
            throw queryInfo.markError(new ApolloError({
              graphQLErrors: result2.errors
            }));
          }
          queryInfo.markResult(result2, options, cacheWriteBehavior);
          queryInfo.markReady();
        }
        var aqr = {
          data: result2.data,
          loading: false,
          networkStatus: NetworkStatus.ready
        };
        if (hasErrors && options.errorPolicy !== "ignore") {
          aqr.errors = result2.errors;
          aqr.networkStatus = NetworkStatus.error;
        }
        return aqr;
      }, function(networkError) {
        var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
        if (requestId >= queryInfo.lastRequestId) {
          queryInfo.markError(error);
        }
        throw error;
      });
    };
    QueryManager2.prototype.fetchQueryObservable = function(queryId, options, networkStatus) {
      var _this = this;
      if (networkStatus === void 0) {
        networkStatus = NetworkStatus.loading;
      }
      var query = this.transform(options.query).document;
      var variables = this.getVariables(query, options.variables);
      var queryInfo = this.getQuery(queryId);
      var defaults = this.defaultOptions.watchQuery;
      var _a5 = options.fetchPolicy, fetchPolicy = _a5 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a5, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context2 = _e === void 0 ? {} : _e;
      var normalized = Object.assign({}, options, {
        query,
        variables,
        fetchPolicy,
        errorPolicy,
        returnPartialData,
        notifyOnNetworkStatusChange,
        context: context2
      });
      var fromVariables = function(variables2) {
        normalized.variables = variables2;
        var concastSources = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
        if (normalized.fetchPolicy !== "standby" && concastSources.length > 0 && queryInfo.observableQuery) {
          queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
        }
        return concastSources;
      };
      var cleanupCancelFn = function() {
        return _this.fetchCancelFns.delete(queryId);
      };
      this.fetchCancelFns.set(queryId, function(reason) {
        cleanupCancelFn();
        setTimeout(function() {
          return concast.cancel(reason);
        });
      });
      var concast = new Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));
      concast.promise.then(cleanupCancelFn, cleanupCancelFn);
      return concast;
    };
    QueryManager2.prototype.refetchQueries = function(_a5) {
      var _this = this;
      var updateCache = _a5.updateCache, include = _a5.include, _b = _a5.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a5.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a5.onQueryUpdated;
      var includedQueriesById = /* @__PURE__ */ new Map();
      if (include) {
        this.getObservableQueries(include).forEach(function(oq, queryId) {
          includedQueriesById.set(queryId, {
            oq,
            lastDiff: _this.getQuery(queryId).getDiff()
          });
        });
      }
      var results = /* @__PURE__ */ new Map();
      if (updateCache) {
        this.cache.batch({
          update: updateCache,
          optimistic: optimistic && removeOptimistic || false,
          removeOptimistic,
          onWatchUpdated: function(watch, diff, lastDiff) {
            var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
            if (oq) {
              if (onQueryUpdated) {
                includedQueriesById.delete(oq.queryId);
                var result2 = onQueryUpdated(oq, diff, lastDiff);
                if (result2 === true) {
                  result2 = oq.refetch();
                }
                if (result2 !== false) {
                  results.set(oq, result2);
                }
                return result2;
              }
              if (onQueryUpdated !== null) {
                includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
              }
            }
          }
        });
      }
      if (includedQueriesById.size) {
        includedQueriesById.forEach(function(_a6, queryId) {
          var oq = _a6.oq, lastDiff = _a6.lastDiff, diff = _a6.diff;
          var result2;
          if (onQueryUpdated) {
            if (!diff) {
              var info = oq["queryInfo"];
              info.reset();
              diff = info.getDiff();
            }
            result2 = onQueryUpdated(oq, diff, lastDiff);
          }
          if (!onQueryUpdated || result2 === true) {
            result2 = oq.refetch();
          }
          if (result2 !== false) {
            results.set(oq, result2);
          }
          if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
            _this.stopQueryNoBroadcast(queryId);
          }
        });
      }
      if (removeOptimistic) {
        this.cache.removeOptimistic(removeOptimistic);
      }
      return results;
    };
    QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a5, networkStatus) {
      var _this = this;
      var query = _a5.query, variables = _a5.variables, fetchPolicy = _a5.fetchPolicy, refetchWritePolicy = _a5.refetchWritePolicy, errorPolicy = _a5.errorPolicy, returnPartialData = _a5.returnPartialData, context2 = _a5.context, notifyOnNetworkStatusChange = _a5.notifyOnNetworkStatusChange;
      var oldNetworkStatus = queryInfo.networkStatus;
      queryInfo.init({
        document: this.transform(query).document,
        variables,
        networkStatus
      });
      var readCache = function() {
        return queryInfo.getDiff(variables);
      };
      var resultsFromCache = function(diff2, networkStatus2) {
        if (networkStatus2 === void 0) {
          networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
        }
        var data = diff2.result;
        if (__DEV__ && !returnPartialData && !equal(data, {})) {
          logMissingFieldErrors(diff2.missing);
        }
        var fromData = function(data2) {
          return Observable.of(__assign2({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
        };
        if (data && _this.transform(query).hasForcedResolvers) {
          return _this.localState.runResolvers({
            document: query,
            remoteResult: { data },
            context: context2,
            variables,
            onlyRunForcedResolvers: true
          }).then(function(resolved) {
            return fromData(resolved.data || void 0);
          });
        }
        return fromData(data);
      };
      var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
      var resultsFromLink = function() {
        return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
          variables,
          context: context2,
          fetchPolicy,
          errorPolicy
        });
      };
      var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
      switch (fetchPolicy) {
        default:
        case "cache-first": {
          var diff = readCache();
          if (diff.complete) {
            return [
              resultsFromCache(diff, queryInfo.markReady())
            ];
          }
          if (returnPartialData || shouldNotify) {
            return [
              resultsFromCache(diff),
              resultsFromLink()
            ];
          }
          return [
            resultsFromLink()
          ];
        }
        case "cache-and-network": {
          var diff = readCache();
          if (diff.complete || returnPartialData || shouldNotify) {
            return [
              resultsFromCache(diff),
              resultsFromLink()
            ];
          }
          return [
            resultsFromLink()
          ];
        }
        case "cache-only":
          return [
            resultsFromCache(readCache(), queryInfo.markReady())
          ];
        case "network-only":
          if (shouldNotify) {
            return [
              resultsFromCache(readCache()),
              resultsFromLink()
            ];
          }
          return [resultsFromLink()];
        case "no-cache":
          if (shouldNotify) {
            return [
              resultsFromCache(queryInfo.getDiff()),
              resultsFromLink()
            ];
          }
          return [resultsFromLink()];
        case "standby":
          return [];
      }
    };
    QueryManager2.prototype.getQuery = function(queryId) {
      if (queryId && !this.queries.has(queryId)) {
        this.queries.set(queryId, new QueryInfo(this, queryId));
      }
      return this.queries.get(queryId);
    };
    QueryManager2.prototype.prepareContext = function(context2) {
      if (context2 === void 0) {
        context2 = {};
      }
      var newContext = this.localState.prepareContext(context2);
      return __assign2(__assign2({}, newContext), { clientAwareness: this.clientAwareness });
    };
    return QueryManager2;
  }();

  // node_modules/@apollo/client/core/ApolloClient.js
  var hasSuggestedDevtools = false;
  var ApolloClient = function() {
    function ApolloClient2(options) {
      var _this = this;
      this.resetStoreCallbacks = [];
      this.clearStoreCallbacks = [];
      var uri = options.uri, credentials = options.credentials, headers = options.headers, cache4 = options.cache, _a5 = options.ssrMode, ssrMode = _a5 === void 0 ? false : _a5, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window === "object" && !window.__APOLLO_CLIENT__ && __DEV__ : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions2 = options.defaultOptions, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? false : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
      var link = options.link;
      if (!link) {
        link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
      }
      if (!cache4) {
        throw __DEV__ ? new InvariantError("To initialize Apollo Client, you must specify a 'cache' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs") : new InvariantError(7);
      }
      this.link = link;
      this.cache = cache4;
      this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
      this.queryDeduplication = queryDeduplication;
      this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
      this.typeDefs = typeDefs;
      if (ssrForceFetchDelay) {
        setTimeout(function() {
          return _this.disableNetworkFetches = false;
        }, ssrForceFetchDelay);
      }
      this.watchQuery = this.watchQuery.bind(this);
      this.query = this.query.bind(this);
      this.mutate = this.mutate.bind(this);
      this.resetStore = this.resetStore.bind(this);
      this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
      if (connectToDevTools && typeof window === "object") {
        window.__APOLLO_CLIENT__ = this;
      }
      if (!hasSuggestedDevtools && __DEV__) {
        hasSuggestedDevtools = true;
        if (typeof window !== "undefined" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
          var nav = window.navigator;
          var ua = nav && nav.userAgent;
          var url = void 0;
          if (typeof ua === "string") {
            if (ua.indexOf("Chrome/") > -1) {
              url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
            } else if (ua.indexOf("Firefox/") > -1) {
              url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
            }
          }
          if (url) {
            __DEV__ && invariant2.log("Download the Apollo DevTools for a better development experience: " + url);
          }
        }
      }
      this.version = version;
      this.localState = new LocalState({
        cache: cache4,
        client: this,
        resolvers,
        fragmentMatcher
      });
      this.queryManager = new QueryManager({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        queryDeduplication,
        ssrMode,
        clientAwareness: {
          name: clientAwarenessName,
          version: clientAwarenessVersion
        },
        localState: this.localState,
        assumeImmutableResults,
        onBroadcast: connectToDevTools ? function() {
          if (_this.devToolsHookCb) {
            _this.devToolsHookCb({
              action: {},
              state: {
                queries: _this.queryManager.getQueryStore(),
                mutations: _this.queryManager.mutationStore || {}
              },
              dataWithOptimisticResults: _this.cache.extract(true)
            });
          }
        } : void 0
      });
    }
    ApolloClient2.prototype.stop = function() {
      this.queryManager.stop();
    };
    ApolloClient2.prototype.watchQuery = function(options) {
      if (this.defaultOptions.watchQuery) {
        options = mergeOptions(this.defaultOptions.watchQuery, options);
      }
      if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
        options = __assign2(__assign2({}, options), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.watchQuery(options);
    };
    ApolloClient2.prototype.query = function(options) {
      if (this.defaultOptions.query) {
        options = mergeOptions(this.defaultOptions.query, options);
      }
      __DEV__ ? invariant2(options.fetchPolicy !== "cache-and-network", "The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only.") : invariant2(options.fetchPolicy !== "cache-and-network", 8);
      if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
        options = __assign2(__assign2({}, options), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.query(options);
    };
    ApolloClient2.prototype.mutate = function(options) {
      if (this.defaultOptions.mutate) {
        options = mergeOptions(this.defaultOptions.mutate, options);
      }
      return this.queryManager.mutate(options);
    };
    ApolloClient2.prototype.subscribe = function(options) {
      return this.queryManager.startGraphQLSubscription(options);
    };
    ApolloClient2.prototype.readQuery = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readQuery(options, optimistic);
    };
    ApolloClient2.prototype.readFragment = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readFragment(options, optimistic);
    };
    ApolloClient2.prototype.writeQuery = function(options) {
      this.cache.writeQuery(options);
      this.queryManager.broadcastQueries();
    };
    ApolloClient2.prototype.writeFragment = function(options) {
      this.cache.writeFragment(options);
      this.queryManager.broadcastQueries();
    };
    ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
      this.devToolsHookCb = cb;
    };
    ApolloClient2.prototype.__requestRaw = function(payload) {
      return execute(this.link, payload);
    };
    ApolloClient2.prototype.resetStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: false
        });
      }).then(function() {
        return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
          return fn();
        }));
      }).then(function() {
        return _this.reFetchObservableQueries();
      });
    };
    ApolloClient2.prototype.clearStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: true
        });
      }).then(function() {
        return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
          return fn();
        }));
      });
    };
    ApolloClient2.prototype.onResetStore = function(cb) {
      var _this = this;
      this.resetStoreCallbacks.push(cb);
      return function() {
        _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
          return c !== cb;
        });
      };
    };
    ApolloClient2.prototype.onClearStore = function(cb) {
      var _this = this;
      this.clearStoreCallbacks.push(cb);
      return function() {
        _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
          return c !== cb;
        });
      };
    };
    ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
      return this.queryManager.reFetchObservableQueries(includeStandby);
    };
    ApolloClient2.prototype.refetchQueries = function(options) {
      var map = this.queryManager.refetchQueries(options);
      var queries = [];
      var results = [];
      map.forEach(function(result3, obsQuery) {
        queries.push(obsQuery);
        results.push(result3);
      });
      var result2 = Promise.all(results);
      result2.queries = queries;
      result2.results = results;
      result2.catch(function(error) {
        __DEV__ && invariant2.debug("In client.refetchQueries, Promise.all promise rejected with error ".concat(error));
      });
      return result2;
    };
    ApolloClient2.prototype.getObservableQueries = function(include) {
      if (include === void 0) {
        include = "active";
      }
      return this.queryManager.getObservableQueries(include);
    };
    ApolloClient2.prototype.extract = function(optimistic) {
      return this.cache.extract(optimistic);
    };
    ApolloClient2.prototype.restore = function(serializedState) {
      return this.cache.restore(serializedState);
    };
    ApolloClient2.prototype.addResolvers = function(resolvers) {
      this.localState.addResolvers(resolvers);
    };
    ApolloClient2.prototype.setResolvers = function(resolvers) {
      this.localState.setResolvers(resolvers);
    };
    ApolloClient2.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    };
    ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
      this.localState.setFragmentMatcher(fragmentMatcher);
    };
    ApolloClient2.prototype.setLink = function(newLink) {
      this.link = this.queryManager.link = newLink;
    };
    return ApolloClient2;
  }();

  // node_modules/graphql-tag/node_modules/tslib/modules/index.js
  var import_tslib21 = __toESM(require_tslib3(), 1);
  var {
    __extends: __extends3,
    __assign: __assign3,
    __rest: __rest3,
    __decorate: __decorate3,
    __param: __param3,
    __metadata: __metadata3,
    __awaiter: __awaiter3,
    __generator: __generator3,
    __exportStar: __exportStar3,
    __createBinding: __createBinding3,
    __values: __values3,
    __read: __read3,
    __spread: __spread3,
    __spreadArrays: __spreadArrays3,
    __spreadArray: __spreadArray3,
    __await: __await3,
    __asyncGenerator: __asyncGenerator3,
    __asyncDelegator: __asyncDelegator3,
    __asyncValues: __asyncValues3,
    __makeTemplateObject: __makeTemplateObject3,
    __importStar: __importStar3,
    __importDefault: __importDefault3,
    __classPrivateFieldGet: __classPrivateFieldGet3,
    __classPrivateFieldSet: __classPrivateFieldSet3,
    __classPrivateFieldIn: __classPrivateFieldIn3
  } = import_tslib21.default;

  // node_modules/graphql-tag/lib/index.js
  var docCache = /* @__PURE__ */ new Map();
  var fragmentSourceMap = /* @__PURE__ */ new Map();
  var printFragmentWarnings = true;
  var experimentalFragmentVariables = false;
  function normalize(string) {
    return string.replace(/[\s,]+/g, " ").trim();
  }
  function cacheKeyFromLoc(loc) {
    return normalize(loc.source.body.substring(loc.start, loc.end));
  }
  function processFragments(ast) {
    var seenKeys = /* @__PURE__ */ new Set();
    var definitions = [];
    ast.definitions.forEach(function(fragmentDefinition) {
      if (fragmentDefinition.kind === "FragmentDefinition") {
        var fragmentName = fragmentDefinition.name.value;
        var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
        var sourceKeySet = fragmentSourceMap.get(fragmentName);
        if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
          if (printFragmentWarnings) {
            console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
          }
        } else if (!sourceKeySet) {
          fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
        }
        sourceKeySet.add(sourceKey);
        if (!seenKeys.has(sourceKey)) {
          seenKeys.add(sourceKey);
          definitions.push(fragmentDefinition);
        }
      } else {
        definitions.push(fragmentDefinition);
      }
    });
    return __assign3(__assign3({}, ast), { definitions });
  }
  function stripLoc(doc) {
    var workSet = new Set(doc.definitions);
    workSet.forEach(function(node) {
      if (node.loc)
        delete node.loc;
      Object.keys(node).forEach(function(key) {
        var value = node[key];
        if (value && typeof value === "object") {
          workSet.add(value);
        }
      });
    });
    var loc = doc.loc;
    if (loc) {
      delete loc.startToken;
      delete loc.endToken;
    }
    return doc;
  }
  function parseDocument(source) {
    var cacheKey = normalize(source);
    if (!docCache.has(cacheKey)) {
      var parsed = parse(source, {
        experimentalFragmentVariables,
        allowLegacyFragmentVariables: experimentalFragmentVariables
      });
      if (!parsed || parsed.kind !== "Document") {
        throw new Error("Not a valid GraphQL document.");
      }
      docCache.set(cacheKey, stripLoc(processFragments(parsed)));
    }
    return docCache.get(cacheKey);
  }
  function gql(literals) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (typeof literals === "string") {
      literals = [literals];
    }
    var result2 = literals[0];
    args.forEach(function(arg, i) {
      if (arg && arg.kind === "Document") {
        result2 += arg.loc.source.body;
      } else {
        result2 += arg;
      }
      result2 += literals[i + 1];
    });
    return parseDocument(result2);
  }
  function resetCaches() {
    docCache.clear();
    fragmentSourceMap.clear();
  }
  function disableFragmentWarnings() {
    printFragmentWarnings = false;
  }
  function enableExperimentalFragmentVariables() {
    experimentalFragmentVariables = true;
  }
  function disableExperimentalFragmentVariables() {
    experimentalFragmentVariables = false;
  }
  var extras = {
    gql,
    resetCaches,
    disableFragmentWarnings,
    enableExperimentalFragmentVariables,
    disableExperimentalFragmentVariables
  };
  (function(gql_1) {
    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
  })(gql || (gql = {}));
  gql["default"] = gql;

  // node_modules/@apollo/client/core/index.js
  setVerbosity(DEV_default ? "log" : "silent");

  // node_modules/@apollo/client/react/context/ApolloContext.js
  var React100 = __toESM(require_react(), 1);
  var contextKey = canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
  function getApolloContext() {
    var context2 = React100.createContext[contextKey];
    if (!context2) {
      Object.defineProperty(React100.createContext, contextKey, {
        value: context2 = React100.createContext({}),
        enumerable: false,
        writable: false,
        configurable: true
      });
      context2.displayName = "ApolloContext";
    }
    return context2;
  }

  // node_modules/@apollo/client/react/hooks/useApolloClient.js
  var import_react113 = __toESM(require_react(), 1);
  function useApolloClient(override) {
    var context2 = (0, import_react113.useContext)(getApolloContext());
    var client = override || context2.client;
    __DEV__ ? invariant2(!!client, 'Could not find "client" in the context or passed in as an option. Wrap the root component in an <ApolloProvider>, or pass an ApolloClient instance in via options.') : invariant2(!!client, 29);
    return client;
  }

  // node_modules/@apollo/client/react/hooks/useQuery.js
  var import_react114 = __toESM(require_react(), 1);

  // node_modules/@apollo/client/react/hooks/useSyncExternalStore.js
  var React101 = __toESM(require_react(), 1);
  var didWarnUncachedGetSnapshot = false;
  var uSESKey = "useSyncExternalStore";
  var realHook = React101[uSESKey];
  var useSyncExternalStore = realHook || function(subscribe, getSnapshot, getServerSnapshot) {
    var value = getSnapshot();
    if (__DEV__ && !didWarnUncachedGetSnapshot && value !== getSnapshot()) {
      didWarnUncachedGetSnapshot = true;
      __DEV__ && invariant2.error("The result of getSnapshot should be cached to avoid an infinite loop");
    }
    var _a5 = React101.useState({ inst: { value, getSnapshot } }), inst = _a5[0].inst, forceUpdate = _a5[1];
    if (canUseLayoutEffect) {
      React101.useLayoutEffect(function() {
        Object.assign(inst, { value, getSnapshot });
        if (checkIfSnapshotChanged(inst)) {
          forceUpdate({ inst });
        }
      }, [subscribe, value, getSnapshot]);
    } else {
      Object.assign(inst, { value, getSnapshot });
    }
    React101.useEffect(function() {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
      return subscribe(function handleStoreChange() {
        if (checkIfSnapshotChanged(inst)) {
          forceUpdate({ inst });
        }
      });
    }, [subscribe]);
    return value;
  };
  function checkIfSnapshotChanged(_a5) {
    var value = _a5.value, getSnapshot = _a5.getSnapshot;
    try {
      return value !== getSnapshot();
    } catch (_b) {
      return true;
    }
  }

  // node_modules/@apollo/client/react/parser/index.js
  var DocumentType;
  (function(DocumentType2) {
    DocumentType2[DocumentType2["Query"] = 0] = "Query";
    DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
    DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
  })(DocumentType || (DocumentType = {}));
  var cache3 = /* @__PURE__ */ new Map();
  function operationName(type) {
    var name;
    switch (type) {
      case DocumentType.Query:
        name = "Query";
        break;
      case DocumentType.Mutation:
        name = "Mutation";
        break;
      case DocumentType.Subscription:
        name = "Subscription";
        break;
    }
    return name;
  }
  function parser(document2) {
    var cached = cache3.get(document2);
    if (cached)
      return cached;
    var variables, type, name;
    __DEV__ ? invariant2(!!document2 && !!document2.kind, "Argument of ".concat(document2, " passed to parser was not a valid GraphQL ") + "DocumentNode. You may need to use 'graphql-tag' or another method to convert your operation into a document") : invariant2(!!document2 && !!document2.kind, 30);
    var fragments = [];
    var queries = [];
    var mutations = [];
    var subscriptions = [];
    for (var _i = 0, _a5 = document2.definitions; _i < _a5.length; _i++) {
      var x = _a5[_i];
      if (x.kind === "FragmentDefinition") {
        fragments.push(x);
        continue;
      }
      if (x.kind === "OperationDefinition") {
        switch (x.operation) {
          case "query":
            queries.push(x);
            break;
          case "mutation":
            mutations.push(x);
            break;
          case "subscription":
            subscriptions.push(x);
            break;
        }
      }
    }
    __DEV__ ? invariant2(!fragments.length || (queries.length || mutations.length || subscriptions.length), "Passing only a fragment to 'graphql' is not yet supported. You must include a query, subscription or mutation as well") : invariant2(!fragments.length || (queries.length || mutations.length || subscriptions.length), 31);
    __DEV__ ? invariant2(queries.length + mutations.length + subscriptions.length <= 1, "react-apollo only supports a query, subscription, or a mutation per HOC. " + "".concat(document2, " had ").concat(queries.length, " queries, ").concat(subscriptions.length, " ") + "subscriptions and ".concat(mutations.length, " mutations. ") + "You can use 'compose' to join multiple operation types to a component") : invariant2(queries.length + mutations.length + subscriptions.length <= 1, 32);
    type = queries.length ? DocumentType.Query : DocumentType.Mutation;
    if (!queries.length && !mutations.length)
      type = DocumentType.Subscription;
    var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
    __DEV__ ? invariant2(definitions.length === 1, "react-apollo only supports one definition per HOC. ".concat(document2, " had ") + "".concat(definitions.length, " definitions. ") + "You can use 'compose' to join multiple operation types to a component") : invariant2(definitions.length === 1, 33);
    var definition = definitions[0];
    variables = definition.variableDefinitions || [];
    if (definition.name && definition.name.kind === "Name") {
      name = definition.name.value;
    } else {
      name = "data";
    }
    var payload = { name, type, variables };
    cache3.set(document2, payload);
    return payload;
  }
  function verifyDocumentType(document2, type) {
    var operation = parser(document2);
    var requiredOperationName = operationName(type);
    var usedOperationName = operationName(operation.type);
    __DEV__ ? invariant2(operation.type === type, "Running a ".concat(requiredOperationName, " requires a graphql ") + "".concat(requiredOperationName, ", but a ").concat(usedOperationName, " was used instead.")) : invariant2(operation.type === type, 34);
  }

  // node_modules/@apollo/client/react/hooks/useQuery.js
  var hasOwnProperty6 = Object.prototype.hasOwnProperty;
  function useQuery(query, options) {
    if (options === void 0) {
      options = /* @__PURE__ */ Object.create(null);
    }
    return useInternalState(useApolloClient(options.client), query).useQuery(options);
  }
  function useInternalState(client, query) {
    var stateRef = (0, import_react114.useRef)();
    if (!stateRef.current || client !== stateRef.current.client || query !== stateRef.current.query) {
      stateRef.current = new InternalState(client, query, stateRef.current);
    }
    var state = stateRef.current;
    var _a5 = (0, import_react114.useState)(0), _tick = _a5[0], setTick = _a5[1];
    state.forceUpdate = function() {
      setTick(function(tick) {
        return tick + 1;
      });
    };
    return state;
  }
  var InternalState = function() {
    function InternalState2(client, query, previous) {
      this.client = client;
      this.query = query;
      this.asyncResolveFns = /* @__PURE__ */ new Set();
      this.optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)();
      this.ssrDisabledResult = maybeDeepFreeze({
        loading: true,
        data: void 0,
        error: void 0,
        networkStatus: NetworkStatus.loading
      });
      this.skipStandbyResult = maybeDeepFreeze({
        loading: false,
        data: void 0,
        error: void 0,
        networkStatus: NetworkStatus.ready
      });
      this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();
      verifyDocumentType(query, DocumentType.Query);
      var previousResult = previous && previous.result;
      var previousData = previousResult && previousResult.data;
      if (previousData) {
        this.previousData = previousData;
      }
    }
    InternalState2.prototype.forceUpdate = function() {
      __DEV__ && invariant2.warn("Calling default no-op implementation of InternalState#forceUpdate");
    };
    InternalState2.prototype.asyncUpdate = function() {
      var _this = this;
      return new Promise(function(resolve) {
        _this.asyncResolveFns.add(resolve);
        _this.optionsToIgnoreOnce.add(_this.watchQueryOptions);
        _this.forceUpdate();
      });
    };
    InternalState2.prototype.useQuery = function(options) {
      var _this = this;
      this.renderPromises = (0, import_react114.useContext)(getApolloContext()).renderPromises;
      this.useOptions(options);
      var obsQuery = this.useObservableQuery();
      var result2 = useSyncExternalStore((0, import_react114.useCallback)(function() {
        if (_this.renderPromises) {
          return function() {
          };
        }
        var onNext = function() {
          var previousResult = _this.result;
          var result3 = obsQuery.getCurrentResult();
          if (previousResult && previousResult.loading === result3.loading && previousResult.networkStatus === result3.networkStatus && equal(previousResult.data, result3.data)) {
            return;
          }
          _this.setResult(result3);
        };
        var onError = function(error) {
          var last = obsQuery["last"];
          subscription.unsubscribe();
          try {
            obsQuery.resetLastResults();
            subscription = obsQuery.subscribe(onNext, onError);
          } finally {
            obsQuery["last"] = last;
          }
          if (!hasOwnProperty6.call(error, "graphQLErrors")) {
            throw error;
          }
          var previousResult = _this.result;
          if (!previousResult || previousResult && previousResult.loading || !equal(error, previousResult.error)) {
            _this.setResult({
              data: previousResult && previousResult.data,
              error,
              loading: false,
              networkStatus: NetworkStatus.error
            });
          }
        };
        var subscription = obsQuery.subscribe(onNext, onError);
        return function() {
          return subscription.unsubscribe();
        };
      }, [
        obsQuery,
        this.renderPromises,
        this.client.disableNetworkFetches
      ]), function() {
        return _this.getCurrentResult();
      }, function() {
        return _this.getCurrentResult();
      });
      this.unsafeHandlePartialRefetch(result2);
      var queryResult = this.toQueryResult(result2);
      if (!queryResult.loading && this.asyncResolveFns.size) {
        this.asyncResolveFns.forEach(function(resolve) {
          return resolve(queryResult);
        });
        this.asyncResolveFns.clear();
      }
      return queryResult;
    };
    InternalState2.prototype.useOptions = function(options) {
      var _a5;
      var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);
      var currentWatchQueryOptions = this.watchQueryOptions;
      if (this.optionsToIgnoreOnce.has(currentWatchQueryOptions) || !equal(watchQueryOptions, currentWatchQueryOptions)) {
        this.watchQueryOptions = watchQueryOptions;
        if (currentWatchQueryOptions && this.observable) {
          this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);
          this.observable.reobserve(this.getObsQueryOptions());
          this.previousData = ((_a5 = this.result) === null || _a5 === void 0 ? void 0 : _a5.data) || this.previousData;
          this.result = void 0;
        }
      }
      this.onCompleted = options.onCompleted || InternalState2.prototype.onCompleted;
      this.onError = options.onError || InternalState2.prototype.onError;
      if ((this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === false && !this.queryHookOptions.skip) {
        this.result = this.ssrDisabledResult;
      } else if (this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === "standby") {
        this.result = this.skipStandbyResult;
      } else if (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) {
        this.result = void 0;
      }
    };
    InternalState2.prototype.getObsQueryOptions = function() {
      var toMerge = [];
      var globalDefaults = this.client.defaultOptions.watchQuery;
      if (globalDefaults)
        toMerge.push(globalDefaults);
      if (this.queryHookOptions.defaultOptions) {
        toMerge.push(this.queryHookOptions.defaultOptions);
      }
      toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));
      return toMerge.reduce(mergeOptions);
    };
    InternalState2.prototype.createWatchQueryOptions = function(_a5) {
      var _b;
      if (_a5 === void 0) {
        _a5 = {};
      }
      var skip = _a5.skip, ssr = _a5.ssr, onCompleted = _a5.onCompleted, onError = _a5.onError, displayName = _a5.displayName, defaultOptions2 = _a5.defaultOptions, otherOptions = __rest2(_a5, ["skip", "ssr", "onCompleted", "onError", "displayName", "defaultOptions"]);
      var watchQueryOptions = Object.assign(otherOptions, { query: this.query });
      if (this.renderPromises && (watchQueryOptions.fetchPolicy === "network-only" || watchQueryOptions.fetchPolicy === "cache-and-network")) {
        watchQueryOptions.fetchPolicy = "cache-first";
      }
      if (!watchQueryOptions.variables) {
        watchQueryOptions.variables = {};
      }
      if (skip) {
        var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;
        Object.assign(watchQueryOptions, {
          initialFetchPolicy,
          fetchPolicy: "standby"
        });
      } else if (!watchQueryOptions.fetchPolicy) {
        watchQueryOptions.fetchPolicy = ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) || this.getDefaultFetchPolicy();
      }
      return watchQueryOptions;
    };
    InternalState2.prototype.getDefaultFetchPolicy = function() {
      var _a5, _b;
      return ((_a5 = this.queryHookOptions.defaultOptions) === null || _a5 === void 0 ? void 0 : _a5.fetchPolicy) || ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "cache-first";
    };
    InternalState2.prototype.onCompleted = function(data) {
    };
    InternalState2.prototype.onError = function(error) {
    };
    InternalState2.prototype.useObservableQuery = function() {
      var obsQuery = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable || this.client.watchQuery(this.getObsQueryOptions());
      this.obsQueryFields = (0, import_react114.useMemo)(function() {
        return {
          refetch: obsQuery.refetch.bind(obsQuery),
          reobserve: obsQuery.reobserve.bind(obsQuery),
          fetchMore: obsQuery.fetchMore.bind(obsQuery),
          updateQuery: obsQuery.updateQuery.bind(obsQuery),
          startPolling: obsQuery.startPolling.bind(obsQuery),
          stopPolling: obsQuery.stopPolling.bind(obsQuery),
          subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)
        };
      }, [obsQuery]);
      var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);
      if (this.renderPromises && ssrAllowed) {
        this.renderPromises.registerSSRObservable(obsQuery);
        if (obsQuery.getCurrentResult().loading) {
          this.renderPromises.addObservableQueryPromise(obsQuery);
        }
      }
      return obsQuery;
    };
    InternalState2.prototype.setResult = function(nextResult) {
      var previousResult = this.result;
      if (previousResult && previousResult.data) {
        this.previousData = previousResult.data;
      }
      this.result = nextResult;
      this.forceUpdate();
      this.handleErrorOrCompleted(nextResult);
    };
    InternalState2.prototype.handleErrorOrCompleted = function(result2) {
      if (!result2.loading) {
        if (result2.error) {
          this.onError(result2.error);
        } else if (result2.data) {
          this.onCompleted(result2.data);
        }
      }
    };
    InternalState2.prototype.getCurrentResult = function() {
      if (!this.result) {
        this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());
      }
      return this.result;
    };
    InternalState2.prototype.toQueryResult = function(result2) {
      var queryResult = this.toQueryResultCache.get(result2);
      if (queryResult)
        return queryResult;
      var data = result2.data, partial = result2.partial, resultWithoutPartial = __rest2(result2, ["data", "partial"]);
      this.toQueryResultCache.set(result2, queryResult = __assign2(__assign2(__assign2({ data }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData }));
      if (!queryResult.error && isNonEmptyArray(result2.errors)) {
        queryResult.error = new ApolloError({ graphQLErrors: result2.errors });
      }
      return queryResult;
    };
    InternalState2.prototype.unsafeHandlePartialRefetch = function(result2) {
      if (result2.partial && this.queryHookOptions.partialRefetch && !result2.loading && (!result2.data || Object.keys(result2.data).length === 0) && this.observable.options.fetchPolicy !== "cache-only") {
        Object.assign(result2, {
          loading: true,
          networkStatus: NetworkStatus.refetch
        });
        this.observable.refetch();
      }
    };
    return InternalState2;
  }();

  // node_modules/@apollo/client/react/hooks/useMutation.js
  var import_react115 = __toESM(require_react(), 1);
  function useMutation(mutation, options) {
    var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
    verifyDocumentType(mutation, DocumentType.Mutation);
    var _a5 = (0, import_react115.useState)({
      called: false,
      loading: false,
      client
    }), result2 = _a5[0], setResult = _a5[1];
    var ref = (0, import_react115.useRef)({
      result: result2,
      mutationId: 0,
      isMounted: true,
      client,
      mutation,
      options
    });
    {
      Object.assign(ref.current, { client, options, mutation });
    }
    var execute2 = (0, import_react115.useCallback)(function(executeOptions) {
      if (executeOptions === void 0) {
        executeOptions = {};
      }
      var _a6 = ref.current, client2 = _a6.client, options2 = _a6.options, mutation2 = _a6.mutation;
      var baseOptions = __assign2(__assign2({}, options2), { mutation: mutation2 });
      if (!ref.current.result.loading && !baseOptions.ignoreResults) {
        setResult(ref.current.result = {
          loading: true,
          error: void 0,
          data: void 0,
          called: true,
          client: client2
        });
      }
      var mutationId = ++ref.current.mutationId;
      var clientOptions = mergeOptions(baseOptions, executeOptions);
      return client2.mutate(clientOptions).then(function(response) {
        var _a7, _b, _c;
        var data = response.data, errors = response.errors;
        var error = errors && errors.length > 0 ? new ApolloError({ graphQLErrors: errors }) : void 0;
        if (mutationId === ref.current.mutationId && !clientOptions.ignoreResults) {
          var result_1 = {
            called: true,
            loading: false,
            data,
            error,
            client: client2
          };
          if (ref.current.isMounted && !equal(ref.current.result, result_1)) {
            setResult(ref.current.result = result_1);
          }
        }
        (_b = (_a7 = ref.current.options) === null || _a7 === void 0 ? void 0 : _a7.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a7, response.data);
        (_c = executeOptions.onCompleted) === null || _c === void 0 ? void 0 : _c.call(executeOptions, response.data);
        return response;
      }).catch(function(error) {
        var _a7, _b, _c, _d;
        if (mutationId === ref.current.mutationId && ref.current.isMounted) {
          var result_2 = {
            loading: false,
            error,
            data: void 0,
            called: true,
            client: client2
          };
          if (!equal(ref.current.result, result_2)) {
            setResult(ref.current.result = result_2);
          }
        }
        if (((_a7 = ref.current.options) === null || _a7 === void 0 ? void 0 : _a7.onError) || clientOptions.onError) {
          (_c = (_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onError) === null || _c === void 0 ? void 0 : _c.call(_b, error);
          (_d = executeOptions.onError) === null || _d === void 0 ? void 0 : _d.call(executeOptions, error);
          return { data: void 0, errors: error };
        }
        throw error;
      });
    }, []);
    var reset = (0, import_react115.useCallback)(function() {
      setResult({ called: false, loading: false, client });
    }, []);
    (0, import_react115.useEffect)(function() {
      ref.current.isMounted = true;
      return function() {
        ref.current.isMounted = false;
      };
    }, []);
    return [execute2, __assign2({ reset }, result2)];
  }

  // src/components/Users/usersgql.js
  var GET_USERS = gql`
	query Query($offset: Int, $limit: Int) {
		users(offset: $offset, limit: $limit) {
			name
			rocket
			twitter
			id
		}
	}
`;
  var GET_USER = gql`
	query Query($userid: uuid!) {
		users_by_pk(id: $userid) {
			id
			name
			rocket
			twitter
		}
	}
`;
  var ADD_USER = gql`
	mutation Mutation($objects: [users_insert_input!]!) {
		insert_users(objects: $objects) {
			returning {
				name
				rocket
				twitter
				id
			}
		}
	}
`;
  var UPDATE_USER = gql`
	mutation Mutation($set: users_set_input, $where: users_bool_exp!) {
		update_users(_set: $set, where: $where) {
			returning {
				id
				name
				twitter
				rocket
			}
		}
	}
`;
  var DELETE_USER = gql`
	mutation Delete_users($where: users_bool_exp!) {
		delete_users(where: $where) {
			returning {
				name
			}
		}
	}
`;

  // src/components/Users/users.jsx
  function Users() {
    let location = useLocation();
    const { error, data, networkStatus, fetchMore } = useQuery(GET_USERS, {
      variables: {
        offset: 0,
        limit: 20
      },
      fetchPolicy: "cache-and-network"
    });
    if (networkStatus === NetworkStatus.loading)
      return /* @__PURE__ */ import_react116.default.createElement("div", null, /* @__PURE__ */ import_react116.default.createElement(Frame, null, /* @__PURE__ */ import_react116.default.createElement(Loading2, null)));
    if (error)
      return /* @__PURE__ */ import_react116.default.createElement("p", null, "Error :");
    return /* @__PURE__ */ import_react116.default.createElement("div", {
      className: "w-full h-full overflow-scroll p-6 rounded-xl shadow-lg items-center space-x-4 border-r-4"
    }, /* @__PURE__ */ import_react116.default.createElement("div", {
      className: "text-right block mb-10"
    }, /* @__PURE__ */ import_react116.default.createElement(Link, {
      to: { pathname: "/adduser", state: { background: location } },
      className: "btn btn-primary"
    }, /* @__PURE__ */ import_react116.default.createElement(Button, {
      primary: true
    }, "Add New User"))), /* @__PURE__ */ import_react116.default.createElement(user_default, {
      users: data.users,
      fetchMore
    }));
  }
  var users_default = Users;

  // src/components/Users/NewUser.jsx
  var import_react118 = __toESM(require_react());

  // src/components/Users/UserForm.jsx
  var import_react117 = __toESM(require_react());
  function UserForm({ user, addUpdateUser, goBack }) {
    const [userDetail, setUserDetails] = (0, import_react117.useState)({});
    const handleSubmit = () => {
      addUpdateUser(userDetail);
    };
    const onInputChange = (type, value) => {
      let obj = {
        [type]: value
      };
      let users = { ...userDetail, ...obj };
      setUserDetails(users);
    };
    (0, import_react117.useEffect)(() => {
      setUserDetails(user);
    }, [user]);
    return /* @__PURE__ */ import_react117.default.createElement("div", null, /* @__PURE__ */ import_react117.default.createElement(Form, {
      onSubmit: handleSubmit
    }, /* @__PURE__ */ import_react117.default.createElement(FormLayout, null, /* @__PURE__ */ import_react117.default.createElement(TextField, {
      value: userDetail?.name || "",
      onChange: (e) => onInputChange("name", e),
      label: "Name",
      type: "text"
    }), /* @__PURE__ */ import_react117.default.createElement(TextField, {
      onChange: (e) => onInputChange("rocket", e),
      value: userDetail?.rocket || "",
      label: "Rocket",
      type: "text"
    }), /* @__PURE__ */ import_react117.default.createElement(TextField, {
      value: userDetail?.twitter || "",
      label: "Twitter ID",
      type: "text",
      onChange: (e) => onInputChange("twitter", e)
    }), /* @__PURE__ */ import_react117.default.createElement("div", null, /* @__PURE__ */ import_react117.default.createElement("div", {
      className: "inline-block mr-5"
    }, /* @__PURE__ */ import_react117.default.createElement(Button, {
      className: "text-right",
      onClick: (e) => goBack(e)
    }, "<", " Back")), /* @__PURE__ */ import_react117.default.createElement("div", {
      className: "inline-block "
    }, /* @__PURE__ */ import_react117.default.createElement(Button, {
      primary: true,
      className: "text-right mr-5",
      submit: true
    }, user ? "Update user" : "Create user"))))));
  }
  var UserForm_default = UserForm;

  // src/components/Users/UserCache.jsx
  function WriteUsers(user, cache4, existingUsers) {
    let usersQuery = GET_USERS;
    cache4.writeQuery({
      query: usersQuery,
      data: {
        users: [user, ...existingUsers]
      },
      variables: {
        id: user.id
      }
    });
  }

  // src/components/Users/NewUser.jsx
  function NewUser() {
    let history = useHistory();
    let back = () => {
      history.goBack();
    };
    const [addUser, { data, error, loading }] = useMutation(ADD_USER, {
      update(cache4, { data: data2 }) {
        cache4.modify({
          fields: {
            users(existingUsers = []) {
              WriteUsers(data2.insert_users.returning[0], cache4, existingUsers);
            }
          }
        });
      }
    });
    if (loading)
      return "creating new users...";
    if (error)
      return `Failed to create user  ${error.message}`;
    if (data) {
      back();
    }
    function addUpdateUser(userDetail) {
      let newuser = {
        objects: [userDetail]
      };
      addUser({ variables: newuser });
    }
    return /* @__PURE__ */ import_react118.default.createElement("div", {
      style: {
        position: "absolute",
        background: "#fff",
        top: 25,
        left: "10%",
        right: "10%",
        padding: 15
      }
    }, /* @__PURE__ */ import_react118.default.createElement(Modal, {
      onClose: back,
      open: "true",
      title: "Create New User"
    }, /* @__PURE__ */ import_react118.default.createElement(Modal.Section, null, /* @__PURE__ */ import_react118.default.createElement(UserForm_default, {
      addUpdateUser,
      goBack: back
    }))));
  }
  var NewUser_default = NewUser;

  // src/components/Users/UserDetail.jsx
  var import_react119 = __toESM(require_react());
  function UserDetail() {
    let history = useHistory();
    let back = () => {
      history.goBack();
    };
    let { userid: user } = useParams();
    const { data, loading, error } = useQuery(GET_USER, {
      variables: {
        userid: user
      },
      fetchPolicy: "cache-and-network"
    });
    const [updateUser, { data: updatedUsers }] = useMutation(UPDATE_USER, {
      onError(error2) {
        return `Failed to get user details ->   ${error2.message}`;
      },
      update(cache4, { data: data2 }) {
        cache4.modify({
          fields: {
            users(existingUsers = []) {
              WriteUsers(data2.update_users.returning[0], cache4, existingUsers);
            }
          }
        });
      }
    });
    if (updatedUsers) {
      back();
    }
    function addUpdateUser(users) {
      let updateObj = {
        set: users,
        where: {
          id: {
            _eq: user
          }
        }
      };
      updateUser({ variables: updateObj });
    }
    if (loading) {
      return /* @__PURE__ */ import_react119.default.createElement(Spinner, {
        accessibilityLabel: "Spinner",
        size: "large"
      });
    }
    if (error)
      return `Failed to get user details -> ${error.message}`;
    if (data)
      return /* @__PURE__ */ import_react119.default.createElement("div", {
        style: {
          position: "fixed",
          background: "#fff",
          top: "10%",
          left: "10%",
          right: "10%",
          padding: 15
        }
      }, /* @__PURE__ */ import_react119.default.createElement(Modal, {
        onClose: back,
        open: "true",
        className: "font-extrabold",
        title: "Edit User"
      }, /* @__PURE__ */ import_react119.default.createElement(Modal.Section, null, /* @__PURE__ */ import_react119.default.createElement(UserForm_default, {
        user: data.users_by_pk,
        addUpdateUser,
        goBack: back
      }))));
  }
  var UserDetail_default = UserDetail;

  // src/components/Users/DeleteUser.jsx
  var import_react120 = __toESM(require_react());
  function DeleteUser() {
    let history = useHistory();
    let back = () => {
      history.goBack();
    };
    let { userid } = useParams();
    console.log(userid);
    const [delete_user, { error }] = useMutation(DELETE_USER, {
      refetchQueries: [{ query: GET_USERS }]
    });
    const deleteUser = async () => {
      let deleteObj = {
        where: {
          id: {
            _eq: userid
          }
        }
      };
      await delete_user({ variables: deleteObj });
      return history.goBack();
    };
    if (error) {
      return "failed to delete the user";
    }
    return /* @__PURE__ */ import_react120.default.createElement("div", {
      style: {
        position: "absolute",
        background: "#fff",
        top: 25,
        left: "10%",
        right: "10%",
        padding: 15
      }
    }, /* @__PURE__ */ import_react120.default.createElement(Modal, {
      onClose: back,
      open: "true",
      title: "Are you sure you want to delete the user?",
      primaryAction: {
        content: "Delete User",
        onAction: deleteUser
      },
      secondaryActions: [
        {
          content: "Cancel",
          onAction: back
        }
      ]
    }));
  }
  var DeleteUser_default = DeleteUser;

  // src/components/Users/RoutesSwitch.jsx
  function RoutesSwitch() {
    let location = useLocation();
    let background = location.state && location.state.background;
    return /* @__PURE__ */ import_react121.default.createElement("div", {
      className: "h-screen w-full"
    }, /* @__PURE__ */ import_react121.default.createElement(Switch, {
      location: background || location
    }, /* @__PURE__ */ import_react121.default.createElement(Route, {
      path: "/users/:userid"
    }, /* @__PURE__ */ import_react121.default.createElement(UserDetail_default, null)), /* @__PURE__ */ import_react121.default.createElement(Route, {
      path: "/adduser"
    }, /* @__PURE__ */ import_react121.default.createElement(NewUser_default, null)), /* @__PURE__ */ import_react121.default.createElement(Route, {
      path: "/"
    }, /* @__PURE__ */ import_react121.default.createElement(users_default, null))), background && /* @__PURE__ */ import_react121.default.createElement(Route, {
      path: "/adduser",
      children: /* @__PURE__ */ import_react121.default.createElement(NewUser_default, null)
    }), background && /* @__PURE__ */ import_react121.default.createElement(Route, {
      exact: true,
      path: "/users/delete/:userid",
      children: /* @__PURE__ */ import_react121.default.createElement(DeleteUser_default, null)
    }), background && /* @__PURE__ */ import_react121.default.createElement(Route, {
      exact: true,
      path: "/users/:userid",
      children: /* @__PURE__ */ import_react121.default.createElement(UserDetail_default, null)
    }));
  }
  var RoutesSwitch_default = RoutesSwitch;

  // src/components/app.jsx
  function App() {
    return /* @__PURE__ */ import_react122.default.createElement(AppProvider, null, /* @__PURE__ */ import_react122.default.createElement(BrowserRouter, null, /* @__PURE__ */ import_react122.default.createElement(RoutesSwitch_default, null)));
  }
  var app_default = App;
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
/** @license React v0.19.1
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v0.19.1
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v16.14.0
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v16.14.0
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
